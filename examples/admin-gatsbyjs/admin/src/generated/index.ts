import gql from 'graphql-tag';
import * as ApolloReactCommon from '@apollo/client';
import * as ApolloReactHooks from '@apollo/client';
export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Date custom scalar type */
  DateTime: any;
  Upload: any;
};

export type Activity = {
  __typename?: 'Activity';
  color?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  day: Scalars['DateTime'];
  id: Scalars['Int'];
  person: Person;
  personId: Scalars['Int'];
  title: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type ActivityCreateInput = {
  color?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  day: Scalars['DateTime'];
  person: PersonCreateOneWithoutActivitiesInput;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type ActivityCreateManyWithoutPersonInput = {
  connect?: Maybe<Array<ActivityWhereUniqueInput>>;
  create?: Maybe<Array<ActivityCreateWithoutPersonInput>>;
};

export type ActivityCreateWithoutPersonInput = {
  color?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  day: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type ActivityFilter = {
  every?: Maybe<ActivityWhereInput>;
  none?: Maybe<ActivityWhereInput>;
  some?: Maybe<ActivityWhereInput>;
};

export type ActivityOrderByInput = {
  color?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  day?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  person?: Maybe<OrderByArg>;
  personId?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type ActivityScalarWhereInput = {
  AND?: Maybe<Array<ActivityScalarWhereInput>>;
  color?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  day?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<ActivityScalarWhereInput>>;
  OR?: Maybe<Array<ActivityScalarWhereInput>>;
  personId?: Maybe<IntFilter>;
  title?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type ActivityUpdateInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneRequiredWithoutActivitiesInput>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type ActivityUpdateManyDataInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type ActivityUpdateManyMutationInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type ActivityUpdateManyWithoutPersonInput = {
  connect?: Maybe<Array<ActivityWhereUniqueInput>>;
  create?: Maybe<Array<ActivityCreateWithoutPersonInput>>;
  delete?: Maybe<Array<ActivityWhereUniqueInput>>;
  deleteMany?: Maybe<Array<ActivityScalarWhereInput>>;
  disconnect?: Maybe<Array<ActivityWhereUniqueInput>>;
  set?: Maybe<Array<ActivityWhereUniqueInput>>;
  update?: Maybe<Array<ActivityUpdateWithWhereUniqueWithoutPersonInput>>;
  updateMany?: Maybe<Array<ActivityUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<ActivityUpsertWithWhereUniqueWithoutPersonInput>>;
};

export type ActivityUpdateManyWithWhereNestedInput = {
  data: ActivityUpdateManyDataInput;
  where: ActivityScalarWhereInput;
};

export type ActivityUpdateWithoutPersonDataInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type ActivityUpdateWithWhereUniqueWithoutPersonInput = {
  data: ActivityUpdateWithoutPersonDataInput;
  where: ActivityWhereUniqueInput;
};

export type ActivityUpsertWithWhereUniqueWithoutPersonInput = {
  create: ActivityCreateWithoutPersonInput;
  update: ActivityUpdateWithoutPersonDataInput;
  where: ActivityWhereUniqueInput;
};

export type ActivityWhereInput = {
  AND?: Maybe<Array<ActivityWhereInput>>;
  color?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  day?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<ActivityWhereInput>>;
  OR?: Maybe<Array<ActivityWhereInput>>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  title?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type ActivityWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AllowedDays = {
  __typename?: 'AllowedDays';
  allowed: Array<Scalars['String']>;
  disabled: Array<Scalars['String']>;
};

export type AssessmentContentQuestion = {
  __typename?: 'AssessmentContentQuestion';
  assessmentContentQuestionAnswers: Array<AssessmentContentQuestionAnswer>;
  assessmentContentQuestionOptions: Array<AssessmentContentQuestionOption>;
  assessmentContentQuestionTools: Array<AssessmentContentQuestionTool>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionType>;
  assessmentContentQuestionTypeId?: Maybe<Scalars['Int']>;
  assessmentTakingQuestions: Array<AssessmentTakingQuestion>;
  assignmentContent?: Maybe<AssignmentContent>;
  assignmentContentId?: Maybe<Scalars['Int']>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  feedback?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  isAllOrNothing: Scalars['Boolean'];
  isInactive: Scalars['Boolean'];
  isOrLogic: Scalars['Boolean'];
  maxScore: Scalars['Float'];
  order?: Maybe<Scalars['Int']>;
  text: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type AssessmentContentQuestionAssessmentContentQuestionAnswersArgs = {
  after?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionAnswerOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
};

export type AssessmentContentQuestionAssessmentContentQuestionOptionsArgs = {
  after?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOptionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type AssessmentContentQuestionAssessmentContentQuestionToolsArgs = {
  after?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionToolOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
};

export type AssessmentContentQuestionAssessmentTakingQuestionsArgs = {
  after?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type AssessmentContentQuestionAnswer = {
  __typename?: 'AssessmentContentQuestionAnswer';
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestion>;
  assessmentContentQuestionId?: Maybe<Scalars['Int']>;
  assessmentContentQuestionOptions: Array<AssessmentContentQuestionOption>;
  assessmentTakingResponses: Array<AssessmentTakingResponse>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  isInactive: Scalars['Boolean'];
  order?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
};

export type AssessmentContentQuestionAnswerAssessmentContentQuestionOptionsArgs = {
  after?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOptionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type AssessmentContentQuestionAnswerAssessmentTakingResponsesArgs = {
  after?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  before?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingResponseOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type AssessmentContentQuestionAnswerCreateInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionAnswersInput>;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionAnswerInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionAnswerInput>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerCreateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentContentQuestionAnswerWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentContentQuestionAnswerCreateOneWithoutAssessmentContentQuestionOptionsInput = {
  connect?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionOptionsInput>;
};

export type AssessmentContentQuestionAnswerCreateOneWithoutAssessmentTakingResponsesInput = {
  connect?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionAnswerCreateWithoutAssessmentTakingResponsesInput>;
};

export type AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionAnswerInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionAnswerInput>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionOptionsInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionAnswersInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionAnswerInput>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerCreateWithoutAssessmentTakingResponsesInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionAnswersInput>;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionAnswerInput
  >;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerFilter = {
  every?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
  none?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
  some?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
};

export type AssessmentContentQuestionAnswerOrderByInput = {
  answer?: Maybe<OrderByArg>;
  assessmentContentQuestion?: Maybe<OrderByArg>;
  assessmentContentQuestionId?: Maybe<OrderByArg>;
  ccQXId?: Maybe<OrderByArg>;
  ccXId?: Maybe<OrderByArg>;
  courseCodeXId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isInactive?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssessmentContentQuestionAnswerScalarWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionAnswerScalarWhereInput>>;
  answer?: Maybe<NullableStringFilter>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  assessmentContentQuestionOptions?: Maybe<AssessmentContentQuestionOptionFilter>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseFilter>;
  ccQXId?: Maybe<NullableStringFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isInactive?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionAnswerScalarWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionAnswerScalarWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionAnswerUpdateInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionAnswersInput>;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionAnswerInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionAnswerInput>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerUpdateManyDataInput = {
  answer?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerUpdateManyMutationInput = {
  answer?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerUpdateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentContentQuestionAnswerWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionInput>>;
  delete?: Maybe<Array<AssessmentContentQuestionAnswerWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentContentQuestionAnswerScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentContentQuestionAnswerWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentContentQuestionAnswerWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentContentQuestionAnswerUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
  updateMany?: Maybe<Array<AssessmentContentQuestionAnswerUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentContentQuestionAnswerUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentContentQuestionAnswerUpdateManyWithWhereNestedInput = {
  data: AssessmentContentQuestionAnswerUpdateManyDataInput;
  where: AssessmentContentQuestionAnswerScalarWhereInput;
};

export type AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentContentQuestionOptionsInput = {
  connect?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionOptionsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionAnswerUpdateWithoutAssessmentContentQuestionOptionsDataInput>;
  upsert?: Maybe<AssessmentContentQuestionAnswerUpsertWithoutAssessmentContentQuestionOptionsInput>;
};

export type AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentTakingResponsesInput = {
  connect?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionAnswerCreateWithoutAssessmentTakingResponsesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionAnswerUpdateWithoutAssessmentTakingResponsesDataInput>;
  upsert?: Maybe<AssessmentContentQuestionAnswerUpsertWithoutAssessmentTakingResponsesInput>;
};

export type AssessmentContentQuestionAnswerUpdateWithoutAssessmentContentQuestionDataInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionAnswerInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionAnswerInput>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerUpdateWithoutAssessmentContentQuestionOptionsDataInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionAnswersInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionAnswerInput>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerUpdateWithoutAssessmentTakingResponsesDataInput = {
  answer?: Maybe<Scalars['String']>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionAnswersInput>;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionAnswerInput
  >;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionAnswerUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  data: AssessmentContentQuestionAnswerUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
};

export type AssessmentContentQuestionAnswerUpsertWithoutAssessmentContentQuestionOptionsInput = {
  create: AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionOptionsInput;
  update: AssessmentContentQuestionAnswerUpdateWithoutAssessmentContentQuestionOptionsDataInput;
};

export type AssessmentContentQuestionAnswerUpsertWithoutAssessmentTakingResponsesInput = {
  create: AssessmentContentQuestionAnswerCreateWithoutAssessmentTakingResponsesInput;
  update: AssessmentContentQuestionAnswerUpdateWithoutAssessmentTakingResponsesDataInput;
};

export type AssessmentContentQuestionAnswerUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  create: AssessmentContentQuestionAnswerCreateWithoutAssessmentContentQuestionInput;
  update: AssessmentContentQuestionAnswerUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
};

export type AssessmentContentQuestionAnswerWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionAnswerWhereInput>>;
  answer?: Maybe<NullableStringFilter>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionWhereInput>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  assessmentContentQuestionOptions?: Maybe<AssessmentContentQuestionOptionFilter>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseFilter>;
  ccQXId?: Maybe<NullableStringFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isInactive?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionAnswerWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionAnswerWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionAnswerWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssessmentContentQuestionCreateInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolCreateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeCreateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionCreateManyWithoutAssessmentContentQuestionTypeInput = {
  connect?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionTypeInput>>;
};

export type AssessmentContentQuestionCreateManyWithoutAssignmentContentInput = {
  connect?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionCreateWithoutAssignmentContentInput>>;
};

export type AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionAnswersInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionAnswersInput>;
};

export type AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionOptionsInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionOptionsInput>;
};

export type AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionToolsInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionToolsInput>;
};

export type AssessmentContentQuestionCreateOneWithoutAssessmentTakingQuestionsInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentTakingQuestionsInput>;
};

export type AssessmentContentQuestionCreateWithoutAssessmentContentQuestionAnswersInput = {
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolCreateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeCreateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionCreateWithoutAssessmentContentQuestionOptionsInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolCreateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeCreateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionCreateWithoutAssessmentContentQuestionToolsInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeCreateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionCreateWithoutAssessmentContentQuestionTypeInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolCreateManyWithoutAssessmentContentQuestionInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionCreateWithoutAssessmentTakingQuestionsInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolCreateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeCreateOneWithoutAssessmentContentQuestionsInput>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionCreateWithoutAssignmentContentInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolCreateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeCreateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssessmentContentQuestionInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionFilter = {
  every?: Maybe<AssessmentContentQuestionWhereInput>;
  none?: Maybe<AssessmentContentQuestionWhereInput>;
  some?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type AssessmentContentQuestionOption = {
  __typename?: 'AssessmentContentQuestionOption';
  assessmentContentQuestion?: Maybe<AssessmentContentQuestion>;
  assessmentContentQuestionAnswer?: Maybe<AssessmentContentQuestionAnswer>;
  assessmentContentQuestionAnswerId?: Maybe<Scalars['Int']>;
  assessmentContentQuestionId?: Maybe<Scalars['Int']>;
  assessmentTakingResponses: Array<AssessmentTakingResponse>;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  isInactive: Scalars['Boolean'];
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type AssessmentContentQuestionOptionAssessmentTakingResponsesArgs = {
  after?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  before?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingResponseOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type AssessmentContentQuestionOptionCreateInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionOptionsInput>;
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerCreateOneWithoutAssessmentContentQuestionOptionsInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionOptionInput>;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionAnswerInput = {
  connect?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionAnswerInput>>;
};

export type AssessmentContentQuestionOptionCreateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentContentQuestionOptionCreateOneWithoutAssessmentTakingResponsesInput = {
  connect?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionOptionCreateWithoutAssessmentTakingResponsesInput>;
};

export type AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionAnswerInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionOptionsInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionOptionInput>;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerCreateOneWithoutAssessmentContentQuestionOptionsInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionOptionInput>;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionCreateWithoutAssessmentTakingResponsesInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionOptionsInput>;
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerCreateOneWithoutAssessmentContentQuestionOptionsInput
  >;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionFilter = {
  every?: Maybe<AssessmentContentQuestionOptionWhereInput>;
  none?: Maybe<AssessmentContentQuestionOptionWhereInput>;
  some?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type AssessmentContentQuestionOptionOrderByInput = {
  assessmentContentQuestion?: Maybe<OrderByArg>;
  assessmentContentQuestionAnswer?: Maybe<OrderByArg>;
  assessmentContentQuestionAnswerId?: Maybe<OrderByArg>;
  assessmentContentQuestionId?: Maybe<OrderByArg>;
  ccQAXId?: Maybe<OrderByArg>;
  ccQXId?: Maybe<OrderByArg>;
  ccXId?: Maybe<OrderByArg>;
  courseCodeXId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isInactive?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  score?: Maybe<OrderByArg>;
  text?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssessmentContentQuestionOptionScalarWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionOptionScalarWhereInput>>;
  assessmentContentQuestionAnswerId?: Maybe<NullableIntFilter>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseFilter>;
  ccQAXId?: Maybe<NullableStringFilter>;
  ccQXId?: Maybe<NullableStringFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isInactive?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionOptionScalarWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionOptionScalarWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  score?: Maybe<NullableFloatFilter>;
  text?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionOptionUpdateInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionOptionsInput>;
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentContentQuestionOptionsInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionOptionInput>;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionUpdateManyDataInput = {
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionUpdateManyMutationInput = {
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionAnswerInput = {
  connect?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionAnswerInput>>;
  delete?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentContentQuestionOptionScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  update?: Maybe<
    Array<AssessmentContentQuestionOptionUpdateWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput>
  >;
  updateMany?: Maybe<Array<AssessmentContentQuestionOptionUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<
    Array<AssessmentContentQuestionOptionUpsertWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput>
  >;
};

export type AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionInput>>;
  delete?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentContentQuestionOptionScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentContentQuestionOptionWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentContentQuestionOptionUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
  updateMany?: Maybe<Array<AssessmentContentQuestionOptionUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentContentQuestionOptionUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentContentQuestionOptionUpdateManyWithWhereNestedInput = {
  data: AssessmentContentQuestionOptionUpdateManyDataInput;
  where: AssessmentContentQuestionOptionScalarWhereInput;
};

export type AssessmentContentQuestionOptionUpdateOneWithoutAssessmentTakingResponsesInput = {
  connect?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionOptionCreateWithoutAssessmentTakingResponsesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionOptionUpdateWithoutAssessmentTakingResponsesDataInput>;
  upsert?: Maybe<AssessmentContentQuestionOptionUpsertWithoutAssessmentTakingResponsesInput>;
};

export type AssessmentContentQuestionOptionUpdateWithoutAssessmentContentQuestionAnswerDataInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionOptionsInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionOptionInput>;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionUpdateWithoutAssessmentContentQuestionDataInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentContentQuestionOptionsInput
  >;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionOptionInput>;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionUpdateWithoutAssessmentTakingResponsesDataInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionOptionsInput>;
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentContentQuestionOptionsInput
  >;
  ccQAXId?: Maybe<Scalars['String']>;
  ccQXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  score?: Maybe<Scalars['Float']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionOptionUpdateWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput = {
  data: AssessmentContentQuestionOptionUpdateWithoutAssessmentContentQuestionAnswerDataInput;
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type AssessmentContentQuestionOptionUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  data: AssessmentContentQuestionOptionUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type AssessmentContentQuestionOptionUpsertWithoutAssessmentTakingResponsesInput = {
  create: AssessmentContentQuestionOptionCreateWithoutAssessmentTakingResponsesInput;
  update: AssessmentContentQuestionOptionUpdateWithoutAssessmentTakingResponsesDataInput;
};

export type AssessmentContentQuestionOptionUpsertWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput = {
  create: AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionAnswerInput;
  update: AssessmentContentQuestionOptionUpdateWithoutAssessmentContentQuestionAnswerDataInput;
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type AssessmentContentQuestionOptionUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  create: AssessmentContentQuestionOptionCreateWithoutAssessmentContentQuestionInput;
  update: AssessmentContentQuestionOptionUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type AssessmentContentQuestionOptionWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionOptionWhereInput>>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionWhereInput>;
  assessmentContentQuestionAnswer?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
  assessmentContentQuestionAnswerId?: Maybe<NullableIntFilter>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseFilter>;
  ccQAXId?: Maybe<NullableStringFilter>;
  ccQXId?: Maybe<NullableStringFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isInactive?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionOptionWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionOptionWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  score?: Maybe<NullableFloatFilter>;
  text?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionOptionWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssessmentContentQuestionOrderByInput = {
  assessmentContentQuestionType?: Maybe<OrderByArg>;
  assessmentContentQuestionTypeId?: Maybe<OrderByArg>;
  assignmentContent?: Maybe<OrderByArg>;
  assignmentContentId?: Maybe<OrderByArg>;
  ccAQTXId?: Maybe<OrderByArg>;
  ccAXId?: Maybe<OrderByArg>;
  ccXId?: Maybe<OrderByArg>;
  courseCodeXId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  feedback?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isAllOrNothing?: Maybe<OrderByArg>;
  isInactive?: Maybe<OrderByArg>;
  isOrLogic?: Maybe<OrderByArg>;
  maxScore?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  text?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssessmentContentQuestionScalarWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionScalarWhereInput>>;
  assessmentContentQuestionAnswers?: Maybe<AssessmentContentQuestionAnswerFilter>;
  assessmentContentQuestionOptions?: Maybe<AssessmentContentQuestionOptionFilter>;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolFilter>;
  assessmentContentQuestionTypeId?: Maybe<NullableIntFilter>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionFilter>;
  assignmentContentId?: Maybe<NullableIntFilter>;
  ccAQTXId?: Maybe<NullableStringFilter>;
  ccAXId?: Maybe<NullableStringFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  feedback?: Maybe<NullableStringFilter>;
  id?: Maybe<IntFilter>;
  isAllOrNothing?: Maybe<BooleanFilter>;
  isInactive?: Maybe<BooleanFilter>;
  isOrLogic?: Maybe<BooleanFilter>;
  maxScore?: Maybe<FloatFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionScalarWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionScalarWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  text?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionTool = {
  __typename?: 'AssessmentContentQuestionTool';
  assessmentContentQuestion?: Maybe<AssessmentContentQuestion>;
  assessmentContentQuestionId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  order: Scalars['Int'];
  textDisplay?: Maybe<Scalars['String']>;
  textValue: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type AssessmentContentQuestionToolCreateInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentContentQuestionToolsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  order?: Maybe<Scalars['Int']>;
  textDisplay?: Maybe<Scalars['String']>;
  textValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionToolCreateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentContentQuestionToolWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionToolCreateWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentContentQuestionToolCreateWithoutAssessmentContentQuestionInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  order?: Maybe<Scalars['Int']>;
  textDisplay?: Maybe<Scalars['String']>;
  textValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionToolFilter = {
  every?: Maybe<AssessmentContentQuestionToolWhereInput>;
  none?: Maybe<AssessmentContentQuestionToolWhereInput>;
  some?: Maybe<AssessmentContentQuestionToolWhereInput>;
};

export type AssessmentContentQuestionToolOrderByInput = {
  assessmentContentQuestion?: Maybe<OrderByArg>;
  assessmentContentQuestionId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  textDisplay?: Maybe<OrderByArg>;
  textValue?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssessmentContentQuestionToolScalarWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionToolScalarWhereInput>>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionToolScalarWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionToolScalarWhereInput>>;
  order?: Maybe<IntFilter>;
  textDisplay?: Maybe<NullableStringFilter>;
  textValue?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionToolUpdateInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionToolsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  textDisplay?: Maybe<Scalars['String']>;
  textValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionToolUpdateManyDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  textDisplay?: Maybe<Scalars['String']>;
  textValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionToolUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  textDisplay?: Maybe<Scalars['String']>;
  textValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionToolUpdateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentContentQuestionToolWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionToolCreateWithoutAssessmentContentQuestionInput>>;
  delete?: Maybe<Array<AssessmentContentQuestionToolWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentContentQuestionToolScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentContentQuestionToolWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentContentQuestionToolWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentContentQuestionToolUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
  updateMany?: Maybe<Array<AssessmentContentQuestionToolUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentContentQuestionToolUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentContentQuestionToolUpdateManyWithWhereNestedInput = {
  data: AssessmentContentQuestionToolUpdateManyDataInput;
  where: AssessmentContentQuestionToolScalarWhereInput;
};

export type AssessmentContentQuestionToolUpdateWithoutAssessmentContentQuestionDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  textDisplay?: Maybe<Scalars['String']>;
  textValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionToolUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  data: AssessmentContentQuestionToolUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentContentQuestionToolWhereUniqueInput;
};

export type AssessmentContentQuestionToolUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  create: AssessmentContentQuestionToolCreateWithoutAssessmentContentQuestionInput;
  update: AssessmentContentQuestionToolUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentContentQuestionToolWhereUniqueInput;
};

export type AssessmentContentQuestionToolWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionToolWhereInput>>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionWhereInput>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionToolWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionToolWhereInput>>;
  order?: Maybe<IntFilter>;
  textDisplay?: Maybe<NullableStringFilter>;
  textValue?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionToolWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssessmentContentQuestionType = {
  __typename?: 'AssessmentContentQuestionType';
  assessmentContentQuestions: Array<AssessmentContentQuestion>;
  code: AssessmentContentQuestionTypeEnum;
  createdAt: Scalars['DateTime'];
  description: Scalars['String'];
  id: Scalars['Int'];
  manualGrade: Scalars['Boolean'];
  updatedAt: Scalars['DateTime'];
};

export type AssessmentContentQuestionTypeAssessmentContentQuestionsArgs = {
  after?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type AssessmentContentQuestionTypeCreateInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionCreateManyWithoutAssessmentContentQuestionTypeInput>;
  code: AssessmentContentQuestionTypeEnum;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  manualGrade?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionTypeCreateOneWithoutAssessmentContentQuestionsInput = {
  connect?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionTypeCreateWithoutAssessmentContentQuestionsInput>;
};

export type AssessmentContentQuestionTypeCreateWithoutAssessmentContentQuestionsInput = {
  code: AssessmentContentQuestionTypeEnum;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  manualGrade?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export enum AssessmentContentQuestionTypeEnum {
  Ct = 'CT',
  Es = 'ES',
  Fb = 'FB',
  Ma = 'MA',
  Mc = 'MC',
  Or = 'OR',
  Tf = 'TF',
}

export type AssessmentContentQuestionTypeEnumFilter = {
  equals?: Maybe<AssessmentContentQuestionTypeEnum>;
  in?: Maybe<Array<AssessmentContentQuestionTypeEnum>>;
  not?: Maybe<AssessmentContentQuestionTypeEnum>;
  notIn?: Maybe<Array<AssessmentContentQuestionTypeEnum>>;
};

export type AssessmentContentQuestionTypeOrderByInput = {
  code?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  description?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  manualGrade?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssessmentContentQuestionTypeUpdateInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionUpdateManyWithoutAssessmentContentQuestionTypeInput>;
  code?: Maybe<AssessmentContentQuestionTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  manualGrade?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionTypeUpdateManyMutationInput = {
  code?: Maybe<AssessmentContentQuestionTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  manualGrade?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionTypeUpdateOneWithoutAssessmentContentQuestionsInput = {
  connect?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionTypeCreateWithoutAssessmentContentQuestionsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionTypeUpdateWithoutAssessmentContentQuestionsDataInput>;
  upsert?: Maybe<AssessmentContentQuestionTypeUpsertWithoutAssessmentContentQuestionsInput>;
};

export type AssessmentContentQuestionTypeUpdateWithoutAssessmentContentQuestionsDataInput = {
  code?: Maybe<AssessmentContentQuestionTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  manualGrade?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionTypeUpsertWithoutAssessmentContentQuestionsInput = {
  create: AssessmentContentQuestionTypeCreateWithoutAssessmentContentQuestionsInput;
  update: AssessmentContentQuestionTypeUpdateWithoutAssessmentContentQuestionsDataInput;
};

export type AssessmentContentQuestionTypeWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionTypeWhereInput>>;
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionFilter>;
  code?: Maybe<AssessmentContentQuestionTypeEnumFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  description?: Maybe<StringFilter>;
  id?: Maybe<IntFilter>;
  manualGrade?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionTypeWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionTypeWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionTypeWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssessmentContentQuestionUpdateInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolUpdateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeUpdateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateManyDataInput = {
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateManyMutationInput = {
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateManyWithoutAssessmentContentQuestionTypeInput = {
  connect?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionTypeInput>>;
  delete?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentContentQuestionScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentContentQuestionUpdateWithWhereUniqueWithoutAssessmentContentQuestionTypeInput>>;
  updateMany?: Maybe<Array<AssessmentContentQuestionUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentContentQuestionUpsertWithWhereUniqueWithoutAssessmentContentQuestionTypeInput>>;
};

export type AssessmentContentQuestionUpdateManyWithoutAssignmentContentInput = {
  connect?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentContentQuestionCreateWithoutAssignmentContentInput>>;
  delete?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentContentQuestionScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentContentQuestionWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentContentQuestionUpdateWithWhereUniqueWithoutAssignmentContentInput>>;
  updateMany?: Maybe<Array<AssessmentContentQuestionUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentContentQuestionUpsertWithWhereUniqueWithoutAssignmentContentInput>>;
};

export type AssessmentContentQuestionUpdateManyWithWhereNestedInput = {
  data: AssessmentContentQuestionUpdateManyDataInput;
  where: AssessmentContentQuestionScalarWhereInput;
};

export type AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionAnswersInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionAnswersInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionAnswersDataInput>;
  upsert?: Maybe<AssessmentContentQuestionUpsertWithoutAssessmentContentQuestionAnswersInput>;
};

export type AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionOptionsInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionOptionsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionOptionsDataInput>;
  upsert?: Maybe<AssessmentContentQuestionUpsertWithoutAssessmentContentQuestionOptionsInput>;
};

export type AssessmentContentQuestionUpdateOneWithoutAssessmentContentQuestionToolsInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentContentQuestionToolsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionToolsDataInput>;
  upsert?: Maybe<AssessmentContentQuestionUpsertWithoutAssessmentContentQuestionToolsInput>;
};

export type AssessmentContentQuestionUpdateOneWithoutAssessmentTakingQuestionsInput = {
  connect?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentContentQuestionCreateWithoutAssessmentTakingQuestionsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentContentQuestionUpdateWithoutAssessmentTakingQuestionsDataInput>;
  upsert?: Maybe<AssessmentContentQuestionUpsertWithoutAssessmentTakingQuestionsInput>;
};

export type AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionAnswersDataInput = {
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolUpdateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeUpdateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionOptionsDataInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolUpdateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeUpdateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionToolsDataInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeUpdateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionTypeDataInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolUpdateManyWithoutAssessmentContentQuestionInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssessmentContentQuestionInput>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateWithoutAssessmentTakingQuestionsDataInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolUpdateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeUpdateOneWithoutAssessmentContentQuestionsInput>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssessmentContentQuestionsInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateWithoutAssignmentContentDataInput = {
  assessmentContentQuestionAnswers?: Maybe<
    AssessmentContentQuestionAnswerUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionOptions?: Maybe<
    AssessmentContentQuestionOptionUpdateManyWithoutAssessmentContentQuestionInput
  >;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolUpdateManyWithoutAssessmentContentQuestionInput>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeUpdateOneWithoutAssessmentContentQuestionsInput>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssessmentContentQuestionInput>;
  ccAQTXId?: Maybe<Scalars['String']>;
  ccAXId?: Maybe<Scalars['String']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isAllOrNothing?: Maybe<Scalars['Boolean']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  isOrLogic?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentContentQuestionUpdateWithWhereUniqueWithoutAssessmentContentQuestionTypeInput = {
  data: AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionTypeDataInput;
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type AssessmentContentQuestionUpdateWithWhereUniqueWithoutAssignmentContentInput = {
  data: AssessmentContentQuestionUpdateWithoutAssignmentContentDataInput;
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type AssessmentContentQuestionUpsertWithoutAssessmentContentQuestionAnswersInput = {
  create: AssessmentContentQuestionCreateWithoutAssessmentContentQuestionAnswersInput;
  update: AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionAnswersDataInput;
};

export type AssessmentContentQuestionUpsertWithoutAssessmentContentQuestionOptionsInput = {
  create: AssessmentContentQuestionCreateWithoutAssessmentContentQuestionOptionsInput;
  update: AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionOptionsDataInput;
};

export type AssessmentContentQuestionUpsertWithoutAssessmentContentQuestionToolsInput = {
  create: AssessmentContentQuestionCreateWithoutAssessmentContentQuestionToolsInput;
  update: AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionToolsDataInput;
};

export type AssessmentContentQuestionUpsertWithoutAssessmentTakingQuestionsInput = {
  create: AssessmentContentQuestionCreateWithoutAssessmentTakingQuestionsInput;
  update: AssessmentContentQuestionUpdateWithoutAssessmentTakingQuestionsDataInput;
};

export type AssessmentContentQuestionUpsertWithWhereUniqueWithoutAssessmentContentQuestionTypeInput = {
  create: AssessmentContentQuestionCreateWithoutAssessmentContentQuestionTypeInput;
  update: AssessmentContentQuestionUpdateWithoutAssessmentContentQuestionTypeDataInput;
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type AssessmentContentQuestionUpsertWithWhereUniqueWithoutAssignmentContentInput = {
  create: AssessmentContentQuestionCreateWithoutAssignmentContentInput;
  update: AssessmentContentQuestionUpdateWithoutAssignmentContentDataInput;
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type AssessmentContentQuestionWhereInput = {
  AND?: Maybe<Array<AssessmentContentQuestionWhereInput>>;
  assessmentContentQuestionAnswers?: Maybe<AssessmentContentQuestionAnswerFilter>;
  assessmentContentQuestionOptions?: Maybe<AssessmentContentQuestionOptionFilter>;
  assessmentContentQuestionTools?: Maybe<AssessmentContentQuestionToolFilter>;
  assessmentContentQuestionType?: Maybe<AssessmentContentQuestionTypeWhereInput>;
  assessmentContentQuestionTypeId?: Maybe<NullableIntFilter>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionFilter>;
  assignmentContent?: Maybe<AssignmentContentWhereInput>;
  assignmentContentId?: Maybe<NullableIntFilter>;
  ccAQTXId?: Maybe<NullableStringFilter>;
  ccAXId?: Maybe<NullableStringFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  feedback?: Maybe<NullableStringFilter>;
  id?: Maybe<IntFilter>;
  isAllOrNothing?: Maybe<BooleanFilter>;
  isInactive?: Maybe<BooleanFilter>;
  isOrLogic?: Maybe<BooleanFilter>;
  maxScore?: Maybe<FloatFilter>;
  NOT?: Maybe<Array<AssessmentContentQuestionWhereInput>>;
  OR?: Maybe<Array<AssessmentContentQuestionWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  text?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentContentQuestionWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssessmentResponse = {
  assessmentContentQuestionAnswerId?: Maybe<Scalars['Int']>;
  assessmentContentQuestionOptionId?: Maybe<Scalars['Int']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  questionContentOptionId: Scalars['Int'];
  textAnswer?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

export type AssessmentSubmitInput = {
  answers?: Maybe<Array<Maybe<MultipleAnswerPartialInput>>>;
  optionId?: Maybe<Scalars['Int']>;
  parentComment?: Maybe<Scalars['String']>;
  questionId: Scalars['Int'];
  questionType?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Int']>;
  textAnswer?: Maybe<Scalars['String']>;
};

export type AssessmentTakingQuestion = {
  __typename?: 'AssessmentTakingQuestion';
  assessmentContentQuestion?: Maybe<AssessmentContentQuestion>;
  assessmentContentQuestionId?: Maybe<Scalars['Int']>;
  assessmentTakingResponses: Array<AssessmentTakingResponse>;
  assignmentTaking?: Maybe<AssignmentTaking>;
  assignmentTakingId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  isCorrectOverride: Scalars['Boolean'];
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['DateTime'];
};

export type AssessmentTakingQuestionAssessmentTakingResponsesArgs = {
  after?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  before?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingResponseOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type AssessmentTakingQuestionCreateInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentTakingQuestionsInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentTakingQuestionInput>;
  assignmentTaking?: Maybe<AssignmentTakingCreateOneWithoutAssessmentTakingQuestionsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionCreateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingQuestionCreateWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentTakingQuestionCreateManyWithoutAssignmentTakingInput = {
  connect?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingQuestionCreateWithoutAssignmentTakingInput>>;
};

export type AssessmentTakingQuestionCreateOneWithoutAssessmentTakingResponsesInput = {
  connect?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentTakingQuestionCreateWithoutAssessmentTakingResponsesInput>;
};

export type AssessmentTakingQuestionCreateWithoutAssessmentContentQuestionInput = {
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentTakingQuestionInput>;
  assignmentTaking?: Maybe<AssignmentTakingCreateOneWithoutAssessmentTakingQuestionsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionCreateWithoutAssessmentTakingResponsesInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentTakingQuestionsInput>;
  assignmentTaking?: Maybe<AssignmentTakingCreateOneWithoutAssessmentTakingQuestionsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionCreateWithoutAssignmentTakingInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionCreateOneWithoutAssessmentTakingQuestionsInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseCreateManyWithoutAssessmentTakingQuestionInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionFilter = {
  every?: Maybe<AssessmentTakingQuestionWhereInput>;
  none?: Maybe<AssessmentTakingQuestionWhereInput>;
  some?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type AssessmentTakingQuestionOrderByInput = {
  assessmentContentQuestion?: Maybe<OrderByArg>;
  assessmentContentQuestionId?: Maybe<OrderByArg>;
  assignmentTaking?: Maybe<OrderByArg>;
  assignmentTakingId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isCorrectOverride?: Maybe<OrderByArg>;
  parentComment?: Maybe<OrderByArg>;
  scoreOverride?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssessmentTakingQuestions = {
  assessmentContentOptions: Array<Maybe<AssessmentResponse>>;
  assessmentContentQuestionId: Scalars['Int'];
  ccAQTXId: Scalars['String'];
  gradeWeight?: Maybe<Scalars['Int']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  isOverride?: Maybe<Scalars['Boolean']>;
  maxScore?: Maybe<Scalars['Int']>;
  questionId?: Maybe<Scalars['Int']>;
  questionTakingId?: Maybe<Scalars['Int']>;
  questionType?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Int']>;
};

export type AssessmentTakingQuestionScalarWhereInput = {
  AND?: Maybe<Array<AssessmentTakingQuestionScalarWhereInput>>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseFilter>;
  assignmentTakingId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isCorrectOverride?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentTakingQuestionScalarWhereInput>>;
  OR?: Maybe<Array<AssessmentTakingQuestionScalarWhereInput>>;
  parentComment?: Maybe<NullableStringFilter>;
  scoreOverride?: Maybe<NullableFloatFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentTakingQuestionUpdateInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentTakingQuestionsInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentTakingQuestionInput>;
  assignmentTaking?: Maybe<AssignmentTakingUpdateOneWithoutAssessmentTakingQuestionsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionUpdateManyDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionUpdateManyWithoutAssessmentContentQuestionInput = {
  connect?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingQuestionCreateWithoutAssessmentContentQuestionInput>>;
  delete?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentTakingQuestionScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentTakingQuestionUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
  updateMany?: Maybe<Array<AssessmentTakingQuestionUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentTakingQuestionUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput>>;
};

export type AssessmentTakingQuestionUpdateManyWithoutAssignmentTakingInput = {
  connect?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingQuestionCreateWithoutAssignmentTakingInput>>;
  delete?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentTakingQuestionScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentTakingQuestionWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentTakingQuestionUpdateWithWhereUniqueWithoutAssignmentTakingInput>>;
  updateMany?: Maybe<Array<AssessmentTakingQuestionUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentTakingQuestionUpsertWithWhereUniqueWithoutAssignmentTakingInput>>;
};

export type AssessmentTakingQuestionUpdateManyWithWhereNestedInput = {
  data: AssessmentTakingQuestionUpdateManyDataInput;
  where: AssessmentTakingQuestionScalarWhereInput;
};

export type AssessmentTakingQuestionUpdateOneWithoutAssessmentTakingResponsesInput = {
  connect?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  create?: Maybe<AssessmentTakingQuestionCreateWithoutAssessmentTakingResponsesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssessmentTakingQuestionUpdateWithoutAssessmentTakingResponsesDataInput>;
  upsert?: Maybe<AssessmentTakingQuestionUpsertWithoutAssessmentTakingResponsesInput>;
};

export type AssessmentTakingQuestionUpdateWithoutAssessmentContentQuestionDataInput = {
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentTakingQuestionInput>;
  assignmentTaking?: Maybe<AssignmentTakingUpdateOneWithoutAssessmentTakingQuestionsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionUpdateWithoutAssessmentTakingResponsesDataInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentTakingQuestionsInput>;
  assignmentTaking?: Maybe<AssignmentTakingUpdateOneWithoutAssessmentTakingQuestionsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionUpdateWithoutAssignmentTakingDataInput = {
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionUpdateOneWithoutAssessmentTakingQuestionsInput>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseUpdateManyWithoutAssessmentTakingQuestionInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrectOverride?: Maybe<Scalars['Boolean']>;
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingQuestionUpdateWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  data: AssessmentTakingQuestionUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type AssessmentTakingQuestionUpdateWithWhereUniqueWithoutAssignmentTakingInput = {
  data: AssessmentTakingQuestionUpdateWithoutAssignmentTakingDataInput;
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type AssessmentTakingQuestionUpsertWithoutAssessmentTakingResponsesInput = {
  create: AssessmentTakingQuestionCreateWithoutAssessmentTakingResponsesInput;
  update: AssessmentTakingQuestionUpdateWithoutAssessmentTakingResponsesDataInput;
};

export type AssessmentTakingQuestionUpsertWithWhereUniqueWithoutAssessmentContentQuestionInput = {
  create: AssessmentTakingQuestionCreateWithoutAssessmentContentQuestionInput;
  update: AssessmentTakingQuestionUpdateWithoutAssessmentContentQuestionDataInput;
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type AssessmentTakingQuestionUpsertWithWhereUniqueWithoutAssignmentTakingInput = {
  create: AssessmentTakingQuestionCreateWithoutAssignmentTakingInput;
  update: AssessmentTakingQuestionUpdateWithoutAssignmentTakingDataInput;
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type AssessmentTakingQuestionWhereInput = {
  AND?: Maybe<Array<AssessmentTakingQuestionWhereInput>>;
  assessmentContentQuestion?: Maybe<AssessmentContentQuestionWhereInput>;
  assessmentContentQuestionId?: Maybe<NullableIntFilter>;
  assessmentTakingResponses?: Maybe<AssessmentTakingResponseFilter>;
  assignmentTaking?: Maybe<AssignmentTakingWhereInput>;
  assignmentTakingId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isCorrectOverride?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentTakingQuestionWhereInput>>;
  OR?: Maybe<Array<AssessmentTakingQuestionWhereInput>>;
  parentComment?: Maybe<NullableStringFilter>;
  scoreOverride?: Maybe<NullableFloatFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentTakingQuestionWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssessmentTakingResponse = {
  __typename?: 'AssessmentTakingResponse';
  assessmentContentQuestionAnswer?: Maybe<AssessmentContentQuestionAnswer>;
  assessmentContentQuestionAnswerId?: Maybe<Scalars['Int']>;
  assessmentContentQuestionOption?: Maybe<AssessmentContentQuestionOption>;
  assessmentContentQuestionOptionId?: Maybe<Scalars['Int']>;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestion>;
  assessmentTakingQuestionId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  isCorrect: Scalars['Boolean'];
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type AssessmentTakingResponseCreateInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerCreateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentContentQuestionOption?: Maybe<
    AssessmentContentQuestionOptionCreateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestionCreateOneWithoutAssessmentTakingResponsesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionAnswerInput = {
  connect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingResponseCreateWithoutAssessmentContentQuestionAnswerInput>>;
};

export type AssessmentTakingResponseCreateManyWithoutAssessmentContentQuestionOptionInput = {
  connect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingResponseCreateWithoutAssessmentContentQuestionOptionInput>>;
};

export type AssessmentTakingResponseCreateManyWithoutAssessmentTakingQuestionInput = {
  connect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingResponseCreateWithoutAssessmentTakingQuestionInput>>;
};

export type AssessmentTakingResponseCreateWithoutAssessmentContentQuestionAnswerInput = {
  assessmentContentQuestionOption?: Maybe<
    AssessmentContentQuestionOptionCreateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestionCreateOneWithoutAssessmentTakingResponsesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseCreateWithoutAssessmentContentQuestionOptionInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerCreateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestionCreateOneWithoutAssessmentTakingResponsesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseCreateWithoutAssessmentTakingQuestionInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerCreateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentContentQuestionOption?: Maybe<
    AssessmentContentQuestionOptionCreateOneWithoutAssessmentTakingResponsesInput
  >;
  createdAt?: Maybe<Scalars['DateTime']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseFilter = {
  every?: Maybe<AssessmentTakingResponseWhereInput>;
  none?: Maybe<AssessmentTakingResponseWhereInput>;
  some?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type AssessmentTakingResponseOrderByInput = {
  assessmentContentQuestionAnswer?: Maybe<OrderByArg>;
  assessmentContentQuestionAnswerId?: Maybe<OrderByArg>;
  assessmentContentQuestionOption?: Maybe<OrderByArg>;
  assessmentContentQuestionOptionId?: Maybe<OrderByArg>;
  assessmentTakingQuestion?: Maybe<OrderByArg>;
  assessmentTakingQuestionId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isCorrect?: Maybe<OrderByArg>;
  textAnswer?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssessmentTakingResponseScalarWhereInput = {
  AND?: Maybe<Array<AssessmentTakingResponseScalarWhereInput>>;
  assessmentContentQuestionAnswerId?: Maybe<NullableIntFilter>;
  assessmentContentQuestionOptionId?: Maybe<NullableIntFilter>;
  assessmentTakingQuestionId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isCorrect?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentTakingResponseScalarWhereInput>>;
  OR?: Maybe<Array<AssessmentTakingResponseScalarWhereInput>>;
  textAnswer?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentTakingResponseUpdateInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentContentQuestionOption?: Maybe<
    AssessmentContentQuestionOptionUpdateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestionUpdateOneWithoutAssessmentTakingResponsesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseUpdateManyDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionAnswerInput = {
  connect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingResponseCreateWithoutAssessmentContentQuestionAnswerInput>>;
  delete?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentTakingResponseScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentTakingResponseUpdateWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput>>;
  updateMany?: Maybe<Array<AssessmentTakingResponseUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentTakingResponseUpsertWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput>>;
};

export type AssessmentTakingResponseUpdateManyWithoutAssessmentContentQuestionOptionInput = {
  connect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingResponseCreateWithoutAssessmentContentQuestionOptionInput>>;
  delete?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentTakingResponseScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentTakingResponseUpdateWithWhereUniqueWithoutAssessmentContentQuestionOptionInput>>;
  updateMany?: Maybe<Array<AssessmentTakingResponseUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentTakingResponseUpsertWithWhereUniqueWithoutAssessmentContentQuestionOptionInput>>;
};

export type AssessmentTakingResponseUpdateManyWithoutAssessmentTakingQuestionInput = {
  connect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  create?: Maybe<Array<AssessmentTakingResponseCreateWithoutAssessmentTakingQuestionInput>>;
  delete?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssessmentTakingResponseScalarWhereInput>>;
  disconnect?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  set?: Maybe<Array<AssessmentTakingResponseWhereUniqueInput>>;
  update?: Maybe<Array<AssessmentTakingResponseUpdateWithWhereUniqueWithoutAssessmentTakingQuestionInput>>;
  updateMany?: Maybe<Array<AssessmentTakingResponseUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssessmentTakingResponseUpsertWithWhereUniqueWithoutAssessmentTakingQuestionInput>>;
};

export type AssessmentTakingResponseUpdateManyWithWhereNestedInput = {
  data: AssessmentTakingResponseUpdateManyDataInput;
  where: AssessmentTakingResponseScalarWhereInput;
};

export type AssessmentTakingResponseUpdateWithoutAssessmentContentQuestionAnswerDataInput = {
  assessmentContentQuestionOption?: Maybe<
    AssessmentContentQuestionOptionUpdateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestionUpdateOneWithoutAssessmentTakingResponsesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseUpdateWithoutAssessmentContentQuestionOptionDataInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestionUpdateOneWithoutAssessmentTakingResponsesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseUpdateWithoutAssessmentTakingQuestionDataInput = {
  assessmentContentQuestionAnswer?: Maybe<
    AssessmentContentQuestionAnswerUpdateOneWithoutAssessmentTakingResponsesInput
  >;
  assessmentContentQuestionOption?: Maybe<
    AssessmentContentQuestionOptionUpdateOneWithoutAssessmentTakingResponsesInput
  >;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isCorrect?: Maybe<Scalars['Boolean']>;
  textAnswer?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssessmentTakingResponseUpdateWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput = {
  data: AssessmentTakingResponseUpdateWithoutAssessmentContentQuestionAnswerDataInput;
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type AssessmentTakingResponseUpdateWithWhereUniqueWithoutAssessmentContentQuestionOptionInput = {
  data: AssessmentTakingResponseUpdateWithoutAssessmentContentQuestionOptionDataInput;
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type AssessmentTakingResponseUpdateWithWhereUniqueWithoutAssessmentTakingQuestionInput = {
  data: AssessmentTakingResponseUpdateWithoutAssessmentTakingQuestionDataInput;
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type AssessmentTakingResponseUpsertWithWhereUniqueWithoutAssessmentContentQuestionAnswerInput = {
  create: AssessmentTakingResponseCreateWithoutAssessmentContentQuestionAnswerInput;
  update: AssessmentTakingResponseUpdateWithoutAssessmentContentQuestionAnswerDataInput;
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type AssessmentTakingResponseUpsertWithWhereUniqueWithoutAssessmentContentQuestionOptionInput = {
  create: AssessmentTakingResponseCreateWithoutAssessmentContentQuestionOptionInput;
  update: AssessmentTakingResponseUpdateWithoutAssessmentContentQuestionOptionDataInput;
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type AssessmentTakingResponseUpsertWithWhereUniqueWithoutAssessmentTakingQuestionInput = {
  create: AssessmentTakingResponseCreateWithoutAssessmentTakingQuestionInput;
  update: AssessmentTakingResponseUpdateWithoutAssessmentTakingQuestionDataInput;
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type AssessmentTakingResponseWhereInput = {
  AND?: Maybe<Array<AssessmentTakingResponseWhereInput>>;
  assessmentContentQuestionAnswer?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
  assessmentContentQuestionAnswerId?: Maybe<NullableIntFilter>;
  assessmentContentQuestionOption?: Maybe<AssessmentContentQuestionOptionWhereInput>;
  assessmentContentQuestionOptionId?: Maybe<NullableIntFilter>;
  assessmentTakingQuestion?: Maybe<AssessmentTakingQuestionWhereInput>;
  assessmentTakingQuestionId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isCorrect?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<AssessmentTakingResponseWhereInput>>;
  OR?: Maybe<Array<AssessmentTakingResponseWhereInput>>;
  textAnswer?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssessmentTakingResponseWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssignmentContent = {
  __typename?: 'AssignmentContent';
  assessmentContentQuestions: Array<AssessmentContentQuestion>;
  assignmentTakings: Array<AssignmentTaking>;
  canBeRetaken: Scalars['Boolean'];
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContent>;
  courseContentId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource: Scalars['Boolean'];
  hasStudentResource: Scalars['Boolean'];
  id: Scalars['Int'];
  isAssessment: Scalars['Boolean'];
  isCounted: Scalars['Boolean'];
  isGradeable: Scalars['Boolean'];
  isOptional: Scalars['Boolean'];
  isVideo: Scalars['Boolean'];
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContent>;
  lessonContentId?: Maybe<Scalars['Int']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type AssignmentContentAssessmentContentQuestionsArgs = {
  after?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type AssignmentContentAssignmentTakingsArgs = {
  after?: Maybe<AssignmentTakingWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type AssignmentContentCreateInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionCreateManyWithoutAssignmentContentInput>;
  assignmentTakings?: Maybe<AssignmentTakingCreateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentCreateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentCreateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentContentCreateWithoutCourseContentInput>>;
};

export type AssignmentContentCreateManyWithoutLessonContentInput = {
  connect?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentContentCreateWithoutLessonContentInput>>;
};

export type AssignmentContentCreateOneWithoutAssessmentContentQuestionsInput = {
  connect?: Maybe<AssignmentContentWhereUniqueInput>;
  create?: Maybe<AssignmentContentCreateWithoutAssessmentContentQuestionsInput>;
};

export type AssignmentContentCreateOneWithoutAssignmentTakingsInput = {
  connect?: Maybe<AssignmentContentWhereUniqueInput>;
  create?: Maybe<AssignmentContentCreateWithoutAssignmentTakingsInput>;
};

export type AssignmentContentCreateWithoutAssessmentContentQuestionsInput = {
  assignmentTakings?: Maybe<AssignmentTakingCreateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentCreateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentCreateWithoutAssignmentTakingsInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionCreateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentCreateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentCreateWithoutCourseContentInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionCreateManyWithoutAssignmentContentInput>;
  assignmentTakings?: Maybe<AssignmentTakingCreateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentCreateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentCreateWithoutLessonContentInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionCreateManyWithoutAssignmentContentInput>;
  assignmentTakings?: Maybe<AssignmentTakingCreateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentFilter = {
  every?: Maybe<AssignmentContentWhereInput>;
  none?: Maybe<AssignmentContentWhereInput>;
  some?: Maybe<AssignmentContentWhereInput>;
};

export type AssignmentContentOrderByInput = {
  canBeRetaken?: Maybe<OrderByArg>;
  ccXId?: Maybe<OrderByArg>;
  courseCodeXId?: Maybe<OrderByArg>;
  courseContent?: Maybe<OrderByArg>;
  courseContentId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  feedbackType?: Maybe<OrderByArg>;
  hasParentResource?: Maybe<OrderByArg>;
  hasStudentResource?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isAssessment?: Maybe<OrderByArg>;
  isCounted?: Maybe<OrderByArg>;
  isGradeable?: Maybe<OrderByArg>;
  isOptional?: Maybe<OrderByArg>;
  isVideo?: Maybe<OrderByArg>;
  label?: Maybe<OrderByArg>;
  lessonContent?: Maybe<OrderByArg>;
  lessonContentId?: Maybe<OrderByArg>;
  lessonDayXId?: Maybe<OrderByArg>;
  link?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  parentInstructions?: Maybe<OrderByArg>;
  parentLink?: Maybe<OrderByArg>;
  parentLinkLabel?: Maybe<OrderByArg>;
  studentLink?: Maybe<OrderByArg>;
  studentLinkLabel?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  totalPoints?: Maybe<OrderByArg>;
  type?: Maybe<OrderByArg>;
  typeLabel?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssignmentContentScalarWhereInput = {
  AND?: Maybe<Array<AssignmentContentScalarWhereInput>>;
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionFilter>;
  assignmentTakings?: Maybe<AssignmentTakingFilter>;
  canBeRetaken?: Maybe<BooleanFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  courseContentId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  feedbackType?: Maybe<NullableStringFilter>;
  hasParentResource?: Maybe<BooleanFilter>;
  hasStudentResource?: Maybe<BooleanFilter>;
  id?: Maybe<IntFilter>;
  isAssessment?: Maybe<BooleanFilter>;
  isCounted?: Maybe<BooleanFilter>;
  isGradeable?: Maybe<BooleanFilter>;
  isOptional?: Maybe<BooleanFilter>;
  isVideo?: Maybe<BooleanFilter>;
  label?: Maybe<NullableStringFilter>;
  lessonContentId?: Maybe<NullableIntFilter>;
  lessonDayXId?: Maybe<NullableIntFilter>;
  link?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<AssignmentContentScalarWhereInput>>;
  OR?: Maybe<Array<AssignmentContentScalarWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  parentInstructions?: Maybe<NullableStringFilter>;
  parentLink?: Maybe<NullableStringFilter>;
  parentLinkLabel?: Maybe<NullableStringFilter>;
  studentLink?: Maybe<NullableStringFilter>;
  studentLinkLabel?: Maybe<NullableStringFilter>;
  title?: Maybe<NullableStringFilter>;
  totalPoints?: Maybe<NullableIntFilter>;
  type?: Maybe<NullableAssignmentContentTypeEnumFilter>;
  typeLabel?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export enum AssignmentContentTypeEnum {
  Act = 'ACT',
  Ass = 'ASS',
  Axe = 'AXE',
  Crv = 'CRV',
  Evl = 'EVL',
  Frv = 'FRV',
  Hnd = 'HND',
  Ivs = 'IVS',
  Lab = 'LAB',
  Non = 'NON',
  Normal = 'Normal',
  Orl = 'ORL',
  Oth = 'OTH',
  Prj = 'PRJ',
  Prt = 'PRT',
  Qiz = 'QIZ',
  Random = 'Random',
  Red = 'RED',
  Rsc = 'RSC',
  Rvw = 'RVW',
  Sor = 'SOR',
  Srd = 'SRD',
  Stp = 'STP',
  Tes = 'TES',
  Til = 'TIL',
  Tsk = 'TSK',
  Vid = 'VID',
  Voq = 'VOQ',
  Vrs = 'VRS',
  Vsp = 'VSP',
  Was = 'WAS',
  Wbk = 'WBK',
  Wrp = 'WRP',
  Wrt = 'WRT',
  Wtc = 'WTC',
  Wtp = 'WTP',
}

export type AssignmentContentUpdateInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionUpdateManyWithoutAssignmentContentInput>;
  assignmentTakings?: Maybe<AssignmentTakingUpdateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentUpdateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentUpdateManyDataInput = {
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentUpdateManyMutationInput = {
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentUpdateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentContentCreateWithoutCourseContentInput>>;
  delete?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssignmentContentScalarWhereInput>>;
  disconnect?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  set?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  update?: Maybe<Array<AssignmentContentUpdateWithWhereUniqueWithoutCourseContentInput>>;
  updateMany?: Maybe<Array<AssignmentContentUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssignmentContentUpsertWithWhereUniqueWithoutCourseContentInput>>;
};

export type AssignmentContentUpdateManyWithoutLessonContentInput = {
  connect?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentContentCreateWithoutLessonContentInput>>;
  delete?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssignmentContentScalarWhereInput>>;
  disconnect?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  set?: Maybe<Array<AssignmentContentWhereUniqueInput>>;
  update?: Maybe<Array<AssignmentContentUpdateWithWhereUniqueWithoutLessonContentInput>>;
  updateMany?: Maybe<Array<AssignmentContentUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssignmentContentUpsertWithWhereUniqueWithoutLessonContentInput>>;
};

export type AssignmentContentUpdateManyWithWhereNestedInput = {
  data: AssignmentContentUpdateManyDataInput;
  where: AssignmentContentScalarWhereInput;
};

export type AssignmentContentUpdateOneWithoutAssessmentContentQuestionsInput = {
  connect?: Maybe<AssignmentContentWhereUniqueInput>;
  create?: Maybe<AssignmentContentCreateWithoutAssessmentContentQuestionsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssignmentContentUpdateWithoutAssessmentContentQuestionsDataInput>;
  upsert?: Maybe<AssignmentContentUpsertWithoutAssessmentContentQuestionsInput>;
};

export type AssignmentContentUpdateOneWithoutAssignmentTakingsInput = {
  connect?: Maybe<AssignmentContentWhereUniqueInput>;
  create?: Maybe<AssignmentContentCreateWithoutAssignmentTakingsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssignmentContentUpdateWithoutAssignmentTakingsDataInput>;
  upsert?: Maybe<AssignmentContentUpsertWithoutAssignmentTakingsInput>;
};

export type AssignmentContentUpdateWithoutAssessmentContentQuestionsDataInput = {
  assignmentTakings?: Maybe<AssignmentTakingUpdateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentUpdateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentUpdateWithoutAssignmentTakingsDataInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionUpdateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentUpdateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentUpdateWithoutCourseContentDataInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionUpdateManyWithoutAssignmentContentInput>;
  assignmentTakings?: Maybe<AssignmentTakingUpdateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContent?: Maybe<LessonContentUpdateOneWithoutAssignmentContentsInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentUpdateWithoutLessonContentDataInput = {
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionUpdateManyWithoutAssignmentContentInput>;
  assignmentTakings?: Maybe<AssignmentTakingUpdateManyWithoutAssignmentContentInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  ccXId?: Maybe<Scalars['String']>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutAssignmentContentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  feedbackType?: Maybe<Scalars['String']>;
  hasParentResource?: Maybe<Scalars['Boolean']>;
  hasStudentResource?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isAssessment?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isOptional?: Maybe<Scalars['Boolean']>;
  isVideo?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  parentLink?: Maybe<Scalars['String']>;
  parentLinkLabel?: Maybe<Scalars['String']>;
  studentLink?: Maybe<Scalars['String']>;
  studentLinkLabel?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Int']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  typeLabel?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentContentUpdateWithWhereUniqueWithoutCourseContentInput = {
  data: AssignmentContentUpdateWithoutCourseContentDataInput;
  where: AssignmentContentWhereUniqueInput;
};

export type AssignmentContentUpdateWithWhereUniqueWithoutLessonContentInput = {
  data: AssignmentContentUpdateWithoutLessonContentDataInput;
  where: AssignmentContentWhereUniqueInput;
};

export type AssignmentContentUpsertWithoutAssessmentContentQuestionsInput = {
  create: AssignmentContentCreateWithoutAssessmentContentQuestionsInput;
  update: AssignmentContentUpdateWithoutAssessmentContentQuestionsDataInput;
};

export type AssignmentContentUpsertWithoutAssignmentTakingsInput = {
  create: AssignmentContentCreateWithoutAssignmentTakingsInput;
  update: AssignmentContentUpdateWithoutAssignmentTakingsDataInput;
};

export type AssignmentContentUpsertWithWhereUniqueWithoutCourseContentInput = {
  create: AssignmentContentCreateWithoutCourseContentInput;
  update: AssignmentContentUpdateWithoutCourseContentDataInput;
  where: AssignmentContentWhereUniqueInput;
};

export type AssignmentContentUpsertWithWhereUniqueWithoutLessonContentInput = {
  create: AssignmentContentCreateWithoutLessonContentInput;
  update: AssignmentContentUpdateWithoutLessonContentDataInput;
  where: AssignmentContentWhereUniqueInput;
};

export type AssignmentContentWhereInput = {
  AND?: Maybe<Array<AssignmentContentWhereInput>>;
  assessmentContentQuestions?: Maybe<AssessmentContentQuestionFilter>;
  assignmentTakings?: Maybe<AssignmentTakingFilter>;
  canBeRetaken?: Maybe<BooleanFilter>;
  ccXId?: Maybe<NullableStringFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  courseContent?: Maybe<CourseContentWhereInput>;
  courseContentId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  feedbackType?: Maybe<NullableStringFilter>;
  hasParentResource?: Maybe<BooleanFilter>;
  hasStudentResource?: Maybe<BooleanFilter>;
  id?: Maybe<IntFilter>;
  isAssessment?: Maybe<BooleanFilter>;
  isCounted?: Maybe<BooleanFilter>;
  isGradeable?: Maybe<BooleanFilter>;
  isOptional?: Maybe<BooleanFilter>;
  isVideo?: Maybe<BooleanFilter>;
  label?: Maybe<NullableStringFilter>;
  lessonContent?: Maybe<LessonContentWhereInput>;
  lessonContentId?: Maybe<NullableIntFilter>;
  lessonDayXId?: Maybe<NullableIntFilter>;
  link?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<AssignmentContentWhereInput>>;
  OR?: Maybe<Array<AssignmentContentWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  parentInstructions?: Maybe<NullableStringFilter>;
  parentLink?: Maybe<NullableStringFilter>;
  parentLinkLabel?: Maybe<NullableStringFilter>;
  studentLink?: Maybe<NullableStringFilter>;
  studentLinkLabel?: Maybe<NullableStringFilter>;
  title?: Maybe<NullableStringFilter>;
  totalPoints?: Maybe<NullableIntFilter>;
  type?: Maybe<NullableAssignmentContentTypeEnumFilter>;
  typeLabel?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssignmentContentWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssignmentTaking = {
  __typename?: 'AssignmentTaking';
  assessmentTakingQuestions: Array<AssessmentTakingQuestion>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContent>;
  assignmentContentId?: Maybe<Scalars['Int']>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeight>;
  assignmentTakingWeightId?: Maybe<Scalars['Int']>;
  canBeRetaken: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded: Scalars['Boolean'];
  id: Scalars['Int'];
  isCounted: Scalars['Boolean'];
  isDone: Scalars['Boolean'];
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride: Scalars['Boolean'];
  isSkipped: Scalars['Boolean'];
  lessonTaking?: Maybe<LessonTaking>;
  lessonTakingId?: Maybe<Scalars['Int']>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview: Scalars['Boolean'];
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt: Scalars['DateTime'];
};

export type AssignmentTakingAssessmentTakingQuestionsArgs = {
  after?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type AssignmentTakingCreateInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssignmentTakingsInput>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightCreateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingCreateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingCreateManyWithoutAssignmentContentInput = {
  connect?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentTakingCreateWithoutAssignmentContentInput>>;
};

export type AssignmentTakingCreateManyWithoutLessonTakingInput = {
  connect?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentTakingCreateWithoutLessonTakingInput>>;
};

export type AssignmentTakingCreateOneWithoutAssessmentTakingQuestionsInput = {
  connect?: Maybe<AssignmentTakingWhereUniqueInput>;
  create?: Maybe<AssignmentTakingCreateWithoutAssessmentTakingQuestionsInput>;
};

export type AssignmentTakingCreateOneWithoutAssignmentTakingWeightInput = {
  connect?: Maybe<AssignmentTakingWhereUniqueInput>;
  create?: Maybe<AssignmentTakingCreateWithoutAssignmentTakingWeightInput>;
};

export type AssignmentTakingCreateWithoutAssessmentTakingQuestionsInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssignmentTakingsInput>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightCreateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingCreateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingCreateWithoutAssignmentContentInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightCreateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingCreateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingCreateWithoutAssignmentTakingWeightInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssignmentTakingsInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingCreateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingCreateWithoutLessonTakingInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionCreateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentCreateOneWithoutAssignmentTakingsInput>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightCreateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingFilter = {
  every?: Maybe<AssignmentTakingWhereInput>;
  none?: Maybe<AssignmentTakingWhereInput>;
  some?: Maybe<AssignmentTakingWhereInput>;
};

export type AssignmentTakingOrderByInput = {
  assignedAt?: Maybe<OrderByArg>;
  assignmentContent?: Maybe<OrderByArg>;
  assignmentContentId?: Maybe<OrderByArg>;
  assignmentTakingWeight?: Maybe<OrderByArg>;
  assignmentTakingWeightId?: Maybe<OrderByArg>;
  canBeRetaken?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  dueDateAt?: Maybe<OrderByArg>;
  hasBeenGraded?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isCounted?: Maybe<OrderByArg>;
  isDone?: Maybe<OrderByArg>;
  isGradeable?: Maybe<OrderByArg>;
  isGradeOverride?: Maybe<OrderByArg>;
  isSkipped?: Maybe<OrderByArg>;
  lessonTaking?: Maybe<OrderByArg>;
  lessonTakingId?: Maybe<OrderByArg>;
  maxPoints?: Maybe<OrderByArg>;
  maxSecondsAllowed?: Maybe<OrderByArg>;
  numericGrade?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  parentInstructions?: Maybe<OrderByArg>;
  requiresReview?: Maybe<OrderByArg>;
  startedAt?: Maybe<OrderByArg>;
  submittedAt?: Maybe<OrderByArg>;
  timeTaken?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  totalPoints?: Maybe<OrderByArg>;
  type?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type AssignmentTakingScalarWhereInput = {
  AND?: Maybe<Array<AssignmentTakingScalarWhereInput>>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionFilter>;
  assignedAt?: Maybe<NullableDateTimeFilter>;
  assignmentContentId?: Maybe<NullableIntFilter>;
  assignmentTakingWeightId?: Maybe<NullableIntFilter>;
  canBeRetaken?: Maybe<BooleanFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  dueDateAt?: Maybe<NullableDateTimeFilter>;
  hasBeenGraded?: Maybe<BooleanFilter>;
  id?: Maybe<IntFilter>;
  isCounted?: Maybe<BooleanFilter>;
  isDone?: Maybe<BooleanFilter>;
  isGradeable?: Maybe<NullableBooleanFilter>;
  isGradeOverride?: Maybe<BooleanFilter>;
  isSkipped?: Maybe<BooleanFilter>;
  lessonTakingId?: Maybe<NullableIntFilter>;
  maxPoints?: Maybe<NullableFloatFilter>;
  maxSecondsAllowed?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<AssignmentTakingScalarWhereInput>>;
  numericGrade?: Maybe<NullableFloatFilter>;
  OR?: Maybe<Array<AssignmentTakingScalarWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  parentInstructions?: Maybe<NullableStringFilter>;
  requiresReview?: Maybe<BooleanFilter>;
  startedAt?: Maybe<NullableDateTimeFilter>;
  submittedAt?: Maybe<NullableDateTimeFilter>;
  timeTaken?: Maybe<NullableIntFilter>;
  title?: Maybe<NullableStringFilter>;
  totalPoints?: Maybe<NullableFloatFilter>;
  type?: Maybe<NullableAssignmentContentTypeEnumFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssignmentTakingUpdateInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssignmentTakingsInput>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightUpdateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingUpdateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingUpdateManyDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingUpdateManyMutationInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingUpdateManyWithoutAssignmentContentInput = {
  connect?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentTakingCreateWithoutAssignmentContentInput>>;
  delete?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssignmentTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  set?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  update?: Maybe<Array<AssignmentTakingUpdateWithWhereUniqueWithoutAssignmentContentInput>>;
  updateMany?: Maybe<Array<AssignmentTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssignmentTakingUpsertWithWhereUniqueWithoutAssignmentContentInput>>;
};

export type AssignmentTakingUpdateManyWithoutLessonTakingInput = {
  connect?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentTakingCreateWithoutLessonTakingInput>>;
  delete?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssignmentTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  set?: Maybe<Array<AssignmentTakingWhereUniqueInput>>;
  update?: Maybe<Array<AssignmentTakingUpdateWithWhereUniqueWithoutLessonTakingInput>>;
  updateMany?: Maybe<Array<AssignmentTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssignmentTakingUpsertWithWhereUniqueWithoutLessonTakingInput>>;
};

export type AssignmentTakingUpdateManyWithWhereNestedInput = {
  data: AssignmentTakingUpdateManyDataInput;
  where: AssignmentTakingScalarWhereInput;
};

export type AssignmentTakingUpdateOneWithoutAssessmentTakingQuestionsInput = {
  connect?: Maybe<AssignmentTakingWhereUniqueInput>;
  create?: Maybe<AssignmentTakingCreateWithoutAssessmentTakingQuestionsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssignmentTakingUpdateWithoutAssessmentTakingQuestionsDataInput>;
  upsert?: Maybe<AssignmentTakingUpsertWithoutAssessmentTakingQuestionsInput>;
};

export type AssignmentTakingUpdateOneWithoutAssignmentTakingWeightInput = {
  connect?: Maybe<AssignmentTakingWhereUniqueInput>;
  create?: Maybe<AssignmentTakingCreateWithoutAssignmentTakingWeightInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssignmentTakingUpdateWithoutAssignmentTakingWeightDataInput>;
  upsert?: Maybe<AssignmentTakingUpsertWithoutAssignmentTakingWeightInput>;
};

export type AssignmentTakingUpdateWithoutAssessmentTakingQuestionsDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssignmentTakingsInput>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightUpdateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingUpdateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingUpdateWithoutAssignmentContentDataInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightUpdateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingUpdateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingUpdateWithoutAssignmentTakingWeightDataInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssignmentTakingsInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  lessonTaking?: Maybe<LessonTakingUpdateOneWithoutAssignmentTakingsInput>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingUpdateWithoutLessonTakingDataInput = {
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionUpdateManyWithoutAssignmentTakingInput>;
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignmentContent?: Maybe<AssignmentContentUpdateOneWithoutAssignmentTakingsInput>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightUpdateOneWithoutAssignmentTakingInput>;
  canBeRetaken?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueDateAt?: Maybe<Scalars['DateTime']>;
  hasBeenGraded?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  isCounted?: Maybe<Scalars['Boolean']>;
  isDone?: Maybe<Scalars['Boolean']>;
  isGradeable?: Maybe<Scalars['Boolean']>;
  isGradeOverride?: Maybe<Scalars['Boolean']>;
  isSkipped?: Maybe<Scalars['Boolean']>;
  maxPoints?: Maybe<Scalars['Float']>;
  maxSecondsAllowed?: Maybe<Scalars['Int']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parentInstructions?: Maybe<Scalars['String']>;
  requiresReview?: Maybe<Scalars['Boolean']>;
  startedAt?: Maybe<Scalars['DateTime']>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  timeTaken?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  totalPoints?: Maybe<Scalars['Float']>;
  type?: Maybe<AssignmentContentTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingUpdateWithWhereUniqueWithoutAssignmentContentInput = {
  data: AssignmentTakingUpdateWithoutAssignmentContentDataInput;
  where: AssignmentTakingWhereUniqueInput;
};

export type AssignmentTakingUpdateWithWhereUniqueWithoutLessonTakingInput = {
  data: AssignmentTakingUpdateWithoutLessonTakingDataInput;
  where: AssignmentTakingWhereUniqueInput;
};

export type AssignmentTakingUpsertWithoutAssessmentTakingQuestionsInput = {
  create: AssignmentTakingCreateWithoutAssessmentTakingQuestionsInput;
  update: AssignmentTakingUpdateWithoutAssessmentTakingQuestionsDataInput;
};

export type AssignmentTakingUpsertWithoutAssignmentTakingWeightInput = {
  create: AssignmentTakingCreateWithoutAssignmentTakingWeightInput;
  update: AssignmentTakingUpdateWithoutAssignmentTakingWeightDataInput;
};

export type AssignmentTakingUpsertWithWhereUniqueWithoutAssignmentContentInput = {
  create: AssignmentTakingCreateWithoutAssignmentContentInput;
  update: AssignmentTakingUpdateWithoutAssignmentContentDataInput;
  where: AssignmentTakingWhereUniqueInput;
};

export type AssignmentTakingUpsertWithWhereUniqueWithoutLessonTakingInput = {
  create: AssignmentTakingCreateWithoutLessonTakingInput;
  update: AssignmentTakingUpdateWithoutLessonTakingDataInput;
  where: AssignmentTakingWhereUniqueInput;
};

export type AssignmentTakingWeight = {
  __typename?: 'AssignmentTakingWeight';
  assignmentTaking?: Maybe<AssignmentTaking>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  weightCategory: CourseTakingWeightCategory;
  weightCategoryId: Scalars['Int'];
};

export type AssignmentTakingWeightCreateInput = {
  assignmentTaking?: Maybe<AssignmentTakingCreateOneWithoutAssignmentTakingWeightInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weightCategory: CourseTakingWeightCategoryCreateOneWithoutAssignmentTakingWeightsInput;
};

export type AssignmentTakingWeightCreateManyWithoutWeightCategoryInput = {
  connect?: Maybe<Array<AssignmentTakingWeightWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentTakingWeightCreateWithoutWeightCategoryInput>>;
};

export type AssignmentTakingWeightCreateOneWithoutAssignmentTakingInput = {
  connect?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  create?: Maybe<AssignmentTakingWeightCreateWithoutAssignmentTakingInput>;
};

export type AssignmentTakingWeightCreateWithoutAssignmentTakingInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weightCategory: CourseTakingWeightCategoryCreateOneWithoutAssignmentTakingWeightsInput;
};

export type AssignmentTakingWeightCreateWithoutWeightCategoryInput = {
  assignmentTaking?: Maybe<AssignmentTakingCreateOneWithoutAssignmentTakingWeightInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingWeightFilter = {
  every?: Maybe<AssignmentTakingWeightWhereInput>;
  none?: Maybe<AssignmentTakingWeightWhereInput>;
  some?: Maybe<AssignmentTakingWeightWhereInput>;
};

export type AssignmentTakingWeightOrderByInput = {
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  weightCategory?: Maybe<OrderByArg>;
  weightCategoryId?: Maybe<OrderByArg>;
};

export type AssignmentTakingWeightScalarWhereInput = {
  AND?: Maybe<Array<AssignmentTakingWeightScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<AssignmentTakingWeightScalarWhereInput>>;
  OR?: Maybe<Array<AssignmentTakingWeightScalarWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
  weightCategoryId?: Maybe<IntFilter>;
};

export type AssignmentTakingWeightUpdateInput = {
  assignmentTaking?: Maybe<AssignmentTakingUpdateOneWithoutAssignmentTakingWeightInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weightCategory?: Maybe<CourseTakingWeightCategoryUpdateOneRequiredWithoutAssignmentTakingWeightsInput>;
};

export type AssignmentTakingWeightUpdateManyDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingWeightUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingWeightUpdateManyWithoutWeightCategoryInput = {
  connect?: Maybe<Array<AssignmentTakingWeightWhereUniqueInput>>;
  create?: Maybe<Array<AssignmentTakingWeightCreateWithoutWeightCategoryInput>>;
  delete?: Maybe<Array<AssignmentTakingWeightWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AssignmentTakingWeightScalarWhereInput>>;
  disconnect?: Maybe<Array<AssignmentTakingWeightWhereUniqueInput>>;
  set?: Maybe<Array<AssignmentTakingWeightWhereUniqueInput>>;
  update?: Maybe<Array<AssignmentTakingWeightUpdateWithWhereUniqueWithoutWeightCategoryInput>>;
  updateMany?: Maybe<Array<AssignmentTakingWeightUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<AssignmentTakingWeightUpsertWithWhereUniqueWithoutWeightCategoryInput>>;
};

export type AssignmentTakingWeightUpdateManyWithWhereNestedInput = {
  data: AssignmentTakingWeightUpdateManyDataInput;
  where: AssignmentTakingWeightScalarWhereInput;
};

export type AssignmentTakingWeightUpdateOneWithoutAssignmentTakingInput = {
  connect?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  create?: Maybe<AssignmentTakingWeightCreateWithoutAssignmentTakingInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AssignmentTakingWeightUpdateWithoutAssignmentTakingDataInput>;
  upsert?: Maybe<AssignmentTakingWeightUpsertWithoutAssignmentTakingInput>;
};

export type AssignmentTakingWeightUpdateWithoutAssignmentTakingDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weightCategory?: Maybe<CourseTakingWeightCategoryUpdateOneRequiredWithoutAssignmentTakingWeightsInput>;
};

export type AssignmentTakingWeightUpdateWithoutWeightCategoryDataInput = {
  assignmentTaking?: Maybe<AssignmentTakingUpdateOneWithoutAssignmentTakingWeightInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AssignmentTakingWeightUpdateWithWhereUniqueWithoutWeightCategoryInput = {
  data: AssignmentTakingWeightUpdateWithoutWeightCategoryDataInput;
  where: AssignmentTakingWeightWhereUniqueInput;
};

export type AssignmentTakingWeightUpsertWithoutAssignmentTakingInput = {
  create: AssignmentTakingWeightCreateWithoutAssignmentTakingInput;
  update: AssignmentTakingWeightUpdateWithoutAssignmentTakingDataInput;
};

export type AssignmentTakingWeightUpsertWithWhereUniqueWithoutWeightCategoryInput = {
  create: AssignmentTakingWeightCreateWithoutWeightCategoryInput;
  update: AssignmentTakingWeightUpdateWithoutWeightCategoryDataInput;
  where: AssignmentTakingWeightWhereUniqueInput;
};

export type AssignmentTakingWeightWhereInput = {
  AND?: Maybe<Array<AssignmentTakingWeightWhereInput>>;
  assignmentTaking?: Maybe<AssignmentTakingWhereInput>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<AssignmentTakingWeightWhereInput>>;
  OR?: Maybe<Array<AssignmentTakingWeightWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
  weightCategory?: Maybe<CourseTakingWeightCategoryWhereInput>;
  weightCategoryId?: Maybe<IntFilter>;
};

export type AssignmentTakingWeightWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type AssignmentTakingWhereInput = {
  AND?: Maybe<Array<AssignmentTakingWhereInput>>;
  assessmentTakingQuestions?: Maybe<AssessmentTakingQuestionFilter>;
  assignedAt?: Maybe<NullableDateTimeFilter>;
  assignmentContent?: Maybe<AssignmentContentWhereInput>;
  assignmentContentId?: Maybe<NullableIntFilter>;
  assignmentTakingWeight?: Maybe<AssignmentTakingWeightWhereInput>;
  assignmentTakingWeightId?: Maybe<NullableIntFilter>;
  canBeRetaken?: Maybe<BooleanFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  dueDateAt?: Maybe<NullableDateTimeFilter>;
  hasBeenGraded?: Maybe<BooleanFilter>;
  id?: Maybe<IntFilter>;
  isCounted?: Maybe<BooleanFilter>;
  isDone?: Maybe<BooleanFilter>;
  isGradeable?: Maybe<NullableBooleanFilter>;
  isGradeOverride?: Maybe<BooleanFilter>;
  isSkipped?: Maybe<BooleanFilter>;
  lessonTaking?: Maybe<LessonTakingWhereInput>;
  lessonTakingId?: Maybe<NullableIntFilter>;
  maxPoints?: Maybe<NullableFloatFilter>;
  maxSecondsAllowed?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<AssignmentTakingWhereInput>>;
  numericGrade?: Maybe<NullableFloatFilter>;
  OR?: Maybe<Array<AssignmentTakingWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  parentInstructions?: Maybe<NullableStringFilter>;
  requiresReview?: Maybe<BooleanFilter>;
  startedAt?: Maybe<NullableDateTimeFilter>;
  submittedAt?: Maybe<NullableDateTimeFilter>;
  timeTaken?: Maybe<NullableIntFilter>;
  title?: Maybe<NullableStringFilter>;
  totalPoints?: Maybe<NullableFloatFilter>;
  type?: Maybe<NullableAssignmentContentTypeEnumFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AssignmentTakingWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type BatchPayload = {
  __typename?: 'BatchPayload';
  count: Scalars['Int'];
};

export type BjupAcctCheck = {
  __typename?: 'BJUPAcctCheck';
  acctNum?: Maybe<Scalars['Int']>;
  foundBJUP: Scalars['Boolean'];
  foundHub: Scalars['Boolean'];
};

export type BjuPressAccount = {
  __typename?: 'BjuPressAccount';
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  customerId?: Maybe<Scalars['Int']>;
  deleted: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  enabled: Scalars['Boolean'];
  firstName?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  lastName?: Maybe<Scalars['String']>;
  originHub: Scalars['Boolean'];
  state?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  zip?: Maybe<Scalars['String']>;
};

export type BjuPressAccountCreateInput = {
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  customerId?: Maybe<Scalars['Int']>;
  deleted?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
  firstName?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  originHub?: Maybe<Scalars['Boolean']>;
  state?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type BjuPressAccountOrderByInput = {
  address1?: Maybe<OrderByArg>;
  address2?: Maybe<OrderByArg>;
  city?: Maybe<OrderByArg>;
  country?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  customerId?: Maybe<OrderByArg>;
  deleted?: Maybe<OrderByArg>;
  email?: Maybe<OrderByArg>;
  enabled?: Maybe<OrderByArg>;
  firstName?: Maybe<OrderByArg>;
  hubUserXid?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  lastName?: Maybe<OrderByArg>;
  originHub?: Maybe<OrderByArg>;
  state?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  zip?: Maybe<OrderByArg>;
};

export type BjuPressAccountUpdateInput = {
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  customerId?: Maybe<Scalars['Int']>;
  deleted?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
  firstName?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  originHub?: Maybe<Scalars['Boolean']>;
  state?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type BjuPressAccountUpdateManyMutationInput = {
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  customerId?: Maybe<Scalars['Int']>;
  deleted?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
  firstName?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  originHub?: Maybe<Scalars['Boolean']>;
  state?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type BjuPressAccountWhereInput = {
  address1?: Maybe<NullableStringFilter>;
  address2?: Maybe<NullableStringFilter>;
  AND?: Maybe<Array<BjuPressAccountWhereInput>>;
  city?: Maybe<NullableStringFilter>;
  country?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  customerId?: Maybe<NullableIntFilter>;
  deleted?: Maybe<BooleanFilter>;
  email?: Maybe<NullableStringFilter>;
  enabled?: Maybe<BooleanFilter>;
  firstName?: Maybe<NullableStringFilter>;
  hubUserXid?: Maybe<NullableIntFilter>;
  id?: Maybe<IntFilter>;
  lastName?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<BjuPressAccountWhereInput>>;
  OR?: Maybe<Array<BjuPressAccountWhereInput>>;
  originHub?: Maybe<BooleanFilter>;
  state?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  zip?: Maybe<NullableStringFilter>;
};

export type BjuPressAccountWhereUniqueInput = {
  customerId?: Maybe<Scalars['Int']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
};

export type BooleanFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<Scalars['Boolean']>;
};

export enum CourseColor {
  Aqua = 'Aqua',
  Blue = 'Blue',
  Default = 'Default',
  Green = 'Green',
  Orange = 'Orange',
  Pink = 'Pink',
  Purple = 'Purple',
  Teal = 'Teal',
  Yellow = 'Yellow',
}

export type CourseColorFilter = {
  equals?: Maybe<CourseColor>;
  in?: Maybe<Array<CourseColor>>;
  not?: Maybe<CourseColor>;
  notIn?: Maybe<Array<CourseColor>>;
};

export type CourseContent = {
  __typename?: 'CourseContent';
  assignmentContent: Array<AssignmentContent>;
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories: Array<CourseContentWeightCategory>;
  courseTakings: Array<CourseTaking>;
  courseType: CourseContentTypeEnum;
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive: Scalars['Boolean'];
  label?: Maybe<Scalars['String']>;
  lessonContents: Array<LessonContent>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  update?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type CourseContentAssignmentContentArgs = {
  after?: Maybe<AssignmentContentWhereUniqueInput>;
  before?: Maybe<AssignmentContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentContentWhereInput>;
};

export type CourseContentCourseContentWeightCategoriesArgs = {
  after?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseContentWeightCategoryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
};

export type CourseContentCourseTakingsArgs = {
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWhereInput>;
};

export type CourseContentLessonContentsArgs = {
  after?: Maybe<LessonContentWhereUniqueInput>;
  before?: Maybe<LessonContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonContentWhereInput>;
};

export type CourseContentCode = {
  __typename?: 'CourseContentCode';
  code: Scalars['String'];
  createdAt: Scalars['DateTime'];
  description: Scalars['String'];
  id: Scalars['Int'];
  type: CourseContentCodeTypeEnum;
  updatedAt: Scalars['DateTime'];
};

export type CourseContentCodeCreateInput = {
  code?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  type: CourseContentCodeTypeEnum;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentCodeOrderByInput = {
  code?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  description?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  type?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export enum CourseContentCodeTypeEnum {
  Edt = 'EDT',
  Ent = 'ENT',
  Grd = 'GRD',
  Sbj = 'SBJ',
  Upd = 'UPD',
}

export type CourseContentCodeTypeEnumFilter = {
  equals?: Maybe<CourseContentCodeTypeEnum>;
  in?: Maybe<Array<CourseContentCodeTypeEnum>>;
  not?: Maybe<CourseContentCodeTypeEnum>;
  notIn?: Maybe<Array<CourseContentCodeTypeEnum>>;
};

export type CourseContentCodeUpdateInput = {
  code?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  type?: Maybe<CourseContentCodeTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentCodeUpdateManyMutationInput = {
  code?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  type?: Maybe<CourseContentCodeTypeEnum>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentCodeWhereInput = {
  AND?: Maybe<Array<CourseContentCodeWhereInput>>;
  code?: Maybe<StringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  description?: Maybe<StringFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<CourseContentCodeWhereInput>>;
  OR?: Maybe<Array<CourseContentCodeWhereInput>>;
  type?: Maybe<CourseContentCodeTypeEnumFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type CourseContentCodeWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type CourseContentCreateInput = {
  assignmentContent?: Maybe<AssignmentContentCreateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryCreateManyWithoutCourseContentInput>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutCourseContentInput>;
  courseType: CourseContentTypeEnum;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentCreateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentCreateOneWithoutAssignmentContentInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutAssignmentContentInput>;
};

export type CourseContentCreateOneWithoutCourseContentWeightCategoriesInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutCourseContentWeightCategoriesInput>;
};

export type CourseContentCreateOneWithoutCourseTakingsInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutCourseTakingsInput>;
};

export type CourseContentCreateOneWithoutLessonContentsInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutLessonContentsInput>;
};

export type CourseContentCreateWithoutAssignmentContentInput = {
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryCreateManyWithoutCourseContentInput>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutCourseContentInput>;
  courseType: CourseContentTypeEnum;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentCreateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentCreateWithoutCourseContentWeightCategoriesInput = {
  assignmentContent?: Maybe<AssignmentContentCreateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutCourseContentInput>;
  courseType: CourseContentTypeEnum;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentCreateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentCreateWithoutCourseTakingsInput = {
  assignmentContent?: Maybe<AssignmentContentCreateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryCreateManyWithoutCourseContentInput>;
  courseType: CourseContentTypeEnum;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentCreateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentCreateWithoutLessonContentsInput = {
  assignmentContent?: Maybe<AssignmentContentCreateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryCreateManyWithoutCourseContentInput>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutCourseContentInput>;
  courseType: CourseContentTypeEnum;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentOrderByInput = {
  courseCode?: Maybe<OrderByArg>;
  courseType?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  description?: Maybe<OrderByArg>;
  edition?: Maybe<OrderByArg>;
  entitlement?: Maybe<OrderByArg>;
  grade?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  imageSource?: Maybe<OrderByArg>;
  information?: Maybe<OrderByArg>;
  isInactive?: Maybe<OrderByArg>;
  label?: Maybe<OrderByArg>;
  pressContentXId?: Maybe<OrderByArg>;
  pressXId?: Maybe<OrderByArg>;
  subject?: Maybe<OrderByArg>;
  teacherBio?: Maybe<OrderByArg>;
  textbookSource?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  update?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export enum CourseContentTypeEnum {
  Alg = 'ALG',
  Dlg = 'DLG',
  Dlo = 'DLO',
  Tlg = 'TLG',
  Vlg = 'VLG',
}

export type CourseContentTypeEnumFilter = {
  equals?: Maybe<CourseContentTypeEnum>;
  in?: Maybe<Array<CourseContentTypeEnum>>;
  not?: Maybe<CourseContentTypeEnum>;
  notIn?: Maybe<Array<CourseContentTypeEnum>>;
};

export type CourseContentUpdateInput = {
  assignmentContent?: Maybe<AssignmentContentUpdateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryUpdateManyWithoutCourseContentInput>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutCourseContentInput>;
  courseType?: Maybe<CourseContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentUpdateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentUpdateManyMutationInput = {
  courseCode?: Maybe<Scalars['String']>;
  courseType?: Maybe<CourseContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentUpdateOneRequiredWithoutCourseContentWeightCategoriesInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutCourseContentWeightCategoriesInput>;
  update?: Maybe<CourseContentUpdateWithoutCourseContentWeightCategoriesDataInput>;
  upsert?: Maybe<CourseContentUpsertWithoutCourseContentWeightCategoriesInput>;
};

export type CourseContentUpdateOneRequiredWithoutCourseTakingsInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutCourseTakingsInput>;
  update?: Maybe<CourseContentUpdateWithoutCourseTakingsDataInput>;
  upsert?: Maybe<CourseContentUpsertWithoutCourseTakingsInput>;
};

export type CourseContentUpdateOneWithoutAssignmentContentInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutAssignmentContentInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<CourseContentUpdateWithoutAssignmentContentDataInput>;
  upsert?: Maybe<CourseContentUpsertWithoutAssignmentContentInput>;
};

export type CourseContentUpdateOneWithoutLessonContentsInput = {
  connect?: Maybe<CourseContentWhereUniqueInput>;
  create?: Maybe<CourseContentCreateWithoutLessonContentsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<CourseContentUpdateWithoutLessonContentsDataInput>;
  upsert?: Maybe<CourseContentUpsertWithoutLessonContentsInput>;
};

export type CourseContentUpdateWithoutAssignmentContentDataInput = {
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryUpdateManyWithoutCourseContentInput>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutCourseContentInput>;
  courseType?: Maybe<CourseContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentUpdateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentUpdateWithoutCourseContentWeightCategoriesDataInput = {
  assignmentContent?: Maybe<AssignmentContentUpdateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutCourseContentInput>;
  courseType?: Maybe<CourseContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentUpdateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentUpdateWithoutCourseTakingsDataInput = {
  assignmentContent?: Maybe<AssignmentContentUpdateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryUpdateManyWithoutCourseContentInput>;
  courseType?: Maybe<CourseContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  lessonContents?: Maybe<LessonContentUpdateManyWithoutCourseContentInput>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentUpdateWithoutLessonContentsDataInput = {
  assignmentContent?: Maybe<AssignmentContentUpdateManyWithoutCourseContentInput>;
  courseCode?: Maybe<Scalars['String']>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryUpdateManyWithoutCourseContentInput>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutCourseContentInput>;
  courseType?: Maybe<CourseContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  edition?: Maybe<Scalars['String']>;
  entitlement?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  imageSource?: Maybe<Scalars['String']>;
  information?: Maybe<Scalars['String']>;
  isInactive?: Maybe<Scalars['Boolean']>;
  label?: Maybe<Scalars['String']>;
  pressContentXId?: Maybe<Scalars['String']>;
  pressXId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  teacherBio?: Maybe<Scalars['String']>;
  textbookSource?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type CourseContentUpsertWithoutAssignmentContentInput = {
  create: CourseContentCreateWithoutAssignmentContentInput;
  update: CourseContentUpdateWithoutAssignmentContentDataInput;
};

export type CourseContentUpsertWithoutCourseContentWeightCategoriesInput = {
  create: CourseContentCreateWithoutCourseContentWeightCategoriesInput;
  update: CourseContentUpdateWithoutCourseContentWeightCategoriesDataInput;
};

export type CourseContentUpsertWithoutCourseTakingsInput = {
  create: CourseContentCreateWithoutCourseTakingsInput;
  update: CourseContentUpdateWithoutCourseTakingsDataInput;
};

export type CourseContentUpsertWithoutLessonContentsInput = {
  create: CourseContentCreateWithoutLessonContentsInput;
  update: CourseContentUpdateWithoutLessonContentsDataInput;
};

export type CourseContentWeightCategory = {
  __typename?: 'CourseContentWeightCategory';
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  courseContent: CourseContent;
  courseContentId: Scalars['Int'];
  courseTakingWeightCategories: Array<CourseTakingWeightCategory>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryCourseTakingWeightCategoriesArgs = {
  after?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingWeightCategoryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type CourseContentWeightCategoryCreateInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  courseContent: CourseContentCreateOneWithoutCourseContentWeightCategoriesInput;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseContentWeightCategoryInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryCreateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<CourseContentWeightCategoryWhereUniqueInput>>;
  create?: Maybe<Array<CourseContentWeightCategoryCreateWithoutCourseContentInput>>;
};

export type CourseContentWeightCategoryCreateOneWithoutCourseTakingWeightCategoriesInput = {
  connect?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  create?: Maybe<CourseContentWeightCategoryCreateWithoutCourseTakingWeightCategoriesInput>;
};

export type CourseContentWeightCategoryCreateWithoutCourseContentInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseContentWeightCategoryInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryCreateWithoutCourseTakingWeightCategoriesInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  courseContent: CourseContentCreateOneWithoutCourseContentWeightCategoriesInput;
  createdAt?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryFilter = {
  every?: Maybe<CourseContentWeightCategoryWhereInput>;
  none?: Maybe<CourseContentWeightCategoryWhereInput>;
  some?: Maybe<CourseContentWeightCategoryWhereInput>;
};

export type CourseContentWeightCategoryOrderByInput = {
  assignmentType?: Maybe<OrderByArg>;
  courseContent?: Maybe<OrderByArg>;
  courseContentId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  weight?: Maybe<OrderByArg>;
};

export type CourseContentWeightCategoryScalarWhereInput = {
  AND?: Maybe<Array<CourseContentWeightCategoryScalarWhereInput>>;
  assignmentType?: Maybe<NullableAssignmentContentTypeEnumFilter>;
  courseContentId?: Maybe<IntFilter>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<CourseContentWeightCategoryScalarWhereInput>>;
  OR?: Maybe<Array<CourseContentWeightCategoryScalarWhereInput>>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  weight?: Maybe<NullableIntFilter>;
};

export type CourseContentWeightCategoryUpdateInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseContentWeightCategoriesInput>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseContentWeightCategoryInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryUpdateManyDataInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryUpdateManyMutationInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryUpdateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<CourseContentWeightCategoryWhereUniqueInput>>;
  create?: Maybe<Array<CourseContentWeightCategoryCreateWithoutCourseContentInput>>;
  delete?: Maybe<Array<CourseContentWeightCategoryWhereUniqueInput>>;
  deleteMany?: Maybe<Array<CourseContentWeightCategoryScalarWhereInput>>;
  disconnect?: Maybe<Array<CourseContentWeightCategoryWhereUniqueInput>>;
  set?: Maybe<Array<CourseContentWeightCategoryWhereUniqueInput>>;
  update?: Maybe<Array<CourseContentWeightCategoryUpdateWithWhereUniqueWithoutCourseContentInput>>;
  updateMany?: Maybe<Array<CourseContentWeightCategoryUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<CourseContentWeightCategoryUpsertWithWhereUniqueWithoutCourseContentInput>>;
};

export type CourseContentWeightCategoryUpdateManyWithWhereNestedInput = {
  data: CourseContentWeightCategoryUpdateManyDataInput;
  where: CourseContentWeightCategoryScalarWhereInput;
};

export type CourseContentWeightCategoryUpdateOneWithoutCourseTakingWeightCategoriesInput = {
  connect?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  create?: Maybe<CourseContentWeightCategoryCreateWithoutCourseTakingWeightCategoriesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<CourseContentWeightCategoryUpdateWithoutCourseTakingWeightCategoriesDataInput>;
  upsert?: Maybe<CourseContentWeightCategoryUpsertWithoutCourseTakingWeightCategoriesInput>;
};

export type CourseContentWeightCategoryUpdateWithoutCourseContentDataInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseContentWeightCategoryInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryUpdateWithoutCourseTakingWeightCategoriesDataInput = {
  assignmentType?: Maybe<AssignmentContentTypeEnum>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseContentWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseContentWeightCategoryUpdateWithWhereUniqueWithoutCourseContentInput = {
  data: CourseContentWeightCategoryUpdateWithoutCourseContentDataInput;
  where: CourseContentWeightCategoryWhereUniqueInput;
};

export type CourseContentWeightCategoryUpsertWithoutCourseTakingWeightCategoriesInput = {
  create: CourseContentWeightCategoryCreateWithoutCourseTakingWeightCategoriesInput;
  update: CourseContentWeightCategoryUpdateWithoutCourseTakingWeightCategoriesDataInput;
};

export type CourseContentWeightCategoryUpsertWithWhereUniqueWithoutCourseContentInput = {
  create: CourseContentWeightCategoryCreateWithoutCourseContentInput;
  update: CourseContentWeightCategoryUpdateWithoutCourseContentDataInput;
  where: CourseContentWeightCategoryWhereUniqueInput;
};

export type CourseContentWeightCategoryWhereInput = {
  AND?: Maybe<Array<CourseContentWeightCategoryWhereInput>>;
  assignmentType?: Maybe<NullableAssignmentContentTypeEnumFilter>;
  courseContent?: Maybe<CourseContentWhereInput>;
  courseContentId?: Maybe<IntFilter>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<CourseContentWeightCategoryWhereInput>>;
  OR?: Maybe<Array<CourseContentWeightCategoryWhereInput>>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  weight?: Maybe<NullableIntFilter>;
};

export type CourseContentWeightCategoryWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type CourseContentWhereInput = {
  AND?: Maybe<Array<CourseContentWhereInput>>;
  assignmentContent?: Maybe<AssignmentContentFilter>;
  courseCode?: Maybe<NullableStringFilter>;
  courseContentWeightCategories?: Maybe<CourseContentWeightCategoryFilter>;
  courseTakings?: Maybe<CourseTakingFilter>;
  courseType?: Maybe<CourseContentTypeEnumFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  description?: Maybe<NullableStringFilter>;
  edition?: Maybe<NullableStringFilter>;
  entitlement?: Maybe<NullableStringFilter>;
  grade?: Maybe<NullableStringFilter>;
  id?: Maybe<IntFilter>;
  imageSource?: Maybe<NullableStringFilter>;
  information?: Maybe<NullableStringFilter>;
  isInactive?: Maybe<BooleanFilter>;
  label?: Maybe<NullableStringFilter>;
  lessonContents?: Maybe<LessonContentFilter>;
  NOT?: Maybe<Array<CourseContentWhereInput>>;
  OR?: Maybe<Array<CourseContentWhereInput>>;
  pressContentXId?: Maybe<NullableStringFilter>;
  pressXId?: Maybe<NullableIntFilter>;
  subject?: Maybe<NullableStringFilter>;
  teacherBio?: Maybe<NullableStringFilter>;
  textbookSource?: Maybe<NullableStringFilter>;
  title?: Maybe<StringFilter>;
  update?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type CourseContentWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type CourseOrder = {
  id: Scalars['Int'];
  order: Scalars['Int'];
};

export type CourseOverview = {
  __typename?: 'CourseOverview';
  color?: Maybe<CourseColor>;
  courseTaking?: Maybe<CourseTaking>;
  gradeScale?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lessonTaking?: Maybe<JustId>;
  numericGrade?: Maybe<Scalars['Float']>;
  title?: Maybe<Scalars['String']>;
  totalGrades?: Maybe<Array<TotalGrades>>;
};

export type CourseProgressAndLateItem = {
  __typename?: 'CourseProgressAndLateItem';
  id: Scalars['Int'];
  lateItem: Scalars['Int'];
  progress: Scalars['Int'];
};

export type CourseTaking = {
  __typename?: 'CourseTaking';
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag: Scalars['Boolean'];
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseContent: CourseContent;
  courseContentId: Scalars['Int'];
  courseTakingWeightCategories: Array<CourseTakingWeightCategory>;
  createdAt: Scalars['DateTime'];
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri: Scalars['Boolean'];
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments: Scalars['Boolean'];
  hasOnlineVideos: Scalars['Boolean'];
  id: Scalars['Int'];
  lessonsPerDay: Scalars['Int'];
  lessonTakings: Array<LessonTaking>;
  mon: Scalars['Boolean'];
  numericGrade?: Maybe<Scalars['Float']>;
  order: Scalars['Int'];
  parent: Parent;
  parentId: Scalars['Int'];
  pressXid?: Maybe<Scalars['Int']>;
  sat: Scalars['Boolean'];
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<Student>;
  studentId?: Maybe<Scalars['Int']>;
  sun: Scalars['Boolean'];
  thu: Scalars['Boolean'];
  tue: Scalars['Boolean'];
  updatedAt: Scalars['DateTime'];
  useGradeWeights: Scalars['Boolean'];
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']>;
  wed: Scalars['Boolean'];
};

export type CourseTakingCourseTakingWeightCategoriesArgs = {
  after?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingWeightCategoryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type CourseTakingLessonTakingsArgs = {
  after?: Maybe<LessonTakingWhereUniqueInput>;
  before?: Maybe<LessonTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonTakingWhereInput>;
};

export type CourseTakingCreateInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseContent: CourseContentCreateOneWithoutCourseTakingsInput;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutCourseTakingsInput;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentCreateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserCreateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingCreateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutCourseContentInput>>;
};

export type CourseTakingCreateManyWithoutParentInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutParentInput>>;
};

export type CourseTakingCreateManyWithoutStudentInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutStudentInput>>;
};

export type CourseTakingCreateManyWithoutUserInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutUserInput>>;
};

export type CourseTakingCreateOneWithoutCourseTakingWeightCategoriesInput = {
  connect?: Maybe<CourseTakingWhereUniqueInput>;
  create?: Maybe<CourseTakingCreateWithoutCourseTakingWeightCategoriesInput>;
};

export type CourseTakingCreateOneWithoutLessonTakingsInput = {
  connect?: Maybe<CourseTakingWhereUniqueInput>;
  create?: Maybe<CourseTakingCreateWithoutLessonTakingsInput>;
};

export type CourseTakingCreateWithoutCourseContentInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutCourseTakingsInput;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentCreateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserCreateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingCreateWithoutCourseTakingWeightCategoriesInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseContent: CourseContentCreateOneWithoutCourseTakingsInput;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutCourseTakingsInput;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentCreateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserCreateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingCreateWithoutLessonTakingsInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseContent: CourseContentCreateOneWithoutCourseTakingsInput;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutCourseTakingsInput;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentCreateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserCreateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingCreateWithoutParentInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseContent: CourseContentCreateOneWithoutCourseTakingsInput;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentCreateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserCreateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingCreateWithoutStudentInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseContent: CourseContentCreateOneWithoutCourseTakingsInput;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutCourseTakingsInput;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserCreateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingCreateWithoutUserInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor: CourseColor;
  courseContent: CourseContentCreateOneWithoutCourseTakingsInput;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryCreateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutCourseTakingsInput;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentCreateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingFilter = {
  every?: Maybe<CourseTakingWhereInput>;
  none?: Maybe<CourseTakingWhereInput>;
  some?: Maybe<CourseTakingWhereInput>;
};

export type CourseTakingOrderByInput = {
  assignedAt?: Maybe<OrderByArg>;
  assignedFlag?: Maybe<OrderByArg>;
  bookRedemptionCode?: Maybe<OrderByArg>;
  courseColor?: Maybe<OrderByArg>;
  courseContent?: Maybe<OrderByArg>;
  courseContentId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  endDate?: Maybe<OrderByArg>;
  entitlementEndDate?: Maybe<OrderByArg>;
  entitlementStartDate?: Maybe<OrderByArg>;
  fri?: Maybe<OrderByArg>;
  gradeScale?: Maybe<OrderByArg>;
  hasOnlineAssessments?: Maybe<OrderByArg>;
  hasOnlineVideos?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  lessonsPerDay?: Maybe<OrderByArg>;
  mon?: Maybe<OrderByArg>;
  numericGrade?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  parent?: Maybe<OrderByArg>;
  parentId?: Maybe<OrderByArg>;
  pressXid?: Maybe<OrderByArg>;
  sat?: Maybe<OrderByArg>;
  startDate?: Maybe<OrderByArg>;
  status?: Maybe<OrderByArg>;
  student?: Maybe<OrderByArg>;
  studentId?: Maybe<OrderByArg>;
  sun?: Maybe<OrderByArg>;
  thu?: Maybe<OrderByArg>;
  tue?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  useGradeWeights?: Maybe<OrderByArg>;
  user?: Maybe<OrderByArg>;
  userId?: Maybe<OrderByArg>;
  wed?: Maybe<OrderByArg>;
};

export type CourseTakingScalarWhereInput = {
  AND?: Maybe<Array<CourseTakingScalarWhereInput>>;
  assignedAt?: Maybe<NullableDateTimeFilter>;
  assignedFlag?: Maybe<BooleanFilter>;
  bookRedemptionCode?: Maybe<NullableStringFilter>;
  courseColor?: Maybe<CourseColorFilter>;
  courseContentId?: Maybe<IntFilter>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  endDate?: Maybe<NullableDateTimeFilter>;
  entitlementEndDate?: Maybe<NullableDateTimeFilter>;
  entitlementStartDate?: Maybe<NullableDateTimeFilter>;
  fri?: Maybe<BooleanFilter>;
  gradeScale?: Maybe<NullableFloatFilter>;
  hasOnlineAssessments?: Maybe<BooleanFilter>;
  hasOnlineVideos?: Maybe<BooleanFilter>;
  id?: Maybe<IntFilter>;
  lessonsPerDay?: Maybe<IntFilter>;
  lessonTakings?: Maybe<LessonTakingFilter>;
  mon?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<CourseTakingScalarWhereInput>>;
  numericGrade?: Maybe<NullableFloatFilter>;
  OR?: Maybe<Array<CourseTakingScalarWhereInput>>;
  order?: Maybe<IntFilter>;
  parentId?: Maybe<IntFilter>;
  pressXid?: Maybe<NullableIntFilter>;
  sat?: Maybe<BooleanFilter>;
  startDate?: Maybe<NullableDateTimeFilter>;
  status?: Maybe<NullableCourseTakingStatusFilter>;
  studentId?: Maybe<NullableIntFilter>;
  sun?: Maybe<BooleanFilter>;
  thu?: Maybe<BooleanFilter>;
  tue?: Maybe<BooleanFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  useGradeWeights?: Maybe<BooleanFilter>;
  userId?: Maybe<NullableIntFilter>;
  wed?: Maybe<BooleanFilter>;
};

export enum CourseTakingStatus {
  Active = 'Active',
  Disabled = 'Disabled',
  Expired = 'Expired',
  Returned = 'Returned',
  Voided = 'Voided',
}

export type CourseTakingUpdateInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseTakingsInput>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCourseTakingsInput>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentUpdateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserUpdateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateManyDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateManyMutationInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutCourseContentInput>>;
  delete?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<CourseTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  set?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  update?: Maybe<Array<CourseTakingUpdateWithWhereUniqueWithoutCourseContentInput>>;
  updateMany?: Maybe<Array<CourseTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<CourseTakingUpsertWithWhereUniqueWithoutCourseContentInput>>;
};

export type CourseTakingUpdateManyWithoutParentInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutParentInput>>;
  delete?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<CourseTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  set?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  update?: Maybe<Array<CourseTakingUpdateWithWhereUniqueWithoutParentInput>>;
  updateMany?: Maybe<Array<CourseTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<CourseTakingUpsertWithWhereUniqueWithoutParentInput>>;
};

export type CourseTakingUpdateManyWithoutStudentInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutStudentInput>>;
  delete?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<CourseTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  set?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  update?: Maybe<Array<CourseTakingUpdateWithWhereUniqueWithoutStudentInput>>;
  updateMany?: Maybe<Array<CourseTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<CourseTakingUpsertWithWhereUniqueWithoutStudentInput>>;
};

export type CourseTakingUpdateManyWithoutUserInput = {
  connect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingCreateWithoutUserInput>>;
  delete?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<CourseTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  set?: Maybe<Array<CourseTakingWhereUniqueInput>>;
  update?: Maybe<Array<CourseTakingUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: Maybe<Array<CourseTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<CourseTakingUpsertWithWhereUniqueWithoutUserInput>>;
};

export type CourseTakingUpdateManyWithWhereNestedInput = {
  data: CourseTakingUpdateManyDataInput;
  where: CourseTakingScalarWhereInput;
};

export type CourseTakingUpdateOneWithoutCourseTakingWeightCategoriesInput = {
  connect?: Maybe<CourseTakingWhereUniqueInput>;
  create?: Maybe<CourseTakingCreateWithoutCourseTakingWeightCategoriesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<CourseTakingUpdateWithoutCourseTakingWeightCategoriesDataInput>;
  upsert?: Maybe<CourseTakingUpsertWithoutCourseTakingWeightCategoriesInput>;
};

export type CourseTakingUpdateOneWithoutLessonTakingsInput = {
  connect?: Maybe<CourseTakingWhereUniqueInput>;
  create?: Maybe<CourseTakingCreateWithoutLessonTakingsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<CourseTakingUpdateWithoutLessonTakingsDataInput>;
  upsert?: Maybe<CourseTakingUpsertWithoutLessonTakingsInput>;
};

export type CourseTakingUpdateWithoutCourseContentDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCourseTakingsInput>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentUpdateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserUpdateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateWithoutCourseTakingWeightCategoriesDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseTakingsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCourseTakingsInput>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentUpdateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserUpdateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateWithoutLessonTakingsDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseTakingsInput>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCourseTakingsInput>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentUpdateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserUpdateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateWithoutParentDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseTakingsInput>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentUpdateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserUpdateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateWithoutStudentDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseTakingsInput>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCourseTakingsInput>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  user?: Maybe<UserUpdateOneWithoutCourseTakingsInput>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateWithoutUserDataInput = {
  assignedAt?: Maybe<Scalars['DateTime']>;
  assignedFlag?: Maybe<Scalars['Boolean']>;
  bookRedemptionCode?: Maybe<Scalars['String']>;
  courseColor?: Maybe<CourseColor>;
  courseContent?: Maybe<CourseContentUpdateOneRequiredWithoutCourseTakingsInput>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryUpdateManyWithoutCourseTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  entitlementEndDate?: Maybe<Scalars['DateTime']>;
  entitlementStartDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  hasOnlineAssessments?: Maybe<Scalars['Boolean']>;
  hasOnlineVideos?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutCourseTakingInput>;
  mon?: Maybe<Scalars['Boolean']>;
  numericGrade?: Maybe<Scalars['Float']>;
  order?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutCourseTakingsInput>;
  pressXid?: Maybe<Scalars['Int']>;
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  status?: Maybe<CourseTakingStatus>;
  student?: Maybe<StudentUpdateOneWithoutCourseTakingsInput>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  useGradeWeights?: Maybe<Scalars['Boolean']>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type CourseTakingUpdateWithWhereUniqueWithoutCourseContentInput = {
  data: CourseTakingUpdateWithoutCourseContentDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingUpdateWithWhereUniqueWithoutParentInput = {
  data: CourseTakingUpdateWithoutParentDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingUpdateWithWhereUniqueWithoutStudentInput = {
  data: CourseTakingUpdateWithoutStudentDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingUpdateWithWhereUniqueWithoutUserInput = {
  data: CourseTakingUpdateWithoutUserDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingUpsertWithoutCourseTakingWeightCategoriesInput = {
  create: CourseTakingCreateWithoutCourseTakingWeightCategoriesInput;
  update: CourseTakingUpdateWithoutCourseTakingWeightCategoriesDataInput;
};

export type CourseTakingUpsertWithoutLessonTakingsInput = {
  create: CourseTakingCreateWithoutLessonTakingsInput;
  update: CourseTakingUpdateWithoutLessonTakingsDataInput;
};

export type CourseTakingUpsertWithWhereUniqueWithoutCourseContentInput = {
  create: CourseTakingCreateWithoutCourseContentInput;
  update: CourseTakingUpdateWithoutCourseContentDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingUpsertWithWhereUniqueWithoutParentInput = {
  create: CourseTakingCreateWithoutParentInput;
  update: CourseTakingUpdateWithoutParentDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingUpsertWithWhereUniqueWithoutStudentInput = {
  create: CourseTakingCreateWithoutStudentInput;
  update: CourseTakingUpdateWithoutStudentDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingUpsertWithWhereUniqueWithoutUserInput = {
  create: CourseTakingCreateWithoutUserInput;
  update: CourseTakingUpdateWithoutUserDataInput;
  where: CourseTakingWhereUniqueInput;
};

export type CourseTakingWeightCategory = {
  __typename?: 'CourseTakingWeightCategory';
  assignmentTakingWeights: Array<AssignmentTakingWeight>;
  courseContentWeightCategory?: Maybe<CourseContentWeightCategory>;
  courseContentWeightCategoryId?: Maybe<Scalars['Int']>;
  courseTaking?: Maybe<CourseTaking>;
  courseTakingId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryAssignmentTakingWeightsArgs = {
  after?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingWeightOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWeightWhereInput>;
};

export type CourseTakingWeightCategoryCreateInput = {
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightCreateManyWithoutWeightCategoryInput>;
  courseContentWeightCategory?: Maybe<CourseContentWeightCategoryCreateOneWithoutCourseTakingWeightCategoriesInput>;
  courseTaking?: Maybe<CourseTakingCreateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryCreateManyWithoutCourseContentWeightCategoryInput = {
  connect?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingWeightCategoryCreateWithoutCourseContentWeightCategoryInput>>;
};

export type CourseTakingWeightCategoryCreateManyWithoutCourseTakingInput = {
  connect?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingWeightCategoryCreateWithoutCourseTakingInput>>;
};

export type CourseTakingWeightCategoryCreateOneWithoutAssignmentTakingWeightsInput = {
  connect?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  create?: Maybe<CourseTakingWeightCategoryCreateWithoutAssignmentTakingWeightsInput>;
};

export type CourseTakingWeightCategoryCreateWithoutAssignmentTakingWeightsInput = {
  courseContentWeightCategory?: Maybe<CourseContentWeightCategoryCreateOneWithoutCourseTakingWeightCategoriesInput>;
  courseTaking?: Maybe<CourseTakingCreateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryCreateWithoutCourseContentWeightCategoryInput = {
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightCreateManyWithoutWeightCategoryInput>;
  courseTaking?: Maybe<CourseTakingCreateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryCreateWithoutCourseTakingInput = {
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightCreateManyWithoutWeightCategoryInput>;
  courseContentWeightCategory?: Maybe<CourseContentWeightCategoryCreateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryFilter = {
  every?: Maybe<CourseTakingWeightCategoryWhereInput>;
  none?: Maybe<CourseTakingWeightCategoryWhereInput>;
  some?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type CourseTakingWeightCategoryOrderByInput = {
  courseContentWeightCategory?: Maybe<OrderByArg>;
  courseContentWeightCategoryId?: Maybe<OrderByArg>;
  courseTaking?: Maybe<OrderByArg>;
  courseTakingId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  originalTitle?: Maybe<OrderByArg>;
  originalWeight?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  weight?: Maybe<OrderByArg>;
};

export type CourseTakingWeightCategoryScalarWhereInput = {
  AND?: Maybe<Array<CourseTakingWeightCategoryScalarWhereInput>>;
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightFilter>;
  courseContentWeightCategoryId?: Maybe<NullableIntFilter>;
  courseTakingId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<CourseTakingWeightCategoryScalarWhereInput>>;
  OR?: Maybe<Array<CourseTakingWeightCategoryScalarWhereInput>>;
  originalTitle?: Maybe<NullableStringFilter>;
  originalWeight?: Maybe<NullableIntFilter>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  weight?: Maybe<NullableIntFilter>;
};

export type CourseTakingWeightCategoryUpdateInput = {
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightUpdateManyWithoutWeightCategoryInput>;
  courseContentWeightCategory?: Maybe<CourseContentWeightCategoryUpdateOneWithoutCourseTakingWeightCategoriesInput>;
  courseTaking?: Maybe<CourseTakingUpdateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryUpdateManyDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryUpdateManyWithoutCourseContentWeightCategoryInput = {
  connect?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingWeightCategoryCreateWithoutCourseContentWeightCategoryInput>>;
  delete?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  deleteMany?: Maybe<Array<CourseTakingWeightCategoryScalarWhereInput>>;
  disconnect?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  set?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  update?: Maybe<Array<CourseTakingWeightCategoryUpdateWithWhereUniqueWithoutCourseContentWeightCategoryInput>>;
  updateMany?: Maybe<Array<CourseTakingWeightCategoryUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<CourseTakingWeightCategoryUpsertWithWhereUniqueWithoutCourseContentWeightCategoryInput>>;
};

export type CourseTakingWeightCategoryUpdateManyWithoutCourseTakingInput = {
  connect?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  create?: Maybe<Array<CourseTakingWeightCategoryCreateWithoutCourseTakingInput>>;
  delete?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  deleteMany?: Maybe<Array<CourseTakingWeightCategoryScalarWhereInput>>;
  disconnect?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  set?: Maybe<Array<CourseTakingWeightCategoryWhereUniqueInput>>;
  update?: Maybe<Array<CourseTakingWeightCategoryUpdateWithWhereUniqueWithoutCourseTakingInput>>;
  updateMany?: Maybe<Array<CourseTakingWeightCategoryUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<CourseTakingWeightCategoryUpsertWithWhereUniqueWithoutCourseTakingInput>>;
};

export type CourseTakingWeightCategoryUpdateManyWithWhereNestedInput = {
  data: CourseTakingWeightCategoryUpdateManyDataInput;
  where: CourseTakingWeightCategoryScalarWhereInput;
};

export type CourseTakingWeightCategoryUpdateOneRequiredWithoutAssignmentTakingWeightsInput = {
  connect?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  create?: Maybe<CourseTakingWeightCategoryCreateWithoutAssignmentTakingWeightsInput>;
  update?: Maybe<CourseTakingWeightCategoryUpdateWithoutAssignmentTakingWeightsDataInput>;
  upsert?: Maybe<CourseTakingWeightCategoryUpsertWithoutAssignmentTakingWeightsInput>;
};

export type CourseTakingWeightCategoryUpdateWithoutAssignmentTakingWeightsDataInput = {
  courseContentWeightCategory?: Maybe<CourseContentWeightCategoryUpdateOneWithoutCourseTakingWeightCategoriesInput>;
  courseTaking?: Maybe<CourseTakingUpdateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryUpdateWithoutCourseContentWeightCategoryDataInput = {
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightUpdateManyWithoutWeightCategoryInput>;
  courseTaking?: Maybe<CourseTakingUpdateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryUpdateWithoutCourseTakingDataInput = {
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightUpdateManyWithoutWeightCategoryInput>;
  courseContentWeightCategory?: Maybe<CourseContentWeightCategoryUpdateOneWithoutCourseTakingWeightCategoriesInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  originalTitle?: Maybe<Scalars['String']>;
  originalWeight?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weight?: Maybe<Scalars['Int']>;
};

export type CourseTakingWeightCategoryUpdateWithWhereUniqueWithoutCourseContentWeightCategoryInput = {
  data: CourseTakingWeightCategoryUpdateWithoutCourseContentWeightCategoryDataInput;
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type CourseTakingWeightCategoryUpdateWithWhereUniqueWithoutCourseTakingInput = {
  data: CourseTakingWeightCategoryUpdateWithoutCourseTakingDataInput;
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type CourseTakingWeightCategoryUpsertWithoutAssignmentTakingWeightsInput = {
  create: CourseTakingWeightCategoryCreateWithoutAssignmentTakingWeightsInput;
  update: CourseTakingWeightCategoryUpdateWithoutAssignmentTakingWeightsDataInput;
};

export type CourseTakingWeightCategoryUpsertWithWhereUniqueWithoutCourseContentWeightCategoryInput = {
  create: CourseTakingWeightCategoryCreateWithoutCourseContentWeightCategoryInput;
  update: CourseTakingWeightCategoryUpdateWithoutCourseContentWeightCategoryDataInput;
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type CourseTakingWeightCategoryUpsertWithWhereUniqueWithoutCourseTakingInput = {
  create: CourseTakingWeightCategoryCreateWithoutCourseTakingInput;
  update: CourseTakingWeightCategoryUpdateWithoutCourseTakingDataInput;
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type CourseTakingWeightCategoryWhereInput = {
  AND?: Maybe<Array<CourseTakingWeightCategoryWhereInput>>;
  assignmentTakingWeights?: Maybe<AssignmentTakingWeightFilter>;
  courseContentWeightCategory?: Maybe<CourseContentWeightCategoryWhereInput>;
  courseContentWeightCategoryId?: Maybe<NullableIntFilter>;
  courseTaking?: Maybe<CourseTakingWhereInput>;
  courseTakingId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<CourseTakingWeightCategoryWhereInput>>;
  OR?: Maybe<Array<CourseTakingWeightCategoryWhereInput>>;
  originalTitle?: Maybe<NullableStringFilter>;
  originalWeight?: Maybe<NullableIntFilter>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  weight?: Maybe<NullableIntFilter>;
};

export type CourseTakingWeightCategoryWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type CourseTakingWhereInput = {
  AND?: Maybe<Array<CourseTakingWhereInput>>;
  assignedAt?: Maybe<NullableDateTimeFilter>;
  assignedFlag?: Maybe<BooleanFilter>;
  bookRedemptionCode?: Maybe<NullableStringFilter>;
  courseColor?: Maybe<CourseColorFilter>;
  courseContent?: Maybe<CourseContentWhereInput>;
  courseContentId?: Maybe<IntFilter>;
  courseTakingWeightCategories?: Maybe<CourseTakingWeightCategoryFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  endDate?: Maybe<NullableDateTimeFilter>;
  entitlementEndDate?: Maybe<NullableDateTimeFilter>;
  entitlementStartDate?: Maybe<NullableDateTimeFilter>;
  fri?: Maybe<BooleanFilter>;
  gradeScale?: Maybe<NullableFloatFilter>;
  hasOnlineAssessments?: Maybe<BooleanFilter>;
  hasOnlineVideos?: Maybe<BooleanFilter>;
  id?: Maybe<IntFilter>;
  lessonsPerDay?: Maybe<IntFilter>;
  lessonTakings?: Maybe<LessonTakingFilter>;
  mon?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<CourseTakingWhereInput>>;
  numericGrade?: Maybe<NullableFloatFilter>;
  OR?: Maybe<Array<CourseTakingWhereInput>>;
  order?: Maybe<IntFilter>;
  parent?: Maybe<ParentWhereInput>;
  parentId?: Maybe<IntFilter>;
  pressXid?: Maybe<NullableIntFilter>;
  sat?: Maybe<BooleanFilter>;
  startDate?: Maybe<NullableDateTimeFilter>;
  status?: Maybe<NullableCourseTakingStatusFilter>;
  student?: Maybe<StudentWhereInput>;
  studentId?: Maybe<NullableIntFilter>;
  sun?: Maybe<BooleanFilter>;
  thu?: Maybe<BooleanFilter>;
  tue?: Maybe<BooleanFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  useGradeWeights?: Maybe<BooleanFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<NullableIntFilter>;
  wed?: Maybe<BooleanFilter>;
};

export type CourseTakingWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  pressXid?: Maybe<Scalars['Int']>;
};

export type DateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<Scalars['DateTime']>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type Enum = {
  __typename?: 'Enum';
  fields: Array<Scalars['String']>;
  name: Scalars['String'];
};

export type Event = {
  __typename?: 'Event';
  childEvents: Array<EventChildren>;
  color: Scalars['String'];
  createdAt: Scalars['DateTime'];
  creator: User;
  creatorId: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  id: Scalars['Int'];
  isFullDayEvent: Scalars['Boolean'];
  isRecurring: Scalars['Boolean'];
  order: Scalars['Int'];
  person?: Maybe<Person>;
  personId?: Maybe<Scalars['Int']>;
  recurringPattern?: Maybe<EventRecurringPattern>;
  recurringPatternId?: Maybe<Scalars['Int']>;
  shiftCoursesFlag: Scalars['Boolean'];
  startDate: Scalars['DateTime'];
  title: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  users: Array<User>;
};

export type EventChildEventsArgs = {
  after?: Maybe<EventChildrenWhereUniqueInput>;
  before?: Maybe<EventChildrenWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventChildrenOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventChildrenWhereInput>;
};

export type EventUsersArgs = {
  after?: Maybe<UserWhereUniqueInput>;
  before?: Maybe<UserWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<UserOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<UserWhereInput>;
};

export type Event2 = {
  __typename?: 'Event2';
  allDay: Scalars['Boolean'];
  assignedStudentId?: Maybe<Scalars['Int']>;
  color: CourseColor;
  completed?: Maybe<Scalars['Boolean']>;
  courseTakingId?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  eventType: Scalars['String'];
  gradeBadge?: Maybe<Scalars['Boolean']>;
  id: Scalars['Int'];
  invitees?: Maybe<Array<User>>;
  isFullDayEvent: Scalars['Boolean'];
  isRecurring: Scalars['Boolean'];
  lateBadge?: Maybe<Scalars['Boolean']>;
  lessonTakingId?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  parentEndDate?: Maybe<Scalars['DateTime']>;
  parentEventId?: Maybe<Scalars['Int']>;
  parentStartDate?: Maybe<Scalars['DateTime']>;
  recurringType?: Maybe<RecurringType>;
  shiftCoursesFlag: Scalars['Boolean'];
  startDate: Scalars['DateTime'];
  title: Scalars['String'];
};

export type EventChildren = {
  __typename?: 'EventChildren';
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  id: Scalars['Int'];
  parentEvent: Event;
  parentEventId: Scalars['Int'];
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type EventChildrenCreateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  parentEvent: EventCreateOneWithoutChildEventsInput;
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventChildrenCreateManyWithoutParentEventInput = {
  connect?: Maybe<Array<EventChildrenWhereUniqueInput>>;
  create?: Maybe<Array<EventChildrenCreateWithoutParentEventInput>>;
};

export type EventChildrenCreateWithoutParentEventInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventChildrenFilter = {
  every?: Maybe<EventChildrenWhereInput>;
  none?: Maybe<EventChildrenWhereInput>;
  some?: Maybe<EventChildrenWhereInput>;
};

export type EventChildrenOrderByInput = {
  createdAt?: Maybe<OrderByArg>;
  description?: Maybe<OrderByArg>;
  endDate?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  parentEvent?: Maybe<OrderByArg>;
  parentEventId?: Maybe<OrderByArg>;
  startDate?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type EventChildrenScalarWhereInput = {
  AND?: Maybe<Array<EventChildrenScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  description?: Maybe<NullableStringFilter>;
  endDate?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<EventChildrenScalarWhereInput>>;
  OR?: Maybe<Array<EventChildrenScalarWhereInput>>;
  parentEventId?: Maybe<IntFilter>;
  startDate?: Maybe<DateTimeFilter>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type EventChildrenUpdateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  parentEvent?: Maybe<EventUpdateOneRequiredWithoutChildEventsInput>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventChildrenUpdateManyDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventChildrenUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventChildrenUpdateManyWithoutParentEventInput = {
  connect?: Maybe<Array<EventChildrenWhereUniqueInput>>;
  create?: Maybe<Array<EventChildrenCreateWithoutParentEventInput>>;
  delete?: Maybe<Array<EventChildrenWhereUniqueInput>>;
  deleteMany?: Maybe<Array<EventChildrenScalarWhereInput>>;
  disconnect?: Maybe<Array<EventChildrenWhereUniqueInput>>;
  set?: Maybe<Array<EventChildrenWhereUniqueInput>>;
  update?: Maybe<Array<EventChildrenUpdateWithWhereUniqueWithoutParentEventInput>>;
  updateMany?: Maybe<Array<EventChildrenUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<EventChildrenUpsertWithWhereUniqueWithoutParentEventInput>>;
};

export type EventChildrenUpdateManyWithWhereNestedInput = {
  data: EventChildrenUpdateManyDataInput;
  where: EventChildrenScalarWhereInput;
};

export type EventChildrenUpdateWithoutParentEventDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventChildrenUpdateWithWhereUniqueWithoutParentEventInput = {
  data: EventChildrenUpdateWithoutParentEventDataInput;
  where: EventChildrenWhereUniqueInput;
};

export type EventChildrenUpsertWithWhereUniqueWithoutParentEventInput = {
  create: EventChildrenCreateWithoutParentEventInput;
  update: EventChildrenUpdateWithoutParentEventDataInput;
  where: EventChildrenWhereUniqueInput;
};

export type EventChildrenWhereInput = {
  AND?: Maybe<Array<EventChildrenWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  description?: Maybe<NullableStringFilter>;
  endDate?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<EventChildrenWhereInput>>;
  OR?: Maybe<Array<EventChildrenWhereInput>>;
  parentEvent?: Maybe<EventWhereInput>;
  parentEventId?: Maybe<IntFilter>;
  startDate?: Maybe<DateTimeFilter>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type EventChildrenWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type EventCreateInput = {
  childEvents?: Maybe<EventChildrenCreateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator: UserCreateOneWithoutEventsInput;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonCreateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternCreateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserCreateManyWithoutEventInvitesInput>;
};

export type EventCreateManyWithoutCreatorInput = {
  connect?: Maybe<Array<EventWhereUniqueInput>>;
  create?: Maybe<Array<EventCreateWithoutCreatorInput>>;
};

export type EventCreateManyWithoutPersonInput = {
  connect?: Maybe<Array<EventWhereUniqueInput>>;
  create?: Maybe<Array<EventCreateWithoutPersonInput>>;
};

export type EventCreateManyWithoutUsersInput = {
  connect?: Maybe<Array<EventWhereUniqueInput>>;
  create?: Maybe<Array<EventCreateWithoutUsersInput>>;
};

export type EventCreateOneWithoutChildEventsInput = {
  connect?: Maybe<EventWhereUniqueInput>;
  create?: Maybe<EventCreateWithoutChildEventsInput>;
};

export type EventCreateOneWithoutRecurringPatternInput = {
  connect?: Maybe<EventWhereUniqueInput>;
  create?: Maybe<EventCreateWithoutRecurringPatternInput>;
};

export type EventCreateUserInput = {
  color?: Maybe<Scalars['String']>;
  daysOfMonth?: Maybe<Array<Scalars['Int']>>;
  daysOfWeek?: Maybe<Array<Scalars['Int']>>;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  inviteeIds: Array<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  recurringType?: Maybe<RecurringType>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title: Scalars['String'];
};

export type EventCreateWithoutChildEventsInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator: UserCreateOneWithoutEventsInput;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonCreateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternCreateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserCreateManyWithoutEventInvitesInput>;
};

export type EventCreateWithoutCreatorInput = {
  childEvents?: Maybe<EventChildrenCreateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonCreateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternCreateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserCreateManyWithoutEventInvitesInput>;
};

export type EventCreateWithoutPersonInput = {
  childEvents?: Maybe<EventChildrenCreateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator: UserCreateOneWithoutEventsInput;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  recurringPattern?: Maybe<EventRecurringPatternCreateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserCreateManyWithoutEventInvitesInput>;
};

export type EventCreateWithoutRecurringPatternInput = {
  childEvents?: Maybe<EventChildrenCreateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator: UserCreateOneWithoutEventsInput;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonCreateOneWithoutEventsInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserCreateManyWithoutEventInvitesInput>;
};

export type EventCreateWithoutUsersInput = {
  childEvents?: Maybe<EventChildrenCreateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator: UserCreateOneWithoutEventsInput;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonCreateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternCreateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventFilter = {
  every?: Maybe<EventWhereInput>;
  none?: Maybe<EventWhereInput>;
  some?: Maybe<EventWhereInput>;
};

export type EventOrderByInput = {
  color?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  creator?: Maybe<OrderByArg>;
  creatorId?: Maybe<OrderByArg>;
  description?: Maybe<OrderByArg>;
  endDate?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isFullDayEvent?: Maybe<OrderByArg>;
  isRecurring?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  person?: Maybe<OrderByArg>;
  personId?: Maybe<OrderByArg>;
  recurringPattern?: Maybe<OrderByArg>;
  recurringPatternId?: Maybe<OrderByArg>;
  shiftCoursesFlag?: Maybe<OrderByArg>;
  startDate?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type EventRecurringPattern = {
  __typename?: 'EventRecurringPattern';
  createdAt: Scalars['DateTime'];
  daysOfMonth: Array<Scalars['Int']>;
  daysOfWeek: Array<Scalars['Int']>;
  event?: Maybe<Event>;
  id: Scalars['Int'];
  monthsOfYear: Array<Scalars['Int']>;
  recurringType: RecurringType;
  separationCount: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  weeksOfMonth: Array<Scalars['Int']>;
};

export type EventRecurringPatternCreatedaysOfMonthInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternCreatedaysOfWeekInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternCreateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  daysOfMonth?: Maybe<EventRecurringPatternCreatedaysOfMonthInput>;
  daysOfWeek?: Maybe<EventRecurringPatternCreatedaysOfWeekInput>;
  event?: Maybe<EventCreateOneWithoutRecurringPatternInput>;
  monthsOfYear?: Maybe<EventRecurringPatternCreatemonthsOfYearInput>;
  recurringType: RecurringType;
  separationCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weeksOfMonth?: Maybe<EventRecurringPatternCreateweeksOfMonthInput>;
};

export type EventRecurringPatternCreatemonthsOfYearInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternCreateOneWithoutEventInput = {
  connect?: Maybe<EventRecurringPatternWhereUniqueInput>;
  create?: Maybe<EventRecurringPatternCreateWithoutEventInput>;
};

export type EventRecurringPatternCreateweeksOfMonthInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternCreateWithoutEventInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  daysOfMonth?: Maybe<EventRecurringPatternCreatedaysOfMonthInput>;
  daysOfWeek?: Maybe<EventRecurringPatternCreatedaysOfWeekInput>;
  monthsOfYear?: Maybe<EventRecurringPatternCreatemonthsOfYearInput>;
  recurringType: RecurringType;
  separationCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weeksOfMonth?: Maybe<EventRecurringPatternCreateweeksOfMonthInput>;
};

export type EventRecurringPatternOrderByInput = {
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  recurringType?: Maybe<OrderByArg>;
  separationCount?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type EventRecurringPatternUpdatedaysOfMonthInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternUpdatedaysOfWeekInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternUpdateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  daysOfMonth?: Maybe<EventRecurringPatternUpdatedaysOfMonthInput>;
  daysOfWeek?: Maybe<EventRecurringPatternUpdatedaysOfWeekInput>;
  event?: Maybe<EventUpdateOneWithoutRecurringPatternInput>;
  id?: Maybe<Scalars['Int']>;
  monthsOfYear?: Maybe<EventRecurringPatternUpdatemonthsOfYearInput>;
  recurringType?: Maybe<RecurringType>;
  separationCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weeksOfMonth?: Maybe<EventRecurringPatternUpdateweeksOfMonthInput>;
};

export type EventRecurringPatternUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  daysOfMonth?: Maybe<EventRecurringPatternUpdatedaysOfMonthInput>;
  daysOfWeek?: Maybe<EventRecurringPatternUpdatedaysOfWeekInput>;
  id?: Maybe<Scalars['Int']>;
  monthsOfYear?: Maybe<EventRecurringPatternUpdatemonthsOfYearInput>;
  recurringType?: Maybe<RecurringType>;
  separationCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weeksOfMonth?: Maybe<EventRecurringPatternUpdateweeksOfMonthInput>;
};

export type EventRecurringPatternUpdatemonthsOfYearInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternUpdateOneWithoutEventInput = {
  connect?: Maybe<EventRecurringPatternWhereUniqueInput>;
  create?: Maybe<EventRecurringPatternCreateWithoutEventInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<EventRecurringPatternUpdateWithoutEventDataInput>;
  upsert?: Maybe<EventRecurringPatternUpsertWithoutEventInput>;
};

export type EventRecurringPatternUpdateweeksOfMonthInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type EventRecurringPatternUpdateWithoutEventDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  daysOfMonth?: Maybe<EventRecurringPatternUpdatedaysOfMonthInput>;
  daysOfWeek?: Maybe<EventRecurringPatternUpdatedaysOfWeekInput>;
  id?: Maybe<Scalars['Int']>;
  monthsOfYear?: Maybe<EventRecurringPatternUpdatemonthsOfYearInput>;
  recurringType?: Maybe<RecurringType>;
  separationCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  weeksOfMonth?: Maybe<EventRecurringPatternUpdateweeksOfMonthInput>;
};

export type EventRecurringPatternUpsertWithoutEventInput = {
  create: EventRecurringPatternCreateWithoutEventInput;
  update: EventRecurringPatternUpdateWithoutEventDataInput;
};

export type EventRecurringPatternWhereInput = {
  AND?: Maybe<Array<EventRecurringPatternWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  event?: Maybe<EventWhereInput>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<EventRecurringPatternWhereInput>>;
  OR?: Maybe<Array<EventRecurringPatternWhereInput>>;
  recurringType?: Maybe<RecurringTypeFilter>;
  separationCount?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type EventRecurringPatternWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type EventScalarWhereInput = {
  AND?: Maybe<Array<EventScalarWhereInput>>;
  childEvents?: Maybe<EventChildrenFilter>;
  color?: Maybe<StringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  creatorId?: Maybe<IntFilter>;
  description?: Maybe<NullableStringFilter>;
  endDate?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isFullDayEvent?: Maybe<BooleanFilter>;
  isRecurring?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<EventScalarWhereInput>>;
  OR?: Maybe<Array<EventScalarWhereInput>>;
  order?: Maybe<IntFilter>;
  personId?: Maybe<NullableIntFilter>;
  recurringPatternId?: Maybe<NullableIntFilter>;
  shiftCoursesFlag?: Maybe<BooleanFilter>;
  startDate?: Maybe<DateTimeFilter>;
  title?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  users?: Maybe<UserFilter>;
};

export type EventUpdateInput = {
  childEvents?: Maybe<EventChildrenUpdateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsInput>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternUpdateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserUpdateManyWithoutEventInvitesInput>;
};

export type EventUpdateInput2 = {
  color?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['DateTime'];
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  startDate: Scalars['DateTime'];
  title: Scalars['String'];
};

export type EventUpdateManyDataInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventUpdateManyMutationInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventUpdateManyWithoutCreatorInput = {
  connect?: Maybe<Array<EventWhereUniqueInput>>;
  create?: Maybe<Array<EventCreateWithoutCreatorInput>>;
  delete?: Maybe<Array<EventWhereUniqueInput>>;
  deleteMany?: Maybe<Array<EventScalarWhereInput>>;
  disconnect?: Maybe<Array<EventWhereUniqueInput>>;
  set?: Maybe<Array<EventWhereUniqueInput>>;
  update?: Maybe<Array<EventUpdateWithWhereUniqueWithoutCreatorInput>>;
  updateMany?: Maybe<Array<EventUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<EventUpsertWithWhereUniqueWithoutCreatorInput>>;
};

export type EventUpdateManyWithoutPersonInput = {
  connect?: Maybe<Array<EventWhereUniqueInput>>;
  create?: Maybe<Array<EventCreateWithoutPersonInput>>;
  delete?: Maybe<Array<EventWhereUniqueInput>>;
  deleteMany?: Maybe<Array<EventScalarWhereInput>>;
  disconnect?: Maybe<Array<EventWhereUniqueInput>>;
  set?: Maybe<Array<EventWhereUniqueInput>>;
  update?: Maybe<Array<EventUpdateWithWhereUniqueWithoutPersonInput>>;
  updateMany?: Maybe<Array<EventUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<EventUpsertWithWhereUniqueWithoutPersonInput>>;
};

export type EventUpdateManyWithoutUsersInput = {
  connect?: Maybe<Array<EventWhereUniqueInput>>;
  create?: Maybe<Array<EventCreateWithoutUsersInput>>;
  delete?: Maybe<Array<EventWhereUniqueInput>>;
  deleteMany?: Maybe<Array<EventScalarWhereInput>>;
  disconnect?: Maybe<Array<EventWhereUniqueInput>>;
  set?: Maybe<Array<EventWhereUniqueInput>>;
  update?: Maybe<Array<EventUpdateWithWhereUniqueWithoutUsersInput>>;
  updateMany?: Maybe<Array<EventUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<EventUpsertWithWhereUniqueWithoutUsersInput>>;
};

export type EventUpdateManyWithWhereNestedInput = {
  data: EventUpdateManyDataInput;
  where: EventScalarWhereInput;
};

export type EventUpdateOneRequiredWithoutChildEventsInput = {
  connect?: Maybe<EventWhereUniqueInput>;
  create?: Maybe<EventCreateWithoutChildEventsInput>;
  update?: Maybe<EventUpdateWithoutChildEventsDataInput>;
  upsert?: Maybe<EventUpsertWithoutChildEventsInput>;
};

export type EventUpdateOneWithoutRecurringPatternInput = {
  connect?: Maybe<EventWhereUniqueInput>;
  create?: Maybe<EventCreateWithoutRecurringPatternInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<EventUpdateWithoutRecurringPatternDataInput>;
  upsert?: Maybe<EventUpsertWithoutRecurringPatternInput>;
};

export type EventUpdateWithoutChildEventsDataInput = {
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsInput>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternUpdateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserUpdateManyWithoutEventInvitesInput>;
};

export type EventUpdateWithoutCreatorDataInput = {
  childEvents?: Maybe<EventChildrenUpdateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternUpdateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserUpdateManyWithoutEventInvitesInput>;
};

export type EventUpdateWithoutPersonDataInput = {
  childEvents?: Maybe<EventChildrenUpdateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsInput>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  recurringPattern?: Maybe<EventRecurringPatternUpdateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserUpdateManyWithoutEventInvitesInput>;
};

export type EventUpdateWithoutRecurringPatternDataInput = {
  childEvents?: Maybe<EventChildrenUpdateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsInput>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneWithoutEventsInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  users?: Maybe<UserUpdateManyWithoutEventInvitesInput>;
};

export type EventUpdateWithoutUsersDataInput = {
  childEvents?: Maybe<EventChildrenUpdateManyWithoutParentEventInput>;
  color?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  creator?: Maybe<UserUpdateOneRequiredWithoutEventsInput>;
  description?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  isFullDayEvent?: Maybe<Scalars['Boolean']>;
  isRecurring?: Maybe<Scalars['Boolean']>;
  order?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneWithoutEventsInput>;
  recurringPattern?: Maybe<EventRecurringPatternUpdateOneWithoutEventInput>;
  shiftCoursesFlag?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type EventUpdateWithWhereUniqueWithoutCreatorInput = {
  data: EventUpdateWithoutCreatorDataInput;
  where: EventWhereUniqueInput;
};

export type EventUpdateWithWhereUniqueWithoutPersonInput = {
  data: EventUpdateWithoutPersonDataInput;
  where: EventWhereUniqueInput;
};

export type EventUpdateWithWhereUniqueWithoutUsersInput = {
  data: EventUpdateWithoutUsersDataInput;
  where: EventWhereUniqueInput;
};

export type EventUpsertWithoutChildEventsInput = {
  create: EventCreateWithoutChildEventsInput;
  update: EventUpdateWithoutChildEventsDataInput;
};

export type EventUpsertWithoutRecurringPatternInput = {
  create: EventCreateWithoutRecurringPatternInput;
  update: EventUpdateWithoutRecurringPatternDataInput;
};

export type EventUpsertWithWhereUniqueWithoutCreatorInput = {
  create: EventCreateWithoutCreatorInput;
  update: EventUpdateWithoutCreatorDataInput;
  where: EventWhereUniqueInput;
};

export type EventUpsertWithWhereUniqueWithoutPersonInput = {
  create: EventCreateWithoutPersonInput;
  update: EventUpdateWithoutPersonDataInput;
  where: EventWhereUniqueInput;
};

export type EventUpsertWithWhereUniqueWithoutUsersInput = {
  create: EventCreateWithoutUsersInput;
  update: EventUpdateWithoutUsersDataInput;
  where: EventWhereUniqueInput;
};

export type EventWhereInput = {
  AND?: Maybe<Array<EventWhereInput>>;
  childEvents?: Maybe<EventChildrenFilter>;
  color?: Maybe<StringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  creator?: Maybe<UserWhereInput>;
  creatorId?: Maybe<IntFilter>;
  description?: Maybe<NullableStringFilter>;
  endDate?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  isFullDayEvent?: Maybe<BooleanFilter>;
  isRecurring?: Maybe<BooleanFilter>;
  NOT?: Maybe<Array<EventWhereInput>>;
  OR?: Maybe<Array<EventWhereInput>>;
  order?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<NullableIntFilter>;
  recurringPattern?: Maybe<EventRecurringPatternWhereInput>;
  recurringPatternId?: Maybe<NullableIntFilter>;
  shiftCoursesFlag?: Maybe<BooleanFilter>;
  startDate?: Maybe<DateTimeFilter>;
  title?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  users?: Maybe<UserFilter>;
};

export type EventWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type Faq = {
  __typename?: 'Faq';
  body?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  faqTags: Array<FaqTag>;
  featured?: Maybe<Scalars['Boolean']>;
  id: Scalars['Int'];
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  type: FaqType;
  updatedAt: Scalars['DateTime'];
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqFaqTagsArgs = {
  after?: Maybe<FaqTagWhereUniqueInput>;
  before?: Maybe<FaqTagWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqTagOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqTagWhereInput>;
};

export type FaqCreateInput = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faqTags?: Maybe<FaqTagCreateManyWithoutFaqsInput>;
  featured?: Maybe<Scalars['Boolean']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  type: FaqType;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqCreateManyWithoutFaqTagsInput = {
  connect?: Maybe<Array<FaqWhereUniqueInput>>;
  create?: Maybe<Array<FaqCreateWithoutFaqTagsInput>>;
};

export type FaqCreateWithoutFaqTagsInput = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  featured?: Maybe<Scalars['Boolean']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  type: FaqType;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqFilter = {
  every?: Maybe<FaqWhereInput>;
  none?: Maybe<FaqWhereInput>;
  some?: Maybe<FaqWhereInput>;
};

export type FaqOrderByInput = {
  body?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  featured?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  link?: Maybe<OrderByArg>;
  order?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  type?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  viewCount?: Maybe<OrderByArg>;
};

export type FaqScalarWhereInput = {
  AND?: Maybe<Array<FaqScalarWhereInput>>;
  body?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  faqTags?: Maybe<FaqTagFilter>;
  featured?: Maybe<NullableBooleanFilter>;
  id?: Maybe<IntFilter>;
  link?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<FaqScalarWhereInput>>;
  OR?: Maybe<Array<FaqScalarWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  title?: Maybe<NullableStringFilter>;
  type?: Maybe<FaqTypeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  viewCount?: Maybe<NullableIntFilter>;
};

export type FaqTag = {
  __typename?: 'FaqTag';
  createdAt: Scalars['DateTime'];
  faqs: Array<Faq>;
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqTagFaqsArgs = {
  after?: Maybe<FaqWhereUniqueInput>;
  before?: Maybe<FaqWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqWhereInput>;
};

export type FaqTagCreateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  faqs?: Maybe<FaqCreateManyWithoutFaqTagsInput>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqTagCreateManyWithoutFaqsInput = {
  connect?: Maybe<Array<FaqTagWhereUniqueInput>>;
  create?: Maybe<Array<FaqTagCreateWithoutFaqsInput>>;
};

export type FaqTagCreateWithoutFaqsInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqTagFilter = {
  every?: Maybe<FaqTagWhereInput>;
  none?: Maybe<FaqTagWhereInput>;
  some?: Maybe<FaqTagWhereInput>;
};

export type FaqTagOrderByInput = {
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  name?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  viewCount?: Maybe<OrderByArg>;
};

export type FaqTagScalarWhereInput = {
  AND?: Maybe<Array<FaqTagScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  faqs?: Maybe<FaqFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<FaqTagScalarWhereInput>>;
  OR?: Maybe<Array<FaqTagScalarWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
  viewCount?: Maybe<NullableIntFilter>;
};

export type FaqTagUpdateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  faqs?: Maybe<FaqUpdateManyWithoutFaqTagsInput>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqTagUpdateManyDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqTagUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqTagUpdateManyWithoutFaqsInput = {
  connect?: Maybe<Array<FaqTagWhereUniqueInput>>;
  create?: Maybe<Array<FaqTagCreateWithoutFaqsInput>>;
  delete?: Maybe<Array<FaqTagWhereUniqueInput>>;
  deleteMany?: Maybe<Array<FaqTagScalarWhereInput>>;
  disconnect?: Maybe<Array<FaqTagWhereUniqueInput>>;
  set?: Maybe<Array<FaqTagWhereUniqueInput>>;
  update?: Maybe<Array<FaqTagUpdateWithWhereUniqueWithoutFaqsInput>>;
  updateMany?: Maybe<Array<FaqTagUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<FaqTagUpsertWithWhereUniqueWithoutFaqsInput>>;
};

export type FaqTagUpdateManyWithWhereNestedInput = {
  data: FaqTagUpdateManyDataInput;
  where: FaqTagScalarWhereInput;
};

export type FaqTagUpdateWithoutFaqsDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqTagUpdateWithWhereUniqueWithoutFaqsInput = {
  data: FaqTagUpdateWithoutFaqsDataInput;
  where: FaqTagWhereUniqueInput;
};

export type FaqTagUpsertWithWhereUniqueWithoutFaqsInput = {
  create: FaqTagCreateWithoutFaqsInput;
  update: FaqTagUpdateWithoutFaqsDataInput;
  where: FaqTagWhereUniqueInput;
};

export type FaqTagWhereInput = {
  AND?: Maybe<Array<FaqTagWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  faqs?: Maybe<FaqFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<FaqTagWhereInput>>;
  OR?: Maybe<Array<FaqTagWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
  viewCount?: Maybe<NullableIntFilter>;
};

export type FaqTagWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

export enum FaqType {
  Kba = 'KBA',
  Vid = 'VID',
}

export type FaqTypeFilter = {
  equals?: Maybe<FaqType>;
  in?: Maybe<Array<FaqType>>;
  not?: Maybe<FaqType>;
  notIn?: Maybe<Array<FaqType>>;
};

export type FaqUpdateInput = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faqTags?: Maybe<FaqTagUpdateManyWithoutFaqsInput>;
  featured?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<FaqType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqUpdateManyDataInput = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  featured?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<FaqType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqUpdateManyMutationInput = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  featured?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<FaqType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqUpdateManyWithoutFaqTagsInput = {
  connect?: Maybe<Array<FaqWhereUniqueInput>>;
  create?: Maybe<Array<FaqCreateWithoutFaqTagsInput>>;
  delete?: Maybe<Array<FaqWhereUniqueInput>>;
  deleteMany?: Maybe<Array<FaqScalarWhereInput>>;
  disconnect?: Maybe<Array<FaqWhereUniqueInput>>;
  set?: Maybe<Array<FaqWhereUniqueInput>>;
  update?: Maybe<Array<FaqUpdateWithWhereUniqueWithoutFaqTagsInput>>;
  updateMany?: Maybe<Array<FaqUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<FaqUpsertWithWhereUniqueWithoutFaqTagsInput>>;
};

export type FaqUpdateManyWithWhereNestedInput = {
  data: FaqUpdateManyDataInput;
  where: FaqScalarWhereInput;
};

export type FaqUpdateWithoutFaqTagsDataInput = {
  body?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  featured?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  link?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<FaqType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  viewCount?: Maybe<Scalars['Int']>;
};

export type FaqUpdateWithWhereUniqueWithoutFaqTagsInput = {
  data: FaqUpdateWithoutFaqTagsDataInput;
  where: FaqWhereUniqueInput;
};

export type FaqUpsertWithWhereUniqueWithoutFaqTagsInput = {
  create: FaqCreateWithoutFaqTagsInput;
  update: FaqUpdateWithoutFaqTagsDataInput;
  where: FaqWhereUniqueInput;
};

export type FaqWhereInput = {
  AND?: Maybe<Array<FaqWhereInput>>;
  body?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  faqTags?: Maybe<FaqTagFilter>;
  featured?: Maybe<NullableBooleanFilter>;
  id?: Maybe<IntFilter>;
  link?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<FaqWhereInput>>;
  OR?: Maybe<Array<FaqWhereInput>>;
  order?: Maybe<NullableIntFilter>;
  title?: Maybe<NullableStringFilter>;
  type?: Maybe<FaqTypeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  viewCount?: Maybe<NullableIntFilter>;
};

export type FaqWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type Field = {
  __typename?: 'Field';
  create: Scalars['Boolean'];
  filter: Scalars['Boolean'];
  id: Scalars['String'];
  kind: KindEnum;
  list: Scalars['Boolean'];
  name: Scalars['String'];
  order: Scalars['Int'];
  read: Scalars['Boolean'];
  required: Scalars['Boolean'];
  sort: Scalars['Boolean'];
  title: Scalars['String'];
  type: Scalars['String'];
  update: Scalars['Boolean'];
};

export type FileUploadResp = {
  __typename?: 'FileUploadResp';
  fileLink?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
};

export type FloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  not?: Maybe<Scalars['Float']>;
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export type Grade = {
  __typename?: 'Grade';
  avg?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  letter?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
};

export type GradeAssessmentTakingQuestionInput = {
  assessmentTakingQuestionId: Scalars['Int'];
  parentComment?: Maybe<Scalars['String']>;
  scoreOverride?: Maybe<Scalars['Float']>;
};

export type GradeAssignmentInput = {
  assessmentTakingQuestionGrades: Array<GradeAssessmentTakingQuestionInput>;
  assignmentTakingId: Scalars['Int'];
};

export type GradeCreateInput = {
  avg?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  letter?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GradeData = {
  __typename?: 'gradeData';
  pv: Scalars['Int'];
  week: Scalars['Int'];
};

export type GradeOrderByInput = {
  avg?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  letter?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type GradesByType = {
  __typename?: 'GradesByType';
  data: Array<GradeData>;
  displayGrade: Scalars['String'];
  maxPoints: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  perc: Scalars['Int'];
  totalPoints: Scalars['Int'];
  weight?: Maybe<Scalars['Int']>;
};

export type GradeUpdateInput = {
  avg?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  letter?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GradeUpdateManyMutationInput = {
  avg?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  letter?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GradeWeight = {
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Float']>;
};

export type GradeWhereInput = {
  AND?: Maybe<Array<GradeWhereInput>>;
  avg?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  letter?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<GradeWhereInput>>;
  OR?: Maybe<Array<GradeWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GradeWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type HubAccount = {
  __typename?: 'HubAccount';
  accountStatus?: Maybe<Status>;
  acctNum?: Maybe<Scalars['Int']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  lastName?: Maybe<Scalars['String']>;
  originHub: Scalars['Boolean'];
  state?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  zip?: Maybe<Scalars['String']>;
};

export type HubAccountCreateInput = {
  accountStatus?: Maybe<Status>;
  acctNum?: Maybe<Scalars['Int']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  originHub?: Maybe<Scalars['Boolean']>;
  state?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type HubAccountOrderByInput = {
  accountStatus?: Maybe<OrderByArg>;
  acctNum?: Maybe<OrderByArg>;
  address1?: Maybe<OrderByArg>;
  address2?: Maybe<OrderByArg>;
  city?: Maybe<OrderByArg>;
  country?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  email?: Maybe<OrderByArg>;
  firstName?: Maybe<OrderByArg>;
  gender?: Maybe<OrderByArg>;
  hubUserXid?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  lastName?: Maybe<OrderByArg>;
  originHub?: Maybe<OrderByArg>;
  state?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  zip?: Maybe<OrderByArg>;
};

export type HubAccountUpdateInput = {
  accountStatus?: Maybe<Status>;
  acctNum?: Maybe<Scalars['Int']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  originHub?: Maybe<Scalars['Boolean']>;
  state?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type HubAccountUpdateManyMutationInput = {
  accountStatus?: Maybe<Status>;
  acctNum?: Maybe<Scalars['Int']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  hubUserXid?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  originHub?: Maybe<Scalars['Boolean']>;
  state?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type HubAccountWhereInput = {
  accountStatus?: Maybe<NullableStatusFilter>;
  acctNum?: Maybe<NullableIntFilter>;
  address1?: Maybe<NullableStringFilter>;
  address2?: Maybe<NullableStringFilter>;
  AND?: Maybe<Array<HubAccountWhereInput>>;
  city?: Maybe<NullableStringFilter>;
  country?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  email?: Maybe<NullableStringFilter>;
  firstName?: Maybe<NullableStringFilter>;
  gender?: Maybe<NullableStringFilter>;
  hubUserXid?: Maybe<NullableIntFilter>;
  id?: Maybe<IntFilter>;
  lastName?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<HubAccountWhereInput>>;
  OR?: Maybe<Array<HubAccountWhereInput>>;
  originHub?: Maybe<BooleanFilter>;
  state?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  zip?: Maybe<NullableStringFilter>;
};

export type HubAccountWhereUniqueInput = {
  hubUserXid?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
};

export type HubEntitlement = {
  __typename?: 'HubEntitlement';
  assignedUserFullName?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  entitlementUnitId: Scalars['Int'];
  id: Scalars['Int'];
  pressAcctNum: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
};

export type HubEntitlementCreateInput = {
  assignedUserFullName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  entitlementUnitId?: Maybe<Scalars['Int']>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type HubEntitlementOrderByInput = {
  assignedUserFullName?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  entitlementUnitId?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  pressAcctNum?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type HubEntitlementUpdateInput = {
  assignedUserFullName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  entitlementUnitId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type HubEntitlementUpdateManyMutationInput = {
  assignedUserFullName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  entitlementUnitId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type HubEntitlementWhereInput = {
  AND?: Maybe<Array<HubEntitlementWhereInput>>;
  assignedUserFullName?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  entitlementUnitId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<HubEntitlementWhereInput>>;
  OR?: Maybe<Array<HubEntitlementWhereInput>>;
  pressAcctNum?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type HubEntitlementWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type IntFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<Scalars['Int']>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type JustId = {
  __typename?: 'JustId';
  id: Scalars['Int'];
};

export enum KindEnum {
  Enum = 'enum',
  Object = 'object',
  Scalar = 'scalar',
}

export type LessonContent = {
  __typename?: 'LessonContent';
  assignmentContents: Array<AssignmentContent>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContent>;
  courseContentId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  day: Scalars['Int'];
  id: Scalars['Int'];
  isActive: Scalars['Boolean'];
  lessonContentResources: Array<LessonContentResource>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings: Array<LessonTaking>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentAssignmentContentsArgs = {
  after?: Maybe<AssignmentContentWhereUniqueInput>;
  before?: Maybe<AssignmentContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentContentWhereInput>;
};

export type LessonContentLessonContentResourcesArgs = {
  after?: Maybe<LessonContentResourceWhereUniqueInput>;
  before?: Maybe<LessonContentResourceWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonContentResourceOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonContentResourceWhereInput>;
};

export type LessonContentLessonTakingsArgs = {
  after?: Maybe<LessonTakingWhereUniqueInput>;
  before?: Maybe<LessonTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonTakingWhereInput>;
};

export type LessonContentCreateInput = {
  assignmentContents?: Maybe<AssignmentContentCreateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceCreateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentCreateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<LessonContentWhereUniqueInput>>;
  create?: Maybe<Array<LessonContentCreateWithoutCourseContentInput>>;
};

export type LessonContentCreateOneWithoutAssignmentContentsInput = {
  connect?: Maybe<LessonContentWhereUniqueInput>;
  create?: Maybe<LessonContentCreateWithoutAssignmentContentsInput>;
};

export type LessonContentCreateOneWithoutLessonContentResourcesInput = {
  connect?: Maybe<LessonContentWhereUniqueInput>;
  create?: Maybe<LessonContentCreateWithoutLessonContentResourcesInput>;
};

export type LessonContentCreateOneWithoutLessonTakingsInput = {
  connect?: Maybe<LessonContentWhereUniqueInput>;
  create?: Maybe<LessonContentCreateWithoutLessonTakingsInput>;
};

export type LessonContentCreateWithoutAssignmentContentsInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceCreateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentCreateWithoutCourseContentInput = {
  assignmentContents?: Maybe<AssignmentContentCreateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceCreateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentCreateWithoutLessonContentResourcesInput = {
  assignmentContents?: Maybe<AssignmentContentCreateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingCreateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentCreateWithoutLessonTakingsInput = {
  assignmentContents?: Maybe<AssignmentContentCreateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentCreateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceCreateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentFilter = {
  every?: Maybe<LessonContentWhereInput>;
  none?: Maybe<LessonContentWhereInput>;
  some?: Maybe<LessonContentWhereInput>;
};

export type LessonContentOrderByInput = {
  courseCodeXId?: Maybe<OrderByArg>;
  courseContent?: Maybe<OrderByArg>;
  courseContentId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  day?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isActive?: Maybe<OrderByArg>;
  lessonDetails?: Maybe<OrderByArg>;
  materials?: Maybe<OrderByArg>;
  objectives?: Maybe<OrderByArg>;
  parentDetails?: Maybe<OrderByArg>;
  parentInstructions?: Maybe<OrderByArg>;
  studentInstructions?: Maybe<OrderByArg>;
  title?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  videoCode?: Maybe<OrderByArg>;
};

export type LessonContentResource = {
  __typename?: 'LessonContentResource';
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  lessonContent?: Maybe<LessonContent>;
  lessonContentId?: Maybe<Scalars['Int']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  resourceType: LessonContentResourceType;
  sourceLink: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type LessonContentResourceCreateInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  lessonContent?: Maybe<LessonContentCreateOneWithoutLessonContentResourcesInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  resourceType: LessonContentResourceType;
  sourceLink?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonContentResourceCreateManyWithoutLessonContentInput = {
  connect?: Maybe<Array<LessonContentResourceWhereUniqueInput>>;
  create?: Maybe<Array<LessonContentResourceCreateWithoutLessonContentInput>>;
};

export type LessonContentResourceCreateWithoutLessonContentInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  resourceType: LessonContentResourceType;
  sourceLink?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonContentResourceFilter = {
  every?: Maybe<LessonContentResourceWhereInput>;
  none?: Maybe<LessonContentResourceWhereInput>;
  some?: Maybe<LessonContentResourceWhereInput>;
};

export type LessonContentResourceOrderByInput = {
  courseCodeXId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  lessonContent?: Maybe<OrderByArg>;
  lessonContentId?: Maybe<OrderByArg>;
  lessonDayXId?: Maybe<OrderByArg>;
  resourceType?: Maybe<OrderByArg>;
  sourceLink?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type LessonContentResourceScalarWhereInput = {
  AND?: Maybe<Array<LessonContentResourceScalarWhereInput>>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  lessonContentId?: Maybe<NullableIntFilter>;
  lessonDayXId?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<LessonContentResourceScalarWhereInput>>;
  OR?: Maybe<Array<LessonContentResourceScalarWhereInput>>;
  resourceType?: Maybe<LessonContentResourceTypeFilter>;
  sourceLink?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export enum LessonContentResourceType {
  Pnt = 'PNT',
  Std = 'STD',
  Vid = 'VID',
}

export type LessonContentResourceTypeFilter = {
  equals?: Maybe<LessonContentResourceType>;
  in?: Maybe<Array<LessonContentResourceType>>;
  not?: Maybe<LessonContentResourceType>;
  notIn?: Maybe<Array<LessonContentResourceType>>;
};

export type LessonContentResourceUpdateInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonContent?: Maybe<LessonContentUpdateOneWithoutLessonContentResourcesInput>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  resourceType?: Maybe<LessonContentResourceType>;
  sourceLink?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonContentResourceUpdateManyDataInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  resourceType?: Maybe<LessonContentResourceType>;
  sourceLink?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonContentResourceUpdateManyMutationInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  resourceType?: Maybe<LessonContentResourceType>;
  sourceLink?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonContentResourceUpdateManyWithoutLessonContentInput = {
  connect?: Maybe<Array<LessonContentResourceWhereUniqueInput>>;
  create?: Maybe<Array<LessonContentResourceCreateWithoutLessonContentInput>>;
  delete?: Maybe<Array<LessonContentResourceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<LessonContentResourceScalarWhereInput>>;
  disconnect?: Maybe<Array<LessonContentResourceWhereUniqueInput>>;
  set?: Maybe<Array<LessonContentResourceWhereUniqueInput>>;
  update?: Maybe<Array<LessonContentResourceUpdateWithWhereUniqueWithoutLessonContentInput>>;
  updateMany?: Maybe<Array<LessonContentResourceUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<LessonContentResourceUpsertWithWhereUniqueWithoutLessonContentInput>>;
};

export type LessonContentResourceUpdateManyWithWhereNestedInput = {
  data: LessonContentResourceUpdateManyDataInput;
  where: LessonContentResourceScalarWhereInput;
};

export type LessonContentResourceUpdateWithoutLessonContentDataInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonDayXId?: Maybe<Scalars['Int']>;
  resourceType?: Maybe<LessonContentResourceType>;
  sourceLink?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonContentResourceUpdateWithWhereUniqueWithoutLessonContentInput = {
  data: LessonContentResourceUpdateWithoutLessonContentDataInput;
  where: LessonContentResourceWhereUniqueInput;
};

export type LessonContentResourceUpsertWithWhereUniqueWithoutLessonContentInput = {
  create: LessonContentResourceCreateWithoutLessonContentInput;
  update: LessonContentResourceUpdateWithoutLessonContentDataInput;
  where: LessonContentResourceWhereUniqueInput;
};

export type LessonContentResourceWhereInput = {
  AND?: Maybe<Array<LessonContentResourceWhereInput>>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  lessonContent?: Maybe<LessonContentWhereInput>;
  lessonContentId?: Maybe<NullableIntFilter>;
  lessonDayXId?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<LessonContentResourceWhereInput>>;
  OR?: Maybe<Array<LessonContentResourceWhereInput>>;
  resourceType?: Maybe<LessonContentResourceTypeFilter>;
  sourceLink?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type LessonContentResourceWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type LessonContentScalarWhereInput = {
  AND?: Maybe<Array<LessonContentScalarWhereInput>>;
  assignmentContents?: Maybe<AssignmentContentFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  courseContentId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  day?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  isActive?: Maybe<BooleanFilter>;
  lessonContentResources?: Maybe<LessonContentResourceFilter>;
  lessonDetails?: Maybe<NullableStringFilter>;
  lessonTakings?: Maybe<LessonTakingFilter>;
  materials?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<LessonContentScalarWhereInput>>;
  objectives?: Maybe<NullableStringFilter>;
  OR?: Maybe<Array<LessonContentScalarWhereInput>>;
  parentDetails?: Maybe<NullableStringFilter>;
  parentInstructions?: Maybe<NullableStringFilter>;
  studentInstructions?: Maybe<NullableStringFilter>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  videoCode?: Maybe<NullableStringFilter>;
};

export type LessonContentUpdateInput = {
  assignmentContents?: Maybe<AssignmentContentUpdateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceUpdateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentUpdateManyDataInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonDetails?: Maybe<Scalars['String']>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentUpdateManyMutationInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonDetails?: Maybe<Scalars['String']>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentUpdateManyWithoutCourseContentInput = {
  connect?: Maybe<Array<LessonContentWhereUniqueInput>>;
  create?: Maybe<Array<LessonContentCreateWithoutCourseContentInput>>;
  delete?: Maybe<Array<LessonContentWhereUniqueInput>>;
  deleteMany?: Maybe<Array<LessonContentScalarWhereInput>>;
  disconnect?: Maybe<Array<LessonContentWhereUniqueInput>>;
  set?: Maybe<Array<LessonContentWhereUniqueInput>>;
  update?: Maybe<Array<LessonContentUpdateWithWhereUniqueWithoutCourseContentInput>>;
  updateMany?: Maybe<Array<LessonContentUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<LessonContentUpsertWithWhereUniqueWithoutCourseContentInput>>;
};

export type LessonContentUpdateManyWithWhereNestedInput = {
  data: LessonContentUpdateManyDataInput;
  where: LessonContentScalarWhereInput;
};

export type LessonContentUpdateOneRequiredWithoutLessonTakingsInput = {
  connect?: Maybe<LessonContentWhereUniqueInput>;
  create?: Maybe<LessonContentCreateWithoutLessonTakingsInput>;
  update?: Maybe<LessonContentUpdateWithoutLessonTakingsDataInput>;
  upsert?: Maybe<LessonContentUpsertWithoutLessonTakingsInput>;
};

export type LessonContentUpdateOneWithoutAssignmentContentsInput = {
  connect?: Maybe<LessonContentWhereUniqueInput>;
  create?: Maybe<LessonContentCreateWithoutAssignmentContentsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<LessonContentUpdateWithoutAssignmentContentsDataInput>;
  upsert?: Maybe<LessonContentUpsertWithoutAssignmentContentsInput>;
};

export type LessonContentUpdateOneWithoutLessonContentResourcesInput = {
  connect?: Maybe<LessonContentWhereUniqueInput>;
  create?: Maybe<LessonContentCreateWithoutLessonContentResourcesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<LessonContentUpdateWithoutLessonContentResourcesDataInput>;
  upsert?: Maybe<LessonContentUpsertWithoutLessonContentResourcesInput>;
};

export type LessonContentUpdateWithoutAssignmentContentsDataInput = {
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceUpdateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentUpdateWithoutCourseContentDataInput = {
  assignmentContents?: Maybe<AssignmentContentUpdateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceUpdateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentUpdateWithoutLessonContentResourcesDataInput = {
  assignmentContents?: Maybe<AssignmentContentUpdateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonDetails?: Maybe<Scalars['String']>;
  lessonTakings?: Maybe<LessonTakingUpdateManyWithoutLessonContentInput>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentUpdateWithoutLessonTakingsDataInput = {
  assignmentContents?: Maybe<AssignmentContentUpdateManyWithoutLessonContentInput>;
  courseCodeXId?: Maybe<Scalars['String']>;
  courseContent?: Maybe<CourseContentUpdateOneWithoutLessonContentsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  isActive?: Maybe<Scalars['Boolean']>;
  lessonContentResources?: Maybe<LessonContentResourceUpdateManyWithoutLessonContentInput>;
  lessonDetails?: Maybe<Scalars['String']>;
  materials?: Maybe<Scalars['String']>;
  objectives?: Maybe<Scalars['String']>;
  parentDetails?: Maybe<Scalars['String']>;
  parentInstructions?: Maybe<Scalars['String']>;
  studentInstructions?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  videoCode?: Maybe<Scalars['String']>;
};

export type LessonContentUpdateWithWhereUniqueWithoutCourseContentInput = {
  data: LessonContentUpdateWithoutCourseContentDataInput;
  where: LessonContentWhereUniqueInput;
};

export type LessonContentUpsertWithoutAssignmentContentsInput = {
  create: LessonContentCreateWithoutAssignmentContentsInput;
  update: LessonContentUpdateWithoutAssignmentContentsDataInput;
};

export type LessonContentUpsertWithoutLessonContentResourcesInput = {
  create: LessonContentCreateWithoutLessonContentResourcesInput;
  update: LessonContentUpdateWithoutLessonContentResourcesDataInput;
};

export type LessonContentUpsertWithoutLessonTakingsInput = {
  create: LessonContentCreateWithoutLessonTakingsInput;
  update: LessonContentUpdateWithoutLessonTakingsDataInput;
};

export type LessonContentUpsertWithWhereUniqueWithoutCourseContentInput = {
  create: LessonContentCreateWithoutCourseContentInput;
  update: LessonContentUpdateWithoutCourseContentDataInput;
  where: LessonContentWhereUniqueInput;
};

export type LessonContentWhereInput = {
  AND?: Maybe<Array<LessonContentWhereInput>>;
  assignmentContents?: Maybe<AssignmentContentFilter>;
  courseCodeXId?: Maybe<NullableStringFilter>;
  courseContent?: Maybe<CourseContentWhereInput>;
  courseContentId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  day?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  isActive?: Maybe<BooleanFilter>;
  lessonContentResources?: Maybe<LessonContentResourceFilter>;
  lessonDetails?: Maybe<NullableStringFilter>;
  lessonTakings?: Maybe<LessonTakingFilter>;
  materials?: Maybe<NullableStringFilter>;
  NOT?: Maybe<Array<LessonContentWhereInput>>;
  objectives?: Maybe<NullableStringFilter>;
  OR?: Maybe<Array<LessonContentWhereInput>>;
  parentDetails?: Maybe<NullableStringFilter>;
  parentInstructions?: Maybe<NullableStringFilter>;
  studentInstructions?: Maybe<NullableStringFilter>;
  title?: Maybe<NullableStringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  videoCode?: Maybe<NullableStringFilter>;
};

export type LessonContentWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type LessonTaking = {
  __typename?: 'LessonTaking';
  assignedDate?: Maybe<Scalars['DateTime']>;
  assignmentTakings: Array<AssignmentTaking>;
  courseTaking?: Maybe<CourseTaking>;
  courseTakingId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['DateTime'];
  day: Scalars['Int'];
  id: Scalars['Int'];
  lessonContent: LessonContent;
  lessonContentId: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
};

export type LessonTakingAssignmentTakingsArgs = {
  after?: Maybe<AssignmentTakingWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type LessonTakingCreateInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  assignmentTakings?: Maybe<AssignmentTakingCreateManyWithoutLessonTakingInput>;
  courseTaking?: Maybe<CourseTakingCreateOneWithoutLessonTakingsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day: Scalars['Int'];
  lessonContent: LessonContentCreateOneWithoutLessonTakingsInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingCreateManyWithoutCourseTakingInput = {
  connect?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  create?: Maybe<Array<LessonTakingCreateWithoutCourseTakingInput>>;
};

export type LessonTakingCreateManyWithoutLessonContentInput = {
  connect?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  create?: Maybe<Array<LessonTakingCreateWithoutLessonContentInput>>;
};

export type LessonTakingCreateOneWithoutAssignmentTakingsInput = {
  connect?: Maybe<LessonTakingWhereUniqueInput>;
  create?: Maybe<LessonTakingCreateWithoutAssignmentTakingsInput>;
};

export type LessonTakingCreateWithoutAssignmentTakingsInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  courseTaking?: Maybe<CourseTakingCreateOneWithoutLessonTakingsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day: Scalars['Int'];
  lessonContent: LessonContentCreateOneWithoutLessonTakingsInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingCreateWithoutCourseTakingInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  assignmentTakings?: Maybe<AssignmentTakingCreateManyWithoutLessonTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day: Scalars['Int'];
  lessonContent: LessonContentCreateOneWithoutLessonTakingsInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingCreateWithoutLessonContentInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  assignmentTakings?: Maybe<AssignmentTakingCreateManyWithoutLessonTakingInput>;
  courseTaking?: Maybe<CourseTakingCreateOneWithoutLessonTakingsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingFilter = {
  every?: Maybe<LessonTakingWhereInput>;
  none?: Maybe<LessonTakingWhereInput>;
  some?: Maybe<LessonTakingWhereInput>;
};

export type LessonTakingOrderByInput = {
  assignedDate?: Maybe<OrderByArg>;
  courseTaking?: Maybe<OrderByArg>;
  courseTakingId?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  day?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  lessonContent?: Maybe<OrderByArg>;
  lessonContentId?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type LessonTakingScalarWhereInput = {
  AND?: Maybe<Array<LessonTakingScalarWhereInput>>;
  assignedDate?: Maybe<NullableDateTimeFilter>;
  assignmentTakings?: Maybe<AssignmentTakingFilter>;
  courseTakingId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  day?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  lessonContentId?: Maybe<IntFilter>;
  NOT?: Maybe<Array<LessonTakingScalarWhereInput>>;
  OR?: Maybe<Array<LessonTakingScalarWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type LessonTakingUpdateInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  assignmentTakings?: Maybe<AssignmentTakingUpdateManyWithoutLessonTakingInput>;
  courseTaking?: Maybe<CourseTakingUpdateOneWithoutLessonTakingsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lessonContent?: Maybe<LessonContentUpdateOneRequiredWithoutLessonTakingsInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingUpdateManyDataInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingUpdateManyMutationInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingUpdateManyWithoutCourseTakingInput = {
  connect?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  create?: Maybe<Array<LessonTakingCreateWithoutCourseTakingInput>>;
  delete?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<LessonTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  set?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  update?: Maybe<Array<LessonTakingUpdateWithWhereUniqueWithoutCourseTakingInput>>;
  updateMany?: Maybe<Array<LessonTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<LessonTakingUpsertWithWhereUniqueWithoutCourseTakingInput>>;
};

export type LessonTakingUpdateManyWithoutLessonContentInput = {
  connect?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  create?: Maybe<Array<LessonTakingCreateWithoutLessonContentInput>>;
  delete?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  deleteMany?: Maybe<Array<LessonTakingScalarWhereInput>>;
  disconnect?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  set?: Maybe<Array<LessonTakingWhereUniqueInput>>;
  update?: Maybe<Array<LessonTakingUpdateWithWhereUniqueWithoutLessonContentInput>>;
  updateMany?: Maybe<Array<LessonTakingUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<LessonTakingUpsertWithWhereUniqueWithoutLessonContentInput>>;
};

export type LessonTakingUpdateManyWithWhereNestedInput = {
  data: LessonTakingUpdateManyDataInput;
  where: LessonTakingScalarWhereInput;
};

export type LessonTakingUpdateOneWithoutAssignmentTakingsInput = {
  connect?: Maybe<LessonTakingWhereUniqueInput>;
  create?: Maybe<LessonTakingCreateWithoutAssignmentTakingsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<LessonTakingUpdateWithoutAssignmentTakingsDataInput>;
  upsert?: Maybe<LessonTakingUpsertWithoutAssignmentTakingsInput>;
};

export type LessonTakingUpdateWithoutAssignmentTakingsDataInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  courseTaking?: Maybe<CourseTakingUpdateOneWithoutLessonTakingsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lessonContent?: Maybe<LessonContentUpdateOneRequiredWithoutLessonTakingsInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingUpdateWithoutCourseTakingDataInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  assignmentTakings?: Maybe<AssignmentTakingUpdateManyWithoutLessonTakingInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  lessonContent?: Maybe<LessonContentUpdateOneRequiredWithoutLessonTakingsInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingUpdateWithoutLessonContentDataInput = {
  assignedDate?: Maybe<Scalars['DateTime']>;
  assignmentTakings?: Maybe<AssignmentTakingUpdateManyWithoutLessonTakingInput>;
  courseTaking?: Maybe<CourseTakingUpdateOneWithoutLessonTakingsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  day?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type LessonTakingUpdateWithWhereUniqueWithoutCourseTakingInput = {
  data: LessonTakingUpdateWithoutCourseTakingDataInput;
  where: LessonTakingWhereUniqueInput;
};

export type LessonTakingUpdateWithWhereUniqueWithoutLessonContentInput = {
  data: LessonTakingUpdateWithoutLessonContentDataInput;
  where: LessonTakingWhereUniqueInput;
};

export type LessonTakingUpsertWithoutAssignmentTakingsInput = {
  create: LessonTakingCreateWithoutAssignmentTakingsInput;
  update: LessonTakingUpdateWithoutAssignmentTakingsDataInput;
};

export type LessonTakingUpsertWithWhereUniqueWithoutCourseTakingInput = {
  create: LessonTakingCreateWithoutCourseTakingInput;
  update: LessonTakingUpdateWithoutCourseTakingDataInput;
  where: LessonTakingWhereUniqueInput;
};

export type LessonTakingUpsertWithWhereUniqueWithoutLessonContentInput = {
  create: LessonTakingCreateWithoutLessonContentInput;
  update: LessonTakingUpdateWithoutLessonContentDataInput;
  where: LessonTakingWhereUniqueInput;
};

export type LessonTakingWhereInput = {
  AND?: Maybe<Array<LessonTakingWhereInput>>;
  assignedDate?: Maybe<NullableDateTimeFilter>;
  assignmentTakings?: Maybe<AssignmentTakingFilter>;
  courseTaking?: Maybe<CourseTakingWhereInput>;
  courseTakingId?: Maybe<NullableIntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  day?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  lessonContent?: Maybe<LessonContentWhereInput>;
  lessonContentId?: Maybe<IntFilter>;
  NOT?: Maybe<Array<LessonTakingWhereInput>>;
  OR?: Maybe<Array<LessonTakingWhereInput>>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type LessonTakingWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type Model = {
  __typename?: 'Model';
  create: Scalars['Boolean'];
  delete: Scalars['Boolean'];
  fields: Array<Field>;
  id: Scalars['String'];
  name: Scalars['String'];
  update: Scalars['Boolean'];
};

export type MultipleAnswerPartialInput = {
  answerId: Scalars['Int'];
  optionId: Scalars['Int'];
};

export type Mutation = {
  __typename?: 'Mutation';
  addStudent?: Maybe<Student>;
  agreeToCoppa: Scalars['Boolean'];
  assignCourseTakingToStudent?: Maybe<CourseTaking>;
  changeStudentPassword: Scalars['Boolean'];
  completeAssignmentTaking: AssignmentTaking;
  completeAssignmentTakings?: Maybe<Array<AssignmentTaking>>;
  createEvent: Scalars['Boolean'];
  createOneActivity: Activity;
  createOneAssessmentContentQuestion: AssessmentContentQuestion;
  createOneAssessmentContentQuestionAnswer: AssessmentContentQuestionAnswer;
  createOneAssessmentContentQuestionOption: AssessmentContentQuestionOption;
  createOneAssessmentContentQuestionTool: AssessmentContentQuestionTool;
  createOneAssessmentContentQuestionType: AssessmentContentQuestionType;
  createOneAssessmentTakingQuestion: AssessmentTakingQuestion;
  createOneAssessmentTakingResponse: AssessmentTakingResponse;
  createOneAssignmentContent: AssignmentContent;
  createOneAssignmentTaking: AssignmentTaking;
  createOneAssignmentTakingWeight: AssignmentTakingWeight;
  createOneBjuPressAccount: BjuPressAccount;
  createOneCourseContent: CourseContent;
  createOneCourseContentCode: CourseContentCode;
  createOneCourseContentWeightCategory: CourseContentWeightCategory;
  createOneCourseTaking: CourseTaking;
  createOneCourseTakingWeightCategory: CourseTakingWeightCategory;
  createOneEvent: Event;
  createOneEventChildren: EventChildren;
  createOneEventRecurringPattern: EventRecurringPattern;
  createOneFaq: Faq;
  createOneFaqTag: FaqTag;
  createOneGrade: Grade;
  createOneHubAccount: HubAccount;
  createOneHubEntitlement: HubEntitlement;
  createOneLessonContent: LessonContent;
  createOneLessonContentResource: LessonContentResource;
  createOneLessonTaking: LessonTaking;
  createOneParent: Parent;
  createOnePerson: Person;
  createOneStudent: Student;
  createOneUser: User;
  createOneUserLearningSettings: UserLearningSettings;
  deleteEvent: Scalars['Boolean'];
  deleteManyActivity: BatchPayload;
  deleteManyAssessmentContentQuestion: BatchPayload;
  deleteManyAssessmentContentQuestionAnswer: BatchPayload;
  deleteManyAssessmentContentQuestionOption: BatchPayload;
  deleteManyAssessmentContentQuestionTool: BatchPayload;
  deleteManyAssessmentContentQuestionType: BatchPayload;
  deleteManyAssessmentTakingQuestion: BatchPayload;
  deleteManyAssessmentTakingResponse: BatchPayload;
  deleteManyAssignmentContent: BatchPayload;
  deleteManyAssignmentTaking: BatchPayload;
  deleteManyAssignmentTakingWeight: BatchPayload;
  deleteManyBjuPressAccount: BatchPayload;
  deleteManyCourseContent: BatchPayload;
  deleteManyCourseContentCode: BatchPayload;
  deleteManyCourseContentWeightCategory: BatchPayload;
  deleteManyCourseTaking: BatchPayload;
  deleteManyCourseTakingWeightCategory: BatchPayload;
  deleteManyEvent: BatchPayload;
  deleteManyEventChildren: BatchPayload;
  deleteManyEventRecurringPattern: BatchPayload;
  deleteManyFaq: BatchPayload;
  deleteManyFaqTag: BatchPayload;
  deleteManyGrade: BatchPayload;
  deleteManyHubAccount: BatchPayload;
  deleteManyHubEntitlement: BatchPayload;
  deleteManyLessonContent: BatchPayload;
  deleteManyLessonContentResource: BatchPayload;
  deleteManyLessonTaking: BatchPayload;
  deleteManyParent: BatchPayload;
  deleteManyPerson: BatchPayload;
  deleteManyStudent: BatchPayload;
  deleteManyUser: BatchPayload;
  deleteManyUserLearningSettings: BatchPayload;
  deleteOneActivity?: Maybe<Activity>;
  deleteOneAssessmentContentQuestion?: Maybe<AssessmentContentQuestion>;
  deleteOneAssessmentContentQuestionAnswer?: Maybe<AssessmentContentQuestionAnswer>;
  deleteOneAssessmentContentQuestionOption?: Maybe<AssessmentContentQuestionOption>;
  deleteOneAssessmentContentQuestionTool?: Maybe<AssessmentContentQuestionTool>;
  deleteOneAssessmentContentQuestionType?: Maybe<AssessmentContentQuestionType>;
  deleteOneAssessmentTakingQuestion?: Maybe<AssessmentTakingQuestion>;
  deleteOneAssessmentTakingResponse?: Maybe<AssessmentTakingResponse>;
  deleteOneAssignmentContent?: Maybe<AssignmentContent>;
  deleteOneAssignmentTaking?: Maybe<AssignmentTaking>;
  deleteOneAssignmentTakingWeight?: Maybe<AssignmentTakingWeight>;
  deleteOneBjuPressAccount?: Maybe<BjuPressAccount>;
  deleteOneCourseContent?: Maybe<CourseContent>;
  deleteOneCourseContentCode?: Maybe<CourseContentCode>;
  deleteOneCourseContentWeightCategory?: Maybe<CourseContentWeightCategory>;
  deleteOneCourseTaking?: Maybe<CourseTaking>;
  deleteOneCourseTakingWeightCategory?: Maybe<CourseTakingWeightCategory>;
  deleteOneEvent?: Maybe<Event>;
  deleteOneEventChildren?: Maybe<EventChildren>;
  deleteOneEventRecurringPattern?: Maybe<EventRecurringPattern>;
  deleteOneFaq?: Maybe<Faq>;
  deleteOneFaqTag?: Maybe<FaqTag>;
  deleteOneGrade?: Maybe<Grade>;
  deleteOneHubAccount?: Maybe<HubAccount>;
  deleteOneHubEntitlement?: Maybe<HubEntitlement>;
  deleteOneLessonContent?: Maybe<LessonContent>;
  deleteOneLessonContentResource?: Maybe<LessonContentResource>;
  deleteOneLessonTaking?: Maybe<LessonTaking>;
  deleteOneParent?: Maybe<Parent>;
  deleteOnePerson?: Maybe<Person>;
  deleteOneStudent?: Maybe<Student>;
  deleteOneUser?: Maybe<User>;
  deleteOneUserLearningSettings?: Maybe<UserLearningSettings>;
  deleteStudent?: Maybe<Scalars['Boolean']>;
  editStudent?: Maybe<Student>;
  getVitalAPIToken?: Maybe<Parent>;
  gradeAssignmentTaking?: Maybe<AssignmentTaking>;
  GrantRetake?: Maybe<AssignmentTaking>;
  hideVideo: Scalars['Boolean'];
  login: UserLogin;
  logout: Scalars['Boolean'];
  moveLessonToCustomDate?: Maybe<LessonTaking>;
  moveLessonToNextDay?: Maybe<LessonTaking>;
  removeImage: Scalars['Boolean'];
  resetPassword: Scalars['Boolean'];
  sendPasswordEmail: Scalars['Boolean'];
  setAssessmentPwd?: Maybe<Student>;
  signUp: Scalars['Boolean'];
  skipAssignmentTaking: AssignmentTaking;
  startAssessment: Scalars['Boolean'];
  submitAssessmentResponses?: Maybe<AssignmentTaking>;
  tempUpload: TempUploadResp;
  unassignCourseTaking?: Maybe<CourseTaking>;
  updateAllLessonsAfterThisLesson?: Maybe<Array<LessonTaking>>;
  updateAssignmentTaking?: Maybe<AssignmentTaking>;
  updateCoursesOrder: Array<CourseTaking>;
  updateCourseTaking: CourseTaking;
  updateCourseWeights: Array<CourseTakingWeightCategory>;
  updateEvent: Scalars['Boolean'];
  updateField: Field;
  updateLessonSkipped?: Maybe<Array<AssignmentTaking>>;
  updateManyActivity: BatchPayload;
  updateManyAssessmentContentQuestion: BatchPayload;
  updateManyAssessmentContentQuestionAnswer: BatchPayload;
  updateManyAssessmentContentQuestionOption: BatchPayload;
  updateManyAssessmentContentQuestionTool: BatchPayload;
  updateManyAssessmentContentQuestionType: BatchPayload;
  updateManyAssessmentTakingQuestion: BatchPayload;
  updateManyAssessmentTakingResponse: BatchPayload;
  updateManyAssignmentContent: BatchPayload;
  updateManyAssignmentTaking: BatchPayload;
  updateManyAssignmentTakingWeight: BatchPayload;
  updateManyBjuPressAccount: BatchPayload;
  updateManyCourseContent: BatchPayload;
  updateManyCourseContentCode: BatchPayload;
  updateManyCourseContentWeightCategory: BatchPayload;
  updateManyCourseTaking: BatchPayload;
  updateManyCourseTakingWeightCategory: BatchPayload;
  updateManyEvent: BatchPayload;
  updateManyEventChildren: BatchPayload;
  updateManyEventRecurringPattern: BatchPayload;
  updateManyFaq: BatchPayload;
  updateManyFaqTag: BatchPayload;
  updateManyGrade: BatchPayload;
  updateManyHubAccount: BatchPayload;
  updateManyHubEntitlement: BatchPayload;
  updateManyLessonContent: BatchPayload;
  updateManyLessonContentResource: BatchPayload;
  updateManyLessonTaking: BatchPayload;
  updateManyParent: BatchPayload;
  updateManyPerson: BatchPayload;
  updateManyStudent: BatchPayload;
  updateManyUser: BatchPayload;
  updateManyUserLearningSettings: BatchPayload;
  updateModel: Model;
  updateOneActivity: Activity;
  updateOneAssessmentContentQuestion: AssessmentContentQuestion;
  updateOneAssessmentContentQuestionAnswer: AssessmentContentQuestionAnswer;
  updateOneAssessmentContentQuestionOption: AssessmentContentQuestionOption;
  updateOneAssessmentContentQuestionTool: AssessmentContentQuestionTool;
  updateOneAssessmentContentQuestionType: AssessmentContentQuestionType;
  updateOneAssessmentTakingQuestion: AssessmentTakingQuestion;
  updateOneAssessmentTakingResponse: AssessmentTakingResponse;
  updateOneAssignmentContent: AssignmentContent;
  updateOneAssignmentTaking: AssignmentTaking;
  updateOneAssignmentTakingWeight: AssignmentTakingWeight;
  updateOneBjuPressAccount: BjuPressAccount;
  updateOneCourseContent: CourseContent;
  updateOneCourseContentCode: CourseContentCode;
  updateOneCourseContentWeightCategory: CourseContentWeightCategory;
  updateOneCourseTaking: CourseTaking;
  updateOneCourseTakingWeightCategory: CourseTakingWeightCategory;
  updateOneEvent: Event;
  updateOneEventChildren: EventChildren;
  updateOneEventRecurringPattern: EventRecurringPattern;
  updateOneFaq: Faq;
  updateOneFaqTag: FaqTag;
  updateOneGrade: Grade;
  updateOneHubAccount: HubAccount;
  updateOneHubEntitlement: HubEntitlement;
  updateOneLessonContent: LessonContent;
  updateOneLessonContentResource: LessonContentResource;
  updateOneLessonTaking: LessonTaking;
  updateOneParent: Parent;
  updateOnePerson: Person;
  updateOneStudent: Student;
  updateOneUser: User;
  updateOneUserLearningSettings: UserLearningSettings;
  updatePassword: Scalars['Boolean'];
  updateUseGradeWeights?: Maybe<CourseTaking>;
  updateUser?: Maybe<User>;
  uploadImage: TempUploadResp;
  uploadSupportAttachment: FileUploadResp;
  wizardFinish: Scalars['Boolean'];
};

export type MutationAddStudentArgs = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  dob?: Maybe<Scalars['DateTime']>;
  firstName: Scalars['String'];
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName: Scalars['String'];
  lessonsPerDay?: Maybe<Scalars['Int']>;
  password: Scalars['String'];
  username: Scalars['String'];
};

export type MutationAssignCourseTakingToStudentArgs = {
  course: SubmitCourse;
  parentId: Scalars['Int'];
  studentId: Scalars['Int'];
};

export type MutationChangeStudentPasswordArgs = {
  password: Scalars['String'];
  studentId: Scalars['Int'];
};

export type MutationCompleteAssignmentTakingArgs = {
  assignmentId: Scalars['Int'];
  status: Scalars['Boolean'];
};

export type MutationCompleteAssignmentTakingsArgs = {
  assignments?: Maybe<Array<Scalars['Int']>>;
  status: Scalars['Boolean'];
};

export type MutationCreateEventArgs = {
  data: EventCreateUserInput;
};

export type MutationCreateOneActivityArgs = {
  data: ActivityCreateInput;
};

export type MutationCreateOneAssessmentContentQuestionArgs = {
  data: AssessmentContentQuestionCreateInput;
};

export type MutationCreateOneAssessmentContentQuestionAnswerArgs = {
  data: AssessmentContentQuestionAnswerCreateInput;
};

export type MutationCreateOneAssessmentContentQuestionOptionArgs = {
  data: AssessmentContentQuestionOptionCreateInput;
};

export type MutationCreateOneAssessmentContentQuestionToolArgs = {
  data: AssessmentContentQuestionToolCreateInput;
};

export type MutationCreateOneAssessmentContentQuestionTypeArgs = {
  data: AssessmentContentQuestionTypeCreateInput;
};

export type MutationCreateOneAssessmentTakingQuestionArgs = {
  data: AssessmentTakingQuestionCreateInput;
};

export type MutationCreateOneAssessmentTakingResponseArgs = {
  data: AssessmentTakingResponseCreateInput;
};

export type MutationCreateOneAssignmentContentArgs = {
  data: AssignmentContentCreateInput;
};

export type MutationCreateOneAssignmentTakingArgs = {
  data: AssignmentTakingCreateInput;
};

export type MutationCreateOneAssignmentTakingWeightArgs = {
  data: AssignmentTakingWeightCreateInput;
};

export type MutationCreateOneBjuPressAccountArgs = {
  data: BjuPressAccountCreateInput;
};

export type MutationCreateOneCourseContentArgs = {
  data: CourseContentCreateInput;
};

export type MutationCreateOneCourseContentCodeArgs = {
  data: CourseContentCodeCreateInput;
};

export type MutationCreateOneCourseContentWeightCategoryArgs = {
  data: CourseContentWeightCategoryCreateInput;
};

export type MutationCreateOneCourseTakingArgs = {
  data: CourseTakingCreateInput;
};

export type MutationCreateOneCourseTakingWeightCategoryArgs = {
  data: CourseTakingWeightCategoryCreateInput;
};

export type MutationCreateOneEventArgs = {
  data: EventCreateInput;
};

export type MutationCreateOneEventChildrenArgs = {
  data: EventChildrenCreateInput;
};

export type MutationCreateOneEventRecurringPatternArgs = {
  data: EventRecurringPatternCreateInput;
};

export type MutationCreateOneFaqArgs = {
  data: FaqCreateInput;
};

export type MutationCreateOneFaqTagArgs = {
  data: FaqTagCreateInput;
};

export type MutationCreateOneGradeArgs = {
  data: GradeCreateInput;
};

export type MutationCreateOneHubAccountArgs = {
  data: HubAccountCreateInput;
};

export type MutationCreateOneHubEntitlementArgs = {
  data: HubEntitlementCreateInput;
};

export type MutationCreateOneLessonContentArgs = {
  data: LessonContentCreateInput;
};

export type MutationCreateOneLessonContentResourceArgs = {
  data: LessonContentResourceCreateInput;
};

export type MutationCreateOneLessonTakingArgs = {
  data: LessonTakingCreateInput;
};

export type MutationCreateOneParentArgs = {
  data: ParentCreateInput;
};

export type MutationCreateOnePersonArgs = {
  data: PersonCreateInput;
};

export type MutationCreateOneStudentArgs = {
  data: StudentCreateInput;
};

export type MutationCreateOneUserArgs = {
  data: UserCreateInput;
};

export type MutationCreateOneUserLearningSettingsArgs = {
  data: UserLearningSettingsCreateInput;
};

export type MutationDeleteEventArgs = {
  id: Scalars['Int'];
  isChildEvent?: Maybe<Scalars['Boolean']>;
};

export type MutationDeleteManyActivityArgs = {
  where?: Maybe<ActivityWhereInput>;
};

export type MutationDeleteManyAssessmentContentQuestionArgs = {
  where?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type MutationDeleteManyAssessmentContentQuestionAnswerArgs = {
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
};

export type MutationDeleteManyAssessmentContentQuestionOptionArgs = {
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type MutationDeleteManyAssessmentContentQuestionToolArgs = {
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
};

export type MutationDeleteManyAssessmentContentQuestionTypeArgs = {
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
};

export type MutationDeleteManyAssessmentTakingQuestionArgs = {
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type MutationDeleteManyAssessmentTakingResponseArgs = {
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type MutationDeleteManyAssignmentContentArgs = {
  where?: Maybe<AssignmentContentWhereInput>;
};

export type MutationDeleteManyAssignmentTakingArgs = {
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type MutationDeleteManyAssignmentTakingWeightArgs = {
  where?: Maybe<AssignmentTakingWeightWhereInput>;
};

export type MutationDeleteManyBjuPressAccountArgs = {
  where?: Maybe<BjuPressAccountWhereInput>;
};

export type MutationDeleteManyCourseContentArgs = {
  where?: Maybe<CourseContentWhereInput>;
};

export type MutationDeleteManyCourseContentCodeArgs = {
  where?: Maybe<CourseContentCodeWhereInput>;
};

export type MutationDeleteManyCourseContentWeightCategoryArgs = {
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
};

export type MutationDeleteManyCourseTakingArgs = {
  where?: Maybe<CourseTakingWhereInput>;
};

export type MutationDeleteManyCourseTakingWeightCategoryArgs = {
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type MutationDeleteManyEventArgs = {
  where?: Maybe<EventWhereInput>;
};

export type MutationDeleteManyEventChildrenArgs = {
  where?: Maybe<EventChildrenWhereInput>;
};

export type MutationDeleteManyEventRecurringPatternArgs = {
  where?: Maybe<EventRecurringPatternWhereInput>;
};

export type MutationDeleteManyFaqArgs = {
  where?: Maybe<FaqWhereInput>;
};

export type MutationDeleteManyFaqTagArgs = {
  where?: Maybe<FaqTagWhereInput>;
};

export type MutationDeleteManyGradeArgs = {
  where?: Maybe<GradeWhereInput>;
};

export type MutationDeleteManyHubAccountArgs = {
  where?: Maybe<HubAccountWhereInput>;
};

export type MutationDeleteManyHubEntitlementArgs = {
  where?: Maybe<HubEntitlementWhereInput>;
};

export type MutationDeleteManyLessonContentArgs = {
  where?: Maybe<LessonContentWhereInput>;
};

export type MutationDeleteManyLessonContentResourceArgs = {
  where?: Maybe<LessonContentResourceWhereInput>;
};

export type MutationDeleteManyLessonTakingArgs = {
  where?: Maybe<LessonTakingWhereInput>;
};

export type MutationDeleteManyParentArgs = {
  where?: Maybe<ParentWhereInput>;
};

export type MutationDeleteManyPersonArgs = {
  where?: Maybe<PersonWhereInput>;
};

export type MutationDeleteManyStudentArgs = {
  where?: Maybe<StudentWhereInput>;
};

export type MutationDeleteManyUserArgs = {
  where?: Maybe<UserWhereInput>;
};

export type MutationDeleteManyUserLearningSettingsArgs = {
  where?: Maybe<UserLearningSettingsWhereInput>;
};

export type MutationDeleteOneActivityArgs = {
  where: ActivityWhereUniqueInput;
};

export type MutationDeleteOneAssessmentContentQuestionArgs = {
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type MutationDeleteOneAssessmentContentQuestionAnswerArgs = {
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
};

export type MutationDeleteOneAssessmentContentQuestionOptionArgs = {
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type MutationDeleteOneAssessmentContentQuestionToolArgs = {
  where: AssessmentContentQuestionToolWhereUniqueInput;
};

export type MutationDeleteOneAssessmentContentQuestionTypeArgs = {
  where: AssessmentContentQuestionTypeWhereUniqueInput;
};

export type MutationDeleteOneAssessmentTakingQuestionArgs = {
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type MutationDeleteOneAssessmentTakingResponseArgs = {
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type MutationDeleteOneAssignmentContentArgs = {
  where: AssignmentContentWhereUniqueInput;
};

export type MutationDeleteOneAssignmentTakingArgs = {
  where: AssignmentTakingWhereUniqueInput;
};

export type MutationDeleteOneAssignmentTakingWeightArgs = {
  where: AssignmentTakingWeightWhereUniqueInput;
};

export type MutationDeleteOneBjuPressAccountArgs = {
  where: BjuPressAccountWhereUniqueInput;
};

export type MutationDeleteOneCourseContentArgs = {
  where: CourseContentWhereUniqueInput;
};

export type MutationDeleteOneCourseContentCodeArgs = {
  where: CourseContentCodeWhereUniqueInput;
};

export type MutationDeleteOneCourseContentWeightCategoryArgs = {
  where: CourseContentWeightCategoryWhereUniqueInput;
};

export type MutationDeleteOneCourseTakingArgs = {
  where: CourseTakingWhereUniqueInput;
};

export type MutationDeleteOneCourseTakingWeightCategoryArgs = {
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type MutationDeleteOneEventArgs = {
  where: EventWhereUniqueInput;
};

export type MutationDeleteOneEventChildrenArgs = {
  where: EventChildrenWhereUniqueInput;
};

export type MutationDeleteOneEventRecurringPatternArgs = {
  where: EventRecurringPatternWhereUniqueInput;
};

export type MutationDeleteOneFaqArgs = {
  where: FaqWhereUniqueInput;
};

export type MutationDeleteOneFaqTagArgs = {
  where: FaqTagWhereUniqueInput;
};

export type MutationDeleteOneGradeArgs = {
  where: GradeWhereUniqueInput;
};

export type MutationDeleteOneHubAccountArgs = {
  where: HubAccountWhereUniqueInput;
};

export type MutationDeleteOneHubEntitlementArgs = {
  where: HubEntitlementWhereUniqueInput;
};

export type MutationDeleteOneLessonContentArgs = {
  where: LessonContentWhereUniqueInput;
};

export type MutationDeleteOneLessonContentResourceArgs = {
  where: LessonContentResourceWhereUniqueInput;
};

export type MutationDeleteOneLessonTakingArgs = {
  where: LessonTakingWhereUniqueInput;
};

export type MutationDeleteOneParentArgs = {
  where: ParentWhereUniqueInput;
};

export type MutationDeleteOnePersonArgs = {
  where: PersonWhereUniqueInput;
};

export type MutationDeleteOneStudentArgs = {
  where: StudentWhereUniqueInput;
};

export type MutationDeleteOneUserArgs = {
  where: UserWhereUniqueInput;
};

export type MutationDeleteOneUserLearningSettingsArgs = {
  where: UserLearningSettingsWhereUniqueInput;
};

export type MutationDeleteStudentArgs = {
  studentId: Scalars['Int'];
};

export type MutationEditStudentArgs = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  dob?: Maybe<Scalars['DateTime']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  studentId: Scalars['Int'];
  username?: Maybe<Scalars['String']>;
};

export type MutationGetVitalApiTokenArgs = {
  parentId: Scalars['Int'];
  vitalSourcePassword: Scalars['String'];
  vitalSourceUsername: Scalars['String'];
};

export type MutationGradeAssignmentTakingArgs = {
  input?: Maybe<GradeAssignmentInput>;
};

export type MutationGrantRetakeArgs = {
  assignmentTakingId: Scalars['Int'];
};

export type MutationLoginArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type MutationMoveLessonToCustomDateArgs = {
  date: Scalars['DateTime'];
  lessonId: Scalars['Int'];
};

export type MutationMoveLessonToNextDayArgs = {
  lessonId: Scalars['Int'];
};

export type MutationRemoveImageArgs = {
  key: Scalars['String'];
};

export type MutationResetPasswordArgs = {
  password: Scalars['String'];
  passwordResetToken: Scalars['String'];
};

export type MutationSendPasswordEmailArgs = {
  email: Scalars['String'];
};

export type MutationSetAssessmentPwdArgs = {
  assessmentPwd: Scalars['String'];
  studentId: Scalars['Int'];
};

export type MutationSignUpArgs = {
  addrLine1: Scalars['String'];
  city: Scalars['String'];
  email: Scalars['String'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  password: Scalars['String'];
  pressAcctNum?: Maybe<Scalars['Int']>;
  state: Scalars['String'];
  zipCode: Scalars['String'];
};

export type MutationSkipAssignmentTakingArgs = {
  assignmentId: Scalars['Int'];
  status: Scalars['Boolean'];
};

export type MutationStartAssessmentArgs = {
  assignmentTakingId: Scalars['Int'];
};

export type MutationSubmitAssessmentResponsesArgs = {
  assessmentContentAnswers: Array<AssessmentSubmitInput>;
  assessmentId: Scalars['Int'];
};

export type MutationTempUploadArgs = {
  file?: Maybe<Scalars['Upload']>;
};

export type MutationUnassignCourseTakingArgs = {
  id: Scalars['Int'];
};

export type MutationUpdateAllLessonsAfterThisLessonArgs = {
  date: Scalars['DateTime'];
  lessonId: Scalars['Int'];
  studentUserId: Scalars['Int'];
};

export type MutationUpdateAssignmentTakingArgs = {
  data: AssignmentTakingUpdateInput;
  where: AssignmentTakingWhereUniqueInput;
};

export type MutationUpdateCoursesOrderArgs = {
  data: Array<CourseOrder>;
};

export type MutationUpdateCourseTakingArgs = {
  courseTaking: SubmitCourse;
};

export type MutationUpdateCourseWeightsArgs = {
  weights: Array<GradeWeight>;
};

export type MutationUpdateEventArgs = {
  data: EventUpdateInput2;
  where: EventWhereUniqueInput;
};

export type MutationUpdateFieldArgs = {
  data?: Maybe<UpdateFieldInput>;
  id: Scalars['String'];
  modelId: Scalars['String'];
};

export type MutationUpdateLessonSkippedArgs = {
  lessonId: Scalars['Int'];
  status: Scalars['Boolean'];
};

export type MutationUpdateManyActivityArgs = {
  data: ActivityUpdateManyMutationInput;
  where?: Maybe<ActivityWhereInput>;
};

export type MutationUpdateManyAssessmentContentQuestionArgs = {
  data: AssessmentContentQuestionUpdateManyMutationInput;
  where?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type MutationUpdateManyAssessmentContentQuestionAnswerArgs = {
  data: AssessmentContentQuestionAnswerUpdateManyMutationInput;
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
};

export type MutationUpdateManyAssessmentContentQuestionOptionArgs = {
  data: AssessmentContentQuestionOptionUpdateManyMutationInput;
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type MutationUpdateManyAssessmentContentQuestionToolArgs = {
  data: AssessmentContentQuestionToolUpdateManyMutationInput;
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
};

export type MutationUpdateManyAssessmentContentQuestionTypeArgs = {
  data: AssessmentContentQuestionTypeUpdateManyMutationInput;
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
};

export type MutationUpdateManyAssessmentTakingQuestionArgs = {
  data: AssessmentTakingQuestionUpdateManyMutationInput;
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type MutationUpdateManyAssessmentTakingResponseArgs = {
  data: AssessmentTakingResponseUpdateManyMutationInput;
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type MutationUpdateManyAssignmentContentArgs = {
  data: AssignmentContentUpdateManyMutationInput;
  where?: Maybe<AssignmentContentWhereInput>;
};

export type MutationUpdateManyAssignmentTakingArgs = {
  data: AssignmentTakingUpdateManyMutationInput;
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type MutationUpdateManyAssignmentTakingWeightArgs = {
  data: AssignmentTakingWeightUpdateManyMutationInput;
  where?: Maybe<AssignmentTakingWeightWhereInput>;
};

export type MutationUpdateManyBjuPressAccountArgs = {
  data: BjuPressAccountUpdateManyMutationInput;
  where?: Maybe<BjuPressAccountWhereInput>;
};

export type MutationUpdateManyCourseContentArgs = {
  data: CourseContentUpdateManyMutationInput;
  where?: Maybe<CourseContentWhereInput>;
};

export type MutationUpdateManyCourseContentCodeArgs = {
  data: CourseContentCodeUpdateManyMutationInput;
  where?: Maybe<CourseContentCodeWhereInput>;
};

export type MutationUpdateManyCourseContentWeightCategoryArgs = {
  data: CourseContentWeightCategoryUpdateManyMutationInput;
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
};

export type MutationUpdateManyCourseTakingArgs = {
  data: CourseTakingUpdateManyMutationInput;
  where?: Maybe<CourseTakingWhereInput>;
};

export type MutationUpdateManyCourseTakingWeightCategoryArgs = {
  data: CourseTakingWeightCategoryUpdateManyMutationInput;
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type MutationUpdateManyEventArgs = {
  data: EventUpdateManyMutationInput;
  where?: Maybe<EventWhereInput>;
};

export type MutationUpdateManyEventChildrenArgs = {
  data: EventChildrenUpdateManyMutationInput;
  where?: Maybe<EventChildrenWhereInput>;
};

export type MutationUpdateManyEventRecurringPatternArgs = {
  data: EventRecurringPatternUpdateManyMutationInput;
  where?: Maybe<EventRecurringPatternWhereInput>;
};

export type MutationUpdateManyFaqArgs = {
  data: FaqUpdateManyMutationInput;
  where?: Maybe<FaqWhereInput>;
};

export type MutationUpdateManyFaqTagArgs = {
  data: FaqTagUpdateManyMutationInput;
  where?: Maybe<FaqTagWhereInput>;
};

export type MutationUpdateManyGradeArgs = {
  data: GradeUpdateManyMutationInput;
  where?: Maybe<GradeWhereInput>;
};

export type MutationUpdateManyHubAccountArgs = {
  data: HubAccountUpdateManyMutationInput;
  where?: Maybe<HubAccountWhereInput>;
};

export type MutationUpdateManyHubEntitlementArgs = {
  data: HubEntitlementUpdateManyMutationInput;
  where?: Maybe<HubEntitlementWhereInput>;
};

export type MutationUpdateManyLessonContentArgs = {
  data: LessonContentUpdateManyMutationInput;
  where?: Maybe<LessonContentWhereInput>;
};

export type MutationUpdateManyLessonContentResourceArgs = {
  data: LessonContentResourceUpdateManyMutationInput;
  where?: Maybe<LessonContentResourceWhereInput>;
};

export type MutationUpdateManyLessonTakingArgs = {
  data: LessonTakingUpdateManyMutationInput;
  where?: Maybe<LessonTakingWhereInput>;
};

export type MutationUpdateManyParentArgs = {
  data: ParentUpdateManyMutationInput;
  where?: Maybe<ParentWhereInput>;
};

export type MutationUpdateManyPersonArgs = {
  data: PersonUpdateManyMutationInput;
  where?: Maybe<PersonWhereInput>;
};

export type MutationUpdateManyStudentArgs = {
  data: StudentUpdateManyMutationInput;
  where?: Maybe<StudentWhereInput>;
};

export type MutationUpdateManyUserArgs = {
  data: UserUpdateManyMutationInput;
  where?: Maybe<UserWhereInput>;
};

export type MutationUpdateManyUserLearningSettingsArgs = {
  data: UserLearningSettingsUpdateManyMutationInput;
  where?: Maybe<UserLearningSettingsWhereInput>;
};

export type MutationUpdateModelArgs = {
  data?: Maybe<UpdateModelInput>;
  id: Scalars['String'];
};

export type MutationUpdateOneActivityArgs = {
  data: ActivityUpdateInput;
  where: ActivityWhereUniqueInput;
};

export type MutationUpdateOneAssessmentContentQuestionArgs = {
  data: AssessmentContentQuestionUpdateInput;
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type MutationUpdateOneAssessmentContentQuestionAnswerArgs = {
  data: AssessmentContentQuestionAnswerUpdateInput;
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
};

export type MutationUpdateOneAssessmentContentQuestionOptionArgs = {
  data: AssessmentContentQuestionOptionUpdateInput;
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type MutationUpdateOneAssessmentContentQuestionToolArgs = {
  data: AssessmentContentQuestionToolUpdateInput;
  where: AssessmentContentQuestionToolWhereUniqueInput;
};

export type MutationUpdateOneAssessmentContentQuestionTypeArgs = {
  data: AssessmentContentQuestionTypeUpdateInput;
  where: AssessmentContentQuestionTypeWhereUniqueInput;
};

export type MutationUpdateOneAssessmentTakingQuestionArgs = {
  data: AssessmentTakingQuestionUpdateInput;
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type MutationUpdateOneAssessmentTakingResponseArgs = {
  data: AssessmentTakingResponseUpdateInput;
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type MutationUpdateOneAssignmentContentArgs = {
  data: AssignmentContentUpdateInput;
  where: AssignmentContentWhereUniqueInput;
};

export type MutationUpdateOneAssignmentTakingArgs = {
  data: AssignmentTakingUpdateInput;
  where: AssignmentTakingWhereUniqueInput;
};

export type MutationUpdateOneAssignmentTakingWeightArgs = {
  data: AssignmentTakingWeightUpdateInput;
  where: AssignmentTakingWeightWhereUniqueInput;
};

export type MutationUpdateOneBjuPressAccountArgs = {
  data: BjuPressAccountUpdateInput;
  where: BjuPressAccountWhereUniqueInput;
};

export type MutationUpdateOneCourseContentArgs = {
  data: CourseContentUpdateInput;
  where: CourseContentWhereUniqueInput;
};

export type MutationUpdateOneCourseContentCodeArgs = {
  data: CourseContentCodeUpdateInput;
  where: CourseContentCodeWhereUniqueInput;
};

export type MutationUpdateOneCourseContentWeightCategoryArgs = {
  data: CourseContentWeightCategoryUpdateInput;
  where: CourseContentWeightCategoryWhereUniqueInput;
};

export type MutationUpdateOneCourseTakingArgs = {
  data: CourseTakingUpdateInput;
  where: CourseTakingWhereUniqueInput;
};

export type MutationUpdateOneCourseTakingWeightCategoryArgs = {
  data: CourseTakingWeightCategoryUpdateInput;
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type MutationUpdateOneEventArgs = {
  data: EventUpdateInput;
  where: EventWhereUniqueInput;
};

export type MutationUpdateOneEventChildrenArgs = {
  data: EventChildrenUpdateInput;
  where: EventChildrenWhereUniqueInput;
};

export type MutationUpdateOneEventRecurringPatternArgs = {
  data: EventRecurringPatternUpdateInput;
  where: EventRecurringPatternWhereUniqueInput;
};

export type MutationUpdateOneFaqArgs = {
  data: FaqUpdateInput;
  where: FaqWhereUniqueInput;
};

export type MutationUpdateOneFaqTagArgs = {
  data: FaqTagUpdateInput;
  where: FaqTagWhereUniqueInput;
};

export type MutationUpdateOneGradeArgs = {
  data: GradeUpdateInput;
  where: GradeWhereUniqueInput;
};

export type MutationUpdateOneHubAccountArgs = {
  data: HubAccountUpdateInput;
  where: HubAccountWhereUniqueInput;
};

export type MutationUpdateOneHubEntitlementArgs = {
  data: HubEntitlementUpdateInput;
  where: HubEntitlementWhereUniqueInput;
};

export type MutationUpdateOneLessonContentArgs = {
  data: LessonContentUpdateInput;
  where: LessonContentWhereUniqueInput;
};

export type MutationUpdateOneLessonContentResourceArgs = {
  data: LessonContentResourceUpdateInput;
  where: LessonContentResourceWhereUniqueInput;
};

export type MutationUpdateOneLessonTakingArgs = {
  data: LessonTakingUpdateInput;
  where: LessonTakingWhereUniqueInput;
};

export type MutationUpdateOneParentArgs = {
  data: ParentUpdateInput;
  where: ParentWhereUniqueInput;
};

export type MutationUpdateOnePersonArgs = {
  data: PersonUpdateInput;
  where: PersonWhereUniqueInput;
};

export type MutationUpdateOneStudentArgs = {
  data: StudentUpdateInput;
  where: StudentWhereUniqueInput;
};

export type MutationUpdateOneUserArgs = {
  data: UserUpdateInput;
  where: UserWhereUniqueInput;
};

export type MutationUpdateOneUserLearningSettingsArgs = {
  data: UserLearningSettingsUpdateInput;
  where: UserLearningSettingsWhereUniqueInput;
};

export type MutationUpdatePasswordArgs = {
  currentPassword: Scalars['String'];
  password: Scalars['String'];
};

export type MutationUpdateUseGradeWeightsArgs = {
  id: Scalars['Int'];
  state: Scalars['Boolean'];
};

export type MutationUpdateUserArgs = {
  data: UserUpdateInput;
};

export type MutationUploadImageArgs = {
  file?: Maybe<Scalars['Upload']>;
};

export type MutationUploadSupportAttachmentArgs = {
  file?: Maybe<Scalars['Upload']>;
};

export type NullableAssignmentContentTypeEnumFilter = {
  equals?: Maybe<AssignmentContentTypeEnum>;
  in?: Maybe<Array<AssignmentContentTypeEnum>>;
  not?: Maybe<AssignmentContentTypeEnum>;
  notIn?: Maybe<Array<AssignmentContentTypeEnum>>;
};

export type NullableBooleanFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<Scalars['Boolean']>;
};

export type NullableCourseTakingStatusFilter = {
  equals?: Maybe<CourseTakingStatus>;
  in?: Maybe<Array<CourseTakingStatus>>;
  not?: Maybe<CourseTakingStatus>;
  notIn?: Maybe<Array<CourseTakingStatus>>;
};

export type NullableDateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<Scalars['DateTime']>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type NullableFloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  not?: Maybe<Scalars['Float']>;
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export type NullableIntFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<Scalars['Int']>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type NullablePersonTypeFilter = {
  equals?: Maybe<PersonType>;
  in?: Maybe<Array<PersonType>>;
  not?: Maybe<PersonType>;
  notIn?: Maybe<Array<PersonType>>;
};

export type NullableStatusFilter = {
  equals?: Maybe<Status>;
  in?: Maybe<Array<Status>>;
  not?: Maybe<Status>;
  notIn?: Maybe<Array<Status>>;
};

export type NullableStringFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  not?: Maybe<Scalars['String']>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export enum OrderByArg {
  Asc = 'asc',
  Desc = 'desc',
}

export type Parent = {
  __typename?: 'Parent';
  coppaIsSigned: Scalars['Boolean'];
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  courseTakings: Array<CourseTaking>;
  createdAt: Scalars['DateTime'];
  hideVideo: Scalars['Boolean'];
  id: Scalars['Int'];
  person: Person;
  personId: Scalars['Int'];
  profileEdited: Scalars['Boolean'];
  students: Array<Student>;
  updatedAt: Scalars['DateTime'];
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished: Scalars['Boolean'];
};

export type ParentCourseTakingsArgs = {
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWhereInput>;
};

export type ParentStudentsArgs = {
  after?: Maybe<StudentWhereUniqueInput>;
  before?: Maybe<StudentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<StudentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<StudentWhereInput>;
};

export type ParentCreateInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutParentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  person: PersonCreateOneWithoutParentInput;
  profileEdited?: Maybe<Scalars['Boolean']>;
  students?: Maybe<StudentCreateManyWithoutParentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentCreateOneWithoutCourseTakingsInput = {
  connect?: Maybe<ParentWhereUniqueInput>;
  create?: Maybe<ParentCreateWithoutCourseTakingsInput>;
};

export type ParentCreateOneWithoutPersonInput = {
  connect?: Maybe<ParentWhereUniqueInput>;
  create?: Maybe<ParentCreateWithoutPersonInput>;
};

export type ParentCreateOneWithoutStudentsInput = {
  connect?: Maybe<ParentWhereUniqueInput>;
  create?: Maybe<ParentCreateWithoutStudentsInput>;
};

export type ParentCreateWithoutCourseTakingsInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  person: PersonCreateOneWithoutParentInput;
  profileEdited?: Maybe<Scalars['Boolean']>;
  students?: Maybe<StudentCreateManyWithoutParentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentCreateWithoutPersonInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutParentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  profileEdited?: Maybe<Scalars['Boolean']>;
  students?: Maybe<StudentCreateManyWithoutParentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentCreateWithoutStudentsInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutParentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  person: PersonCreateOneWithoutParentInput;
  profileEdited?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentOrderByInput = {
  coppaIsSigned?: Maybe<OrderByArg>;
  coppaSignedTime?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  hideVideo?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  person?: Maybe<OrderByArg>;
  personId?: Maybe<OrderByArg>;
  profileEdited?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  vitalSourceToken?: Maybe<OrderByArg>;
  wizardFinished?: Maybe<OrderByArg>;
};

export type ParentUpdateInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutParentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneRequiredWithoutParentInput>;
  profileEdited?: Maybe<Scalars['Boolean']>;
  students?: Maybe<StudentUpdateManyWithoutParentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentUpdateManyMutationInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  profileEdited?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentUpdateOneRequiredWithoutCourseTakingsInput = {
  connect?: Maybe<ParentWhereUniqueInput>;
  create?: Maybe<ParentCreateWithoutCourseTakingsInput>;
  update?: Maybe<ParentUpdateWithoutCourseTakingsDataInput>;
  upsert?: Maybe<ParentUpsertWithoutCourseTakingsInput>;
};

export type ParentUpdateOneRequiredWithoutStudentsInput = {
  connect?: Maybe<ParentWhereUniqueInput>;
  create?: Maybe<ParentCreateWithoutStudentsInput>;
  update?: Maybe<ParentUpdateWithoutStudentsDataInput>;
  upsert?: Maybe<ParentUpsertWithoutStudentsInput>;
};

export type ParentUpdateOneWithoutPersonInput = {
  connect?: Maybe<ParentWhereUniqueInput>;
  create?: Maybe<ParentCreateWithoutPersonInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<ParentUpdateWithoutPersonDataInput>;
  upsert?: Maybe<ParentUpsertWithoutPersonInput>;
};

export type ParentUpdateWithoutCourseTakingsDataInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneRequiredWithoutParentInput>;
  profileEdited?: Maybe<Scalars['Boolean']>;
  students?: Maybe<StudentUpdateManyWithoutParentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentUpdateWithoutPersonDataInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutParentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  profileEdited?: Maybe<Scalars['Boolean']>;
  students?: Maybe<StudentUpdateManyWithoutParentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentUpdateWithoutStudentsDataInput = {
  coppaIsSigned?: Maybe<Scalars['Boolean']>;
  coppaSignedTime?: Maybe<Scalars['DateTime']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutParentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  hideVideo?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneRequiredWithoutParentInput>;
  profileEdited?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  vitalSourceToken?: Maybe<Scalars['String']>;
  wizardFinished?: Maybe<Scalars['Boolean']>;
};

export type ParentUpsertWithoutCourseTakingsInput = {
  create: ParentCreateWithoutCourseTakingsInput;
  update: ParentUpdateWithoutCourseTakingsDataInput;
};

export type ParentUpsertWithoutPersonInput = {
  create: ParentCreateWithoutPersonInput;
  update: ParentUpdateWithoutPersonDataInput;
};

export type ParentUpsertWithoutStudentsInput = {
  create: ParentCreateWithoutStudentsInput;
  update: ParentUpdateWithoutStudentsDataInput;
};

export type ParentWhereInput = {
  AND?: Maybe<Array<ParentWhereInput>>;
  coppaIsSigned?: Maybe<BooleanFilter>;
  coppaSignedTime?: Maybe<NullableDateTimeFilter>;
  courseTakings?: Maybe<CourseTakingFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  hideVideo?: Maybe<BooleanFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<ParentWhereInput>>;
  OR?: Maybe<Array<ParentWhereInput>>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  profileEdited?: Maybe<BooleanFilter>;
  students?: Maybe<StudentFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  vitalSourceToken?: Maybe<NullableStringFilter>;
  wizardFinished?: Maybe<BooleanFilter>;
};

export type ParentWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type Person = {
  __typename?: 'Person';
  activities: Array<Activity>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events: Array<Event>;
  firstName: Scalars['String'];
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  lastName: Scalars['String'];
  parent?: Maybe<Parent>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<Student>;
  studentId?: Maybe<Scalars['Int']>;
  type?: Maybe<PersonType>;
  updatedAt: Scalars['DateTime'];
  user: User;
  userId: Scalars['Int'];
  zip?: Maybe<Scalars['String']>;
};

export type PersonActivitiesArgs = {
  after?: Maybe<ActivityWhereUniqueInput>;
  before?: Maybe<ActivityWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<ActivityOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<ActivityWhereInput>;
};

export type PersonEventsArgs = {
  after?: Maybe<EventWhereUniqueInput>;
  before?: Maybe<EventWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventWhereInput>;
};

export type PersonCreateInput = {
  activities?: Maybe<ActivityCreateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventCreateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentCreateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentCreateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user: UserCreateOneWithoutPersonInput;
  zip?: Maybe<Scalars['String']>;
};

export type PersonCreateOneWithoutActivitiesInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutActivitiesInput>;
};

export type PersonCreateOneWithoutEventsInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutEventsInput>;
};

export type PersonCreateOneWithoutParentInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutParentInput>;
};

export type PersonCreateOneWithoutStudentInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutStudentInput>;
};

export type PersonCreateOneWithoutUserInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutUserInput>;
};

export type PersonCreateWithoutActivitiesInput = {
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventCreateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentCreateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentCreateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user: UserCreateOneWithoutPersonInput;
  zip?: Maybe<Scalars['String']>;
};

export type PersonCreateWithoutEventsInput = {
  activities?: Maybe<ActivityCreateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentCreateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentCreateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user: UserCreateOneWithoutPersonInput;
  zip?: Maybe<Scalars['String']>;
};

export type PersonCreateWithoutParentInput = {
  activities?: Maybe<ActivityCreateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventCreateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentCreateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user: UserCreateOneWithoutPersonInput;
  zip?: Maybe<Scalars['String']>;
};

export type PersonCreateWithoutStudentInput = {
  activities?: Maybe<ActivityCreateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventCreateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentCreateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user: UserCreateOneWithoutPersonInput;
  zip?: Maybe<Scalars['String']>;
};

export type PersonCreateWithoutUserInput = {
  activities?: Maybe<ActivityCreateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventCreateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentCreateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentCreateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonOrderByInput = {
  addrLine1?: Maybe<OrderByArg>;
  addrLine2?: Maybe<OrderByArg>;
  city?: Maybe<OrderByArg>;
  country?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  dob?: Maybe<OrderByArg>;
  email?: Maybe<OrderByArg>;
  firstName?: Maybe<OrderByArg>;
  gender?: Maybe<OrderByArg>;
  grade?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  lastName?: Maybe<OrderByArg>;
  phone?: Maybe<OrderByArg>;
  state?: Maybe<OrderByArg>;
  student?: Maybe<OrderByArg>;
  studentId?: Maybe<OrderByArg>;
  type?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  user?: Maybe<OrderByArg>;
  userId?: Maybe<OrderByArg>;
  zip?: Maybe<OrderByArg>;
};

export enum PersonType {
  P = 'P',
  S = 'S',
}

export type PersonUpdateInput = {
  activities?: Maybe<ActivityUpdateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventUpdateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentUpdateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentUpdateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<UserUpdateOneRequiredWithoutPersonInput>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonUpdateManyMutationInput = {
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonUpdateOneRequiredWithoutActivitiesInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutActivitiesInput>;
  update?: Maybe<PersonUpdateWithoutActivitiesDataInput>;
  upsert?: Maybe<PersonUpsertWithoutActivitiesInput>;
};

export type PersonUpdateOneRequiredWithoutParentInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutParentInput>;
  update?: Maybe<PersonUpdateWithoutParentDataInput>;
  upsert?: Maybe<PersonUpsertWithoutParentInput>;
};

export type PersonUpdateOneRequiredWithoutStudentInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutStudentInput>;
  update?: Maybe<PersonUpdateWithoutStudentDataInput>;
  upsert?: Maybe<PersonUpsertWithoutStudentInput>;
};

export type PersonUpdateOneWithoutEventsInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutEventsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<PersonUpdateWithoutEventsDataInput>;
  upsert?: Maybe<PersonUpsertWithoutEventsInput>;
};

export type PersonUpdateOneWithoutUserInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  create?: Maybe<PersonCreateWithoutUserInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<PersonUpdateWithoutUserDataInput>;
  upsert?: Maybe<PersonUpsertWithoutUserInput>;
};

export type PersonUpdateWithoutActivitiesDataInput = {
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventUpdateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentUpdateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentUpdateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<UserUpdateOneRequiredWithoutPersonInput>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonUpdateWithoutEventsDataInput = {
  activities?: Maybe<ActivityUpdateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentUpdateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentUpdateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<UserUpdateOneRequiredWithoutPersonInput>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonUpdateWithoutParentDataInput = {
  activities?: Maybe<ActivityUpdateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventUpdateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentUpdateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<UserUpdateOneRequiredWithoutPersonInput>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonUpdateWithoutStudentDataInput = {
  activities?: Maybe<ActivityUpdateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventUpdateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentUpdateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<UserUpdateOneRequiredWithoutPersonInput>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonUpdateWithoutUserDataInput = {
  activities?: Maybe<ActivityUpdateManyWithoutPersonInput>;
  addrLine1?: Maybe<Scalars['String']>;
  addrLine2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dob?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  events?: Maybe<EventUpdateManyWithoutPersonInput>;
  firstName?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  parent?: Maybe<ParentUpdateOneWithoutPersonInput>;
  phone?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  student?: Maybe<StudentUpdateOneWithoutPersonInput>;
  type?: Maybe<PersonType>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  zip?: Maybe<Scalars['String']>;
};

export type PersonUpsertWithoutActivitiesInput = {
  create: PersonCreateWithoutActivitiesInput;
  update: PersonUpdateWithoutActivitiesDataInput;
};

export type PersonUpsertWithoutEventsInput = {
  create: PersonCreateWithoutEventsInput;
  update: PersonUpdateWithoutEventsDataInput;
};

export type PersonUpsertWithoutParentInput = {
  create: PersonCreateWithoutParentInput;
  update: PersonUpdateWithoutParentDataInput;
};

export type PersonUpsertWithoutStudentInput = {
  create: PersonCreateWithoutStudentInput;
  update: PersonUpdateWithoutStudentDataInput;
};

export type PersonUpsertWithoutUserInput = {
  create: PersonCreateWithoutUserInput;
  update: PersonUpdateWithoutUserDataInput;
};

export type PersonWhereInput = {
  activities?: Maybe<ActivityFilter>;
  addrLine1?: Maybe<NullableStringFilter>;
  addrLine2?: Maybe<NullableStringFilter>;
  AND?: Maybe<Array<PersonWhereInput>>;
  city?: Maybe<NullableStringFilter>;
  country?: Maybe<NullableStringFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  dob?: Maybe<NullableDateTimeFilter>;
  email?: Maybe<NullableStringFilter>;
  events?: Maybe<EventFilter>;
  firstName?: Maybe<StringFilter>;
  gender?: Maybe<NullableStringFilter>;
  grade?: Maybe<NullableStringFilter>;
  id?: Maybe<IntFilter>;
  lastName?: Maybe<StringFilter>;
  NOT?: Maybe<Array<PersonWhereInput>>;
  OR?: Maybe<Array<PersonWhereInput>>;
  parent?: Maybe<ParentWhereInput>;
  phone?: Maybe<NullableStringFilter>;
  state?: Maybe<NullableStringFilter>;
  student?: Maybe<StudentWhereInput>;
  studentId?: Maybe<NullableIntFilter>;
  type?: Maybe<NullablePersonTypeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<IntFilter>;
  zip?: Maybe<NullableStringFilter>;
};

export type PersonWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type Query = {
  __typename?: 'Query';
  assignmentTaking?: Maybe<AssignmentTaking>;
  assignmentTakings?: Maybe<Array<AssignmentTaking>>;
  checkAssessmentPwd: Scalars['Boolean'];
  checkEmailAvailability: Scalars['Boolean'];
  checkForBJUPAcctByEmailOrLastName: BjupAcctCheck;
  checkForBJUPAcctByNumOrEmail: BjupAcctCheck;
  courseTaking?: Maybe<CourseTaking>;
  courseTakings?: Maybe<Array<CourseTaking>>;
  faq?: Maybe<Faq>;
  faqs?: Maybe<Array<Faq>>;
  faqTags?: Maybe<Array<FaqTag>>;
  fetchEntitlements: Scalars['Boolean'];
  findManyActivity?: Maybe<Array<Activity>>;
  findManyActivityCount: Scalars['Int'];
  findManyAssessmentContentQuestion?: Maybe<Array<AssessmentContentQuestion>>;
  findManyAssessmentContentQuestionAnswer?: Maybe<Array<AssessmentContentQuestionAnswer>>;
  findManyAssessmentContentQuestionAnswerCount: Scalars['Int'];
  findManyAssessmentContentQuestionCount: Scalars['Int'];
  findManyAssessmentContentQuestionOption?: Maybe<Array<AssessmentContentQuestionOption>>;
  findManyAssessmentContentQuestionOptionCount: Scalars['Int'];
  findManyAssessmentContentQuestionTool?: Maybe<Array<AssessmentContentQuestionTool>>;
  findManyAssessmentContentQuestionToolCount: Scalars['Int'];
  findManyAssessmentContentQuestionType?: Maybe<Array<AssessmentContentQuestionType>>;
  findManyAssessmentContentQuestionTypeCount: Scalars['Int'];
  findManyAssessmentTakingQuestion?: Maybe<Array<AssessmentTakingQuestion>>;
  findManyAssessmentTakingQuestionCount: Scalars['Int'];
  findManyAssessmentTakingResponse?: Maybe<Array<AssessmentTakingResponse>>;
  findManyAssessmentTakingResponseCount: Scalars['Int'];
  findManyAssignmentContent?: Maybe<Array<AssignmentContent>>;
  findManyAssignmentContentCount: Scalars['Int'];
  findManyAssignmentTaking?: Maybe<Array<AssignmentTaking>>;
  findManyAssignmentTakingCount: Scalars['Int'];
  findManyAssignmentTakingWeight?: Maybe<Array<AssignmentTakingWeight>>;
  findManyAssignmentTakingWeightCount: Scalars['Int'];
  findManyBjuPressAccount?: Maybe<Array<BjuPressAccount>>;
  findManyBjuPressAccountCount: Scalars['Int'];
  findManyCourseContent?: Maybe<Array<CourseContent>>;
  findManyCourseContentCode?: Maybe<Array<CourseContentCode>>;
  findManyCourseContentCodeCount: Scalars['Int'];
  findManyCourseContentCount: Scalars['Int'];
  findManyCourseContentWeightCategory?: Maybe<Array<CourseContentWeightCategory>>;
  findManyCourseContentWeightCategoryCount: Scalars['Int'];
  findManyCourseTaking?: Maybe<Array<CourseTaking>>;
  findManyCourseTakingCount: Scalars['Int'];
  findManyCourseTakingWeightCategory?: Maybe<Array<CourseTakingWeightCategory>>;
  findManyCourseTakingWeightCategoryCount: Scalars['Int'];
  findManyEvent?: Maybe<Array<Event>>;
  findManyEventChildren?: Maybe<Array<EventChildren>>;
  findManyEventChildrenCount: Scalars['Int'];
  findManyEventCount: Scalars['Int'];
  findManyEventRecurringPattern?: Maybe<Array<EventRecurringPattern>>;
  findManyEventRecurringPatternCount: Scalars['Int'];
  findManyFaq?: Maybe<Array<Faq>>;
  findManyFaqCount: Scalars['Int'];
  findManyFaqTag?: Maybe<Array<FaqTag>>;
  findManyFaqTagCount: Scalars['Int'];
  findManyGrade?: Maybe<Array<Grade>>;
  findManyGradeCount: Scalars['Int'];
  findManyHubAccount?: Maybe<Array<HubAccount>>;
  findManyHubAccountCount: Scalars['Int'];
  findManyHubEntitlement?: Maybe<Array<HubEntitlement>>;
  findManyHubEntitlementCount: Scalars['Int'];
  findManyLessonContent?: Maybe<Array<LessonContent>>;
  findManyLessonContentCount: Scalars['Int'];
  findManyLessonContentResource?: Maybe<Array<LessonContentResource>>;
  findManyLessonContentResourceCount: Scalars['Int'];
  findManyLessonTaking?: Maybe<Array<LessonTaking>>;
  findManyLessonTakingCount: Scalars['Int'];
  findManyParent?: Maybe<Array<Parent>>;
  findManyParentCount: Scalars['Int'];
  findManyPerson?: Maybe<Array<Person>>;
  findManyPersonCount: Scalars['Int'];
  findManyStudent?: Maybe<Array<Student>>;
  findManyStudentCount: Scalars['Int'];
  findManyUser?: Maybe<Array<User>>;
  findManyUserCount: Scalars['Int'];
  findManyUserLearningSettings?: Maybe<Array<UserLearningSettings>>;
  findManyUserLearningSettingsCount: Scalars['Int'];
  findOneActivity?: Maybe<Activity>;
  findOneAssessmentContentQuestion?: Maybe<AssessmentContentQuestion>;
  findOneAssessmentContentQuestionAnswer?: Maybe<AssessmentContentQuestionAnswer>;
  findOneAssessmentContentQuestionOption?: Maybe<AssessmentContentQuestionOption>;
  findOneAssessmentContentQuestionTool?: Maybe<AssessmentContentQuestionTool>;
  findOneAssessmentContentQuestionType?: Maybe<AssessmentContentQuestionType>;
  findOneAssessmentTakingQuestion?: Maybe<AssessmentTakingQuestion>;
  findOneAssessmentTakingResponse?: Maybe<AssessmentTakingResponse>;
  findOneAssignmentContent?: Maybe<AssignmentContent>;
  findOneAssignmentTaking?: Maybe<AssignmentTaking>;
  findOneAssignmentTakingWeight?: Maybe<AssignmentTakingWeight>;
  findOneBjuPressAccount?: Maybe<BjuPressAccount>;
  findOneCourseContent?: Maybe<CourseContent>;
  findOneCourseContentCode?: Maybe<CourseContentCode>;
  findOneCourseContentWeightCategory?: Maybe<CourseContentWeightCategory>;
  findOneCourseTaking?: Maybe<CourseTaking>;
  findOneCourseTakingWeightCategory?: Maybe<CourseTakingWeightCategory>;
  findOneEvent?: Maybe<Event>;
  findOneEventChildren?: Maybe<EventChildren>;
  findOneEventRecurringPattern?: Maybe<EventRecurringPattern>;
  findOneFaq?: Maybe<Faq>;
  findOneFaqTag?: Maybe<FaqTag>;
  findOneGrade?: Maybe<Grade>;
  findOneHubAccount?: Maybe<HubAccount>;
  findOneHubEntitlement?: Maybe<HubEntitlement>;
  findOneLessonContent?: Maybe<LessonContent>;
  findOneLessonContentResource?: Maybe<LessonContentResource>;
  findOneLessonTaking?: Maybe<LessonTaking>;
  findOneParent?: Maybe<Parent>;
  findOnePerson?: Maybe<Person>;
  findOneStudent?: Maybe<Student>;
  findOneUser?: Maybe<User>;
  findOneUserLearningSettings?: Maybe<UserLearningSettings>;
  getAssignmentsByType?: Maybe<Array<GradesByType>>;
  getAssignmentsCount?: Maybe<Scalars['Int']>;
  getCalendarEvents?: Maybe<Array<Event2>>;
  getCourseAllowedDays: AllowedDays;
  getCoursesProgressAndLateItems?: Maybe<Array<CourseProgressAndLateItem>>;
  getCoursesToAssign?: Maybe<Array<CourseTaking>>;
  getEnum?: Maybe<Enum>;
  getFreeCourses?: Maybe<Array<CourseContent>>;
  getGradebookOverViewForStudentByDate?: Maybe<Array<CourseOverview>>;
  getLessonsContentsCount?: Maybe<Scalars['Int']>;
  getLessonsTakingsCount?: Maybe<Scalars['Int']>;
  getModel?: Maybe<Model>;
  getModels?: Maybe<Array<Model>>;
  getVitalBookRedirectLink: Scalars['String'];
  lessonTaking?: Maybe<LessonTaking>;
  lessonTakings?: Maybe<Array<LessonTaking>>;
  sendSupportRequest: Scalars['Boolean'];
  userDetails?: Maybe<UserDetails>;
  validCurrentPass?: Maybe<Scalars['Boolean']>;
  verifyResetToken?: Maybe<VerifyPasswordResetToken>;
};

export type QueryAssignmentTakingArgs = {
  where: AssignmentTakingWhereUniqueInput;
};

export type QueryAssignmentTakingsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type QueryCheckAssessmentPwdArgs = {
  assessmentPwd?: Maybe<Scalars['String']>;
};

export type QueryCheckEmailAvailabilityArgs = {
  email: Scalars['String'];
};

export type QueryCheckForBjupAcctByEmailOrLastNameArgs = {
  email: Scalars['String'];
  lastName: Scalars['String'];
};

export type QueryCheckForBjupAcctByNumOrEmailArgs = {
  accountNum: Scalars['Int'];
  altEmail: Scalars['String'];
};

export type QueryCourseTakingArgs = {
  where: CourseTakingWhereUniqueInput;
};

export type QueryCourseTakingsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWhereInput>;
};

export type QueryFaqArgs = {
  where: FaqWhereUniqueInput;
};

export type QueryFaqsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqWhereInput>;
};

export type QueryFaqTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqTagOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqTagWhereInput>;
};

export type QueryFindManyActivityArgs = {
  after?: Maybe<ActivityWhereUniqueInput>;
  before?: Maybe<ActivityWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<ActivityOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<ActivityWhereInput>;
};

export type QueryFindManyActivityCountArgs = {
  after?: Maybe<ActivityWhereUniqueInput>;
  before?: Maybe<ActivityWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<ActivityOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<ActivityWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionArgs = {
  after?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionAnswerArgs = {
  after?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionAnswerOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionAnswerCountArgs = {
  after?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionAnswerOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionCountArgs = {
  after?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionOptionArgs = {
  after?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOptionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionOptionCountArgs = {
  after?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionOptionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionToolArgs = {
  after?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionToolOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionToolCountArgs = {
  after?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionToolOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionTypeArgs = {
  after?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionTypeOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
};

export type QueryFindManyAssessmentContentQuestionTypeCountArgs = {
  after?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentContentQuestionTypeOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
};

export type QueryFindManyAssessmentTakingQuestionArgs = {
  after?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type QueryFindManyAssessmentTakingQuestionCountArgs = {
  after?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingQuestionOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type QueryFindManyAssessmentTakingResponseArgs = {
  after?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  before?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingResponseOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type QueryFindManyAssessmentTakingResponseCountArgs = {
  after?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  before?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssessmentTakingResponseOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type QueryFindManyAssignmentContentArgs = {
  after?: Maybe<AssignmentContentWhereUniqueInput>;
  before?: Maybe<AssignmentContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentContentWhereInput>;
};

export type QueryFindManyAssignmentContentCountArgs = {
  after?: Maybe<AssignmentContentWhereUniqueInput>;
  before?: Maybe<AssignmentContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentContentWhereInput>;
};

export type QueryFindManyAssignmentTakingArgs = {
  after?: Maybe<AssignmentTakingWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type QueryFindManyAssignmentTakingCountArgs = {
  after?: Maybe<AssignmentTakingWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type QueryFindManyAssignmentTakingWeightArgs = {
  after?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingWeightOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWeightWhereInput>;
};

export type QueryFindManyAssignmentTakingWeightCountArgs = {
  after?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingWeightOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWeightWhereInput>;
};

export type QueryFindManyBjuPressAccountArgs = {
  after?: Maybe<BjuPressAccountWhereUniqueInput>;
  before?: Maybe<BjuPressAccountWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<BjuPressAccountOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<BjuPressAccountWhereInput>;
};

export type QueryFindManyBjuPressAccountCountArgs = {
  after?: Maybe<BjuPressAccountWhereUniqueInput>;
  before?: Maybe<BjuPressAccountWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<BjuPressAccountOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<BjuPressAccountWhereInput>;
};

export type QueryFindManyCourseContentArgs = {
  after?: Maybe<CourseContentWhereUniqueInput>;
  before?: Maybe<CourseContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseContentWhereInput>;
};

export type QueryFindManyCourseContentCodeArgs = {
  after?: Maybe<CourseContentCodeWhereUniqueInput>;
  before?: Maybe<CourseContentCodeWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseContentCodeOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseContentCodeWhereInput>;
};

export type QueryFindManyCourseContentCodeCountArgs = {
  after?: Maybe<CourseContentCodeWhereUniqueInput>;
  before?: Maybe<CourseContentCodeWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseContentCodeOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseContentCodeWhereInput>;
};

export type QueryFindManyCourseContentCountArgs = {
  after?: Maybe<CourseContentWhereUniqueInput>;
  before?: Maybe<CourseContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseContentWhereInput>;
};

export type QueryFindManyCourseContentWeightCategoryArgs = {
  after?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseContentWeightCategoryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
};

export type QueryFindManyCourseContentWeightCategoryCountArgs = {
  after?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseContentWeightCategoryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
};

export type QueryFindManyCourseTakingArgs = {
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWhereInput>;
};

export type QueryFindManyCourseTakingCountArgs = {
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWhereInput>;
};

export type QueryFindManyCourseTakingWeightCategoryArgs = {
  after?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingWeightCategoryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type QueryFindManyCourseTakingWeightCategoryCountArgs = {
  after?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingWeightCategoryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type QueryFindManyEventArgs = {
  after?: Maybe<EventWhereUniqueInput>;
  before?: Maybe<EventWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventWhereInput>;
};

export type QueryFindManyEventChildrenArgs = {
  after?: Maybe<EventChildrenWhereUniqueInput>;
  before?: Maybe<EventChildrenWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventChildrenOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventChildrenWhereInput>;
};

export type QueryFindManyEventChildrenCountArgs = {
  after?: Maybe<EventChildrenWhereUniqueInput>;
  before?: Maybe<EventChildrenWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventChildrenOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventChildrenWhereInput>;
};

export type QueryFindManyEventCountArgs = {
  after?: Maybe<EventWhereUniqueInput>;
  before?: Maybe<EventWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventWhereInput>;
};

export type QueryFindManyEventRecurringPatternArgs = {
  after?: Maybe<EventRecurringPatternWhereUniqueInput>;
  before?: Maybe<EventRecurringPatternWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventRecurringPatternOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventRecurringPatternWhereInput>;
};

export type QueryFindManyEventRecurringPatternCountArgs = {
  after?: Maybe<EventRecurringPatternWhereUniqueInput>;
  before?: Maybe<EventRecurringPatternWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventRecurringPatternOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventRecurringPatternWhereInput>;
};

export type QueryFindManyFaqArgs = {
  after?: Maybe<FaqWhereUniqueInput>;
  before?: Maybe<FaqWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqWhereInput>;
};

export type QueryFindManyFaqCountArgs = {
  after?: Maybe<FaqWhereUniqueInput>;
  before?: Maybe<FaqWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqWhereInput>;
};

export type QueryFindManyFaqTagArgs = {
  after?: Maybe<FaqTagWhereUniqueInput>;
  before?: Maybe<FaqTagWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqTagOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqTagWhereInput>;
};

export type QueryFindManyFaqTagCountArgs = {
  after?: Maybe<FaqTagWhereUniqueInput>;
  before?: Maybe<FaqTagWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FaqTagOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<FaqTagWhereInput>;
};

export type QueryFindManyGradeArgs = {
  after?: Maybe<GradeWhereUniqueInput>;
  before?: Maybe<GradeWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GradeOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<GradeWhereInput>;
};

export type QueryFindManyGradeCountArgs = {
  after?: Maybe<GradeWhereUniqueInput>;
  before?: Maybe<GradeWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GradeOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<GradeWhereInput>;
};

export type QueryFindManyHubAccountArgs = {
  after?: Maybe<HubAccountWhereUniqueInput>;
  before?: Maybe<HubAccountWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<HubAccountOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<HubAccountWhereInput>;
};

export type QueryFindManyHubAccountCountArgs = {
  after?: Maybe<HubAccountWhereUniqueInput>;
  before?: Maybe<HubAccountWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<HubAccountOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<HubAccountWhereInput>;
};

export type QueryFindManyHubEntitlementArgs = {
  after?: Maybe<HubEntitlementWhereUniqueInput>;
  before?: Maybe<HubEntitlementWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<HubEntitlementOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<HubEntitlementWhereInput>;
};

export type QueryFindManyHubEntitlementCountArgs = {
  after?: Maybe<HubEntitlementWhereUniqueInput>;
  before?: Maybe<HubEntitlementWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<HubEntitlementOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<HubEntitlementWhereInput>;
};

export type QueryFindManyLessonContentArgs = {
  after?: Maybe<LessonContentWhereUniqueInput>;
  before?: Maybe<LessonContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonContentWhereInput>;
};

export type QueryFindManyLessonContentCountArgs = {
  after?: Maybe<LessonContentWhereUniqueInput>;
  before?: Maybe<LessonContentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonContentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonContentWhereInput>;
};

export type QueryFindManyLessonContentResourceArgs = {
  after?: Maybe<LessonContentResourceWhereUniqueInput>;
  before?: Maybe<LessonContentResourceWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonContentResourceOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonContentResourceWhereInput>;
};

export type QueryFindManyLessonContentResourceCountArgs = {
  after?: Maybe<LessonContentResourceWhereUniqueInput>;
  before?: Maybe<LessonContentResourceWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonContentResourceOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonContentResourceWhereInput>;
};

export type QueryFindManyLessonTakingArgs = {
  after?: Maybe<LessonTakingWhereUniqueInput>;
  before?: Maybe<LessonTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonTakingWhereInput>;
};

export type QueryFindManyLessonTakingCountArgs = {
  after?: Maybe<LessonTakingWhereUniqueInput>;
  before?: Maybe<LessonTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonTakingWhereInput>;
};

export type QueryFindManyParentArgs = {
  after?: Maybe<ParentWhereUniqueInput>;
  before?: Maybe<ParentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<ParentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<ParentWhereInput>;
};

export type QueryFindManyParentCountArgs = {
  after?: Maybe<ParentWhereUniqueInput>;
  before?: Maybe<ParentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<ParentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<ParentWhereInput>;
};

export type QueryFindManyPersonArgs = {
  after?: Maybe<PersonWhereUniqueInput>;
  before?: Maybe<PersonWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<PersonOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<PersonWhereInput>;
};

export type QueryFindManyPersonCountArgs = {
  after?: Maybe<PersonWhereUniqueInput>;
  before?: Maybe<PersonWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<PersonOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<PersonWhereInput>;
};

export type QueryFindManyStudentArgs = {
  after?: Maybe<StudentWhereUniqueInput>;
  before?: Maybe<StudentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<StudentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<StudentWhereInput>;
};

export type QueryFindManyStudentCountArgs = {
  after?: Maybe<StudentWhereUniqueInput>;
  before?: Maybe<StudentWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<StudentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<StudentWhereInput>;
};

export type QueryFindManyUserArgs = {
  after?: Maybe<UserWhereUniqueInput>;
  before?: Maybe<UserWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<UserOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<UserWhereInput>;
};

export type QueryFindManyUserCountArgs = {
  after?: Maybe<UserWhereUniqueInput>;
  before?: Maybe<UserWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<UserOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<UserWhereInput>;
};

export type QueryFindManyUserLearningSettingsArgs = {
  after?: Maybe<UserLearningSettingsWhereUniqueInput>;
  before?: Maybe<UserLearningSettingsWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<UserLearningSettingsOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<UserLearningSettingsWhereInput>;
};

export type QueryFindManyUserLearningSettingsCountArgs = {
  after?: Maybe<UserLearningSettingsWhereUniqueInput>;
  before?: Maybe<UserLearningSettingsWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<UserLearningSettingsOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<UserLearningSettingsWhereInput>;
};

export type QueryFindOneActivityArgs = {
  where: ActivityWhereUniqueInput;
};

export type QueryFindOneAssessmentContentQuestionArgs = {
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type QueryFindOneAssessmentContentQuestionAnswerArgs = {
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
};

export type QueryFindOneAssessmentContentQuestionOptionArgs = {
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type QueryFindOneAssessmentContentQuestionToolArgs = {
  where: AssessmentContentQuestionToolWhereUniqueInput;
};

export type QueryFindOneAssessmentContentQuestionTypeArgs = {
  where: AssessmentContentQuestionTypeWhereUniqueInput;
};

export type QueryFindOneAssessmentTakingQuestionArgs = {
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type QueryFindOneAssessmentTakingResponseArgs = {
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type QueryFindOneAssignmentContentArgs = {
  where: AssignmentContentWhereUniqueInput;
};

export type QueryFindOneAssignmentTakingArgs = {
  where: AssignmentTakingWhereUniqueInput;
};

export type QueryFindOneAssignmentTakingWeightArgs = {
  where: AssignmentTakingWeightWhereUniqueInput;
};

export type QueryFindOneBjuPressAccountArgs = {
  where: BjuPressAccountWhereUniqueInput;
};

export type QueryFindOneCourseContentArgs = {
  where: CourseContentWhereUniqueInput;
};

export type QueryFindOneCourseContentCodeArgs = {
  where: CourseContentCodeWhereUniqueInput;
};

export type QueryFindOneCourseContentWeightCategoryArgs = {
  where: CourseContentWeightCategoryWhereUniqueInput;
};

export type QueryFindOneCourseTakingArgs = {
  where: CourseTakingWhereUniqueInput;
};

export type QueryFindOneCourseTakingWeightCategoryArgs = {
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type QueryFindOneEventArgs = {
  where: EventWhereUniqueInput;
};

export type QueryFindOneEventChildrenArgs = {
  where: EventChildrenWhereUniqueInput;
};

export type QueryFindOneEventRecurringPatternArgs = {
  where: EventRecurringPatternWhereUniqueInput;
};

export type QueryFindOneFaqArgs = {
  where: FaqWhereUniqueInput;
};

export type QueryFindOneFaqTagArgs = {
  where: FaqTagWhereUniqueInput;
};

export type QueryFindOneGradeArgs = {
  where: GradeWhereUniqueInput;
};

export type QueryFindOneHubAccountArgs = {
  where: HubAccountWhereUniqueInput;
};

export type QueryFindOneHubEntitlementArgs = {
  where: HubEntitlementWhereUniqueInput;
};

export type QueryFindOneLessonContentArgs = {
  where: LessonContentWhereUniqueInput;
};

export type QueryFindOneLessonContentResourceArgs = {
  where: LessonContentResourceWhereUniqueInput;
};

export type QueryFindOneLessonTakingArgs = {
  where: LessonTakingWhereUniqueInput;
};

export type QueryFindOneParentArgs = {
  where: ParentWhereUniqueInput;
};

export type QueryFindOnePersonArgs = {
  where: PersonWhereUniqueInput;
};

export type QueryFindOneStudentArgs = {
  where: StudentWhereUniqueInput;
};

export type QueryFindOneUserArgs = {
  where: UserWhereUniqueInput;
};

export type QueryFindOneUserLearningSettingsArgs = {
  where: UserLearningSettingsWhereUniqueInput;
};

export type QueryGetAssignmentsByTypeArgs = {
  courseId: Scalars['Int'];
};

export type QueryGetAssignmentsCountArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type QueryGetCalendarEventsArgs = {
  endDate: Scalars['DateTime'];
  startDate: Scalars['DateTime'];
  userIds: Array<Scalars['Int']>;
};

export type QueryGetCourseAllowedDaysArgs = {
  courseId: Scalars['Int'];
};

export type QueryGetCoursesProgressAndLateItemsArgs = {
  courses: Array<Scalars['Int']>;
};

export type QueryGetEnumArgs = {
  name: Scalars['String'];
};

export type QueryGetGradebookOverViewForStudentByDateArgs = {
  fromDate?: Maybe<Scalars['DateTime']>;
  studentId: Scalars['Int'];
  toDate?: Maybe<Scalars['DateTime']>;
};

export type QueryGetLessonsContentsCountArgs = {
  courseId: Scalars['Int'];
};

export type QueryGetLessonsTakingsCountArgs = {
  courseId: Scalars['Int'];
};

export type QueryGetModelArgs = {
  id: Scalars['String'];
};

export type QueryGetVitalBookRedirectLinkArgs = {
  bookUrl: Scalars['String'];
  courseTakingId: Scalars['Int'];
  redemptionCode?: Maybe<Scalars['String']>;
  vitalToken: Scalars['String'];
};

export type QueryLessonTakingArgs = {
  where: LessonTakingWhereUniqueInput;
};

export type QueryLessonTakingsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<LessonTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<LessonTakingWhereInput>;
};

export type QuerySendSupportRequestArgs = {
  attachmentUrl?: Maybe<Scalars['String']>;
  description: Scalars['String'];
  email: Scalars['String'];
  firstName: Scalars['String'];
  grade: Scalars['String'];
  lastName: Scalars['String'];
  subject: Scalars['String'];
  supportType: Scalars['String'];
};

export type QueryValidCurrentPassArgs = {
  password: Scalars['String'];
};

export type QueryVerifyResetTokenArgs = {
  token: Scalars['String'];
};

export enum RecurringType {
  Daily = 'DAILY',
  Monthly = 'MONTHLY',
  Weekly = 'WEEKLY',
  Yearly = 'YEARLY',
}

export type RecurringTypeFilter = {
  equals?: Maybe<RecurringType>;
  in?: Maybe<Array<RecurringType>>;
  not?: Maybe<RecurringType>;
  notIn?: Maybe<Array<RecurringType>>;
};

export enum Status {
  Active = 'Active',
  Deleted = 'Deleted',
  Inactive = 'Inactive',
}

export type StringFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  not?: Maybe<Scalars['String']>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type Student = {
  __typename?: 'Student';
  assessmentPwd?: Maybe<Scalars['String']>;
  courseTakings: Array<CourseTaking>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  lessonsPerDay?: Maybe<Scalars['Int']>;
  parent: Parent;
  parentId: Scalars['Int'];
  person: Person;
  updatedAt: Scalars['DateTime'];
};

export type StudentCourseTakingsArgs = {
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWhereInput>;
};

export type StudentCreateInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutStudentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutStudentsInput;
  person: PersonCreateOneWithoutStudentInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentCreateManyWithoutParentInput = {
  connect?: Maybe<Array<StudentWhereUniqueInput>>;
  create?: Maybe<Array<StudentCreateWithoutParentInput>>;
};

export type StudentCreateOneWithoutCourseTakingsInput = {
  connect?: Maybe<StudentWhereUniqueInput>;
  create?: Maybe<StudentCreateWithoutCourseTakingsInput>;
};

export type StudentCreateOneWithoutPersonInput = {
  connect?: Maybe<StudentWhereUniqueInput>;
  create?: Maybe<StudentCreateWithoutPersonInput>;
};

export type StudentCreateWithoutCourseTakingsInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutStudentsInput;
  person: PersonCreateOneWithoutStudentInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentCreateWithoutParentInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutStudentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  person: PersonCreateOneWithoutStudentInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentCreateWithoutPersonInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutStudentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  parent: ParentCreateOneWithoutStudentsInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentFilter = {
  every?: Maybe<StudentWhereInput>;
  none?: Maybe<StudentWhereInput>;
  some?: Maybe<StudentWhereInput>;
};

export type StudentOrderByInput = {
  assessmentPwd?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  lessonsPerDay?: Maybe<OrderByArg>;
  parent?: Maybe<OrderByArg>;
  parentId?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type StudentScalarWhereInput = {
  AND?: Maybe<Array<StudentScalarWhereInput>>;
  assessmentPwd?: Maybe<NullableStringFilter>;
  courseTakings?: Maybe<CourseTakingFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  lessonsPerDay?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<StudentScalarWhereInput>>;
  OR?: Maybe<Array<StudentScalarWhereInput>>;
  parentId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type StudentUpdateInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutStudentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutStudentsInput>;
  person?: Maybe<PersonUpdateOneRequiredWithoutStudentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentUpdateManyDataInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentUpdateManyMutationInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentUpdateManyWithoutParentInput = {
  connect?: Maybe<Array<StudentWhereUniqueInput>>;
  create?: Maybe<Array<StudentCreateWithoutParentInput>>;
  delete?: Maybe<Array<StudentWhereUniqueInput>>;
  deleteMany?: Maybe<Array<StudentScalarWhereInput>>;
  disconnect?: Maybe<Array<StudentWhereUniqueInput>>;
  set?: Maybe<Array<StudentWhereUniqueInput>>;
  update?: Maybe<Array<StudentUpdateWithWhereUniqueWithoutParentInput>>;
  updateMany?: Maybe<Array<StudentUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<StudentUpsertWithWhereUniqueWithoutParentInput>>;
};

export type StudentUpdateManyWithWhereNestedInput = {
  data: StudentUpdateManyDataInput;
  where: StudentScalarWhereInput;
};

export type StudentUpdateOneWithoutCourseTakingsInput = {
  connect?: Maybe<StudentWhereUniqueInput>;
  create?: Maybe<StudentCreateWithoutCourseTakingsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<StudentUpdateWithoutCourseTakingsDataInput>;
  upsert?: Maybe<StudentUpsertWithoutCourseTakingsInput>;
};

export type StudentUpdateOneWithoutPersonInput = {
  connect?: Maybe<StudentWhereUniqueInput>;
  create?: Maybe<StudentCreateWithoutPersonInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<StudentUpdateWithoutPersonDataInput>;
  upsert?: Maybe<StudentUpsertWithoutPersonInput>;
};

export type StudentUpdateWithoutCourseTakingsDataInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutStudentsInput>;
  person?: Maybe<PersonUpdateOneRequiredWithoutStudentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentUpdateWithoutParentDataInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutStudentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  person?: Maybe<PersonUpdateOneRequiredWithoutStudentInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentUpdateWithoutPersonDataInput = {
  assessmentPwd?: Maybe<Scalars['String']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutStudentInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  parent?: Maybe<ParentUpdateOneRequiredWithoutStudentsInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type StudentUpdateWithWhereUniqueWithoutParentInput = {
  data: StudentUpdateWithoutParentDataInput;
  where: StudentWhereUniqueInput;
};

export type StudentUpsertWithoutCourseTakingsInput = {
  create: StudentCreateWithoutCourseTakingsInput;
  update: StudentUpdateWithoutCourseTakingsDataInput;
};

export type StudentUpsertWithoutPersonInput = {
  create: StudentCreateWithoutPersonInput;
  update: StudentUpdateWithoutPersonDataInput;
};

export type StudentUpsertWithWhereUniqueWithoutParentInput = {
  create: StudentCreateWithoutParentInput;
  update: StudentUpdateWithoutParentDataInput;
  where: StudentWhereUniqueInput;
};

export type StudentWhereInput = {
  AND?: Maybe<Array<StudentWhereInput>>;
  assessmentPwd?: Maybe<NullableStringFilter>;
  courseTakings?: Maybe<CourseTakingFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  lessonsPerDay?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<StudentWhereInput>>;
  OR?: Maybe<Array<StudentWhereInput>>;
  parent?: Maybe<ParentWhereInput>;
  parentId?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type StudentWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type SubmitCourse = {
  courseColor: CourseColor;
  courseContentId?: Maybe<Scalars['Int']>;
  courseId?: Maybe<Scalars['Int']>;
  endDate?: Maybe<Scalars['DateTime']>;
  fri?: Maybe<Scalars['Boolean']>;
  gradeScale?: Maybe<Scalars['Float']>;
  isCustom?: Maybe<Scalars['Boolean']>;
  lessonsPerDay: Scalars['Int'];
  mon?: Maybe<Scalars['Boolean']>;
  order: Scalars['Int'];
  sat?: Maybe<Scalars['Boolean']>;
  startDate?: Maybe<Scalars['DateTime']>;
  sun?: Maybe<Scalars['Boolean']>;
  thu?: Maybe<Scalars['Boolean']>;
  tue?: Maybe<Scalars['Boolean']>;
  wed?: Maybe<Scalars['Boolean']>;
};

export type TempUploadResp = {
  __typename?: 'TempUploadResp';
  avatarLink?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
};

export type TotalGrades = {
  __typename?: 'TotalGrades';
  grade: Scalars['Float'];
  week: Scalars['Int'];
};

export type UpdateFieldInput = {
  create?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['String']>;
  kind?: Maybe<KindEnum>;
  list?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  read?: Maybe<Scalars['Boolean']>;
  required?: Maybe<Scalars['Boolean']>;
  sort?: Maybe<Scalars['Boolean']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['Boolean']>;
};

export type UpdateModelInput = {
  create?: Maybe<Scalars['Boolean']>;
  delete?: Maybe<Scalars['Boolean']>;
  fields?: Maybe<Array<UpdateFieldInput>>;
  name?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['Boolean']>;
};

export type User = {
  __typename?: 'User';
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity: Scalars['Boolean'];
  canAddEventsToCalendar: Scalars['Boolean'];
  canReceiveDirectMessages: Scalars['Boolean'];
  canSeeGrades: Scalars['Boolean'];
  communityPostAlertAlways: Scalars['Boolean'];
  courseTakings: Array<CourseTaking>;
  createdAt: Scalars['DateTime'];
  eventInvites: Array<Event>;
  events: Array<Event>;
  font?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  isCommunity: Scalars['Boolean'];
  isParent: Scalars['Boolean'];
  isVisible: Scalars['Boolean'];
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password: Scalars['String'];
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<Person>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['DateTime'];
  userLearningSettings?: Maybe<UserLearningSettings>;
  userLearningSettingsId?: Maybe<Scalars['Int']>;
  username: Scalars['String'];
  userTheme?: Maybe<Scalars['String']>;
};

export type UserCourseTakingsArgs = {
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<CourseTakingWhereInput>;
};

export type UserEventInvitesArgs = {
  after?: Maybe<EventWhereUniqueInput>;
  before?: Maybe<EventWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventWhereInput>;
};

export type UserEventsArgs = {
  after?: Maybe<EventWhereUniqueInput>;
  before?: Maybe<EventWhereUniqueInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<EventOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  where?: Maybe<EventWhereInput>;
};

export type UserCreateInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventCreateManyWithoutUsersInput>;
  events?: Maybe<EventCreateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonCreateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsCreateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserCreateManyWithoutEventInvitesInput = {
  connect?: Maybe<Array<UserWhereUniqueInput>>;
  create?: Maybe<Array<UserCreateWithoutEventInvitesInput>>;
};

export type UserCreateOneWithoutCourseTakingsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutCourseTakingsInput>;
};

export type UserCreateOneWithoutEventsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutEventsInput>;
};

export type UserCreateOneWithoutPersonInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutPersonInput>;
};

export type UserCreateOneWithoutUserLearningSettingsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutUserLearningSettingsInput>;
};

export type UserCreateWithoutCourseTakingsInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventCreateManyWithoutUsersInput>;
  events?: Maybe<EventCreateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonCreateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsCreateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserCreateWithoutEventInvitesInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  events?: Maybe<EventCreateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonCreateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsCreateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserCreateWithoutEventsInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventCreateManyWithoutUsersInput>;
  font?: Maybe<Scalars['String']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonCreateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsCreateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserCreateWithoutPersonInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventCreateManyWithoutUsersInput>;
  events?: Maybe<EventCreateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsCreateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserCreateWithoutUserLearningSettingsInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingCreateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventCreateManyWithoutUsersInput>;
  events?: Maybe<EventCreateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonCreateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserDetails = {
  __typename?: 'UserDetails';
  parent?: Maybe<Parent>;
  student?: Maybe<Student>;
};

export type UserFilter = {
  every?: Maybe<UserWhereInput>;
  none?: Maybe<UserWhereInput>;
  some?: Maybe<UserWhereInput>;
};

export type UserLearningSettings = {
  __typename?: 'UserLearningSettings';
  createdAt: Scalars['DateTime'];
  hoursPerDay?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  schoolEnd?: Maybe<Scalars['DateTime']>;
  schoolOnFri: Scalars['Boolean'];
  schoolOnMon: Scalars['Boolean'];
  schoolOnSat: Scalars['Boolean'];
  schoolOnSun: Scalars['Boolean'];
  schoolOnThu: Scalars['Boolean'];
  schoolOnTue: Scalars['Boolean'];
  schoolOnWed: Scalars['Boolean'];
  schoolStart?: Maybe<Scalars['DateTime']>;
  univPwd?: Maybe<Scalars['String']>;
  univPwdWholeFamily: Scalars['Boolean'];
  updatedAt: Scalars['DateTime'];
  user?: Maybe<User>;
};

export type UserLearningSettingsCreateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  hoursPerDay?: Maybe<Scalars['Int']>;
  schoolEnd?: Maybe<Scalars['DateTime']>;
  schoolOnFri?: Maybe<Scalars['Boolean']>;
  schoolOnMon?: Maybe<Scalars['Boolean']>;
  schoolOnSat?: Maybe<Scalars['Boolean']>;
  schoolOnSun?: Maybe<Scalars['Boolean']>;
  schoolOnThu?: Maybe<Scalars['Boolean']>;
  schoolOnTue?: Maybe<Scalars['Boolean']>;
  schoolOnWed?: Maybe<Scalars['Boolean']>;
  schoolStart?: Maybe<Scalars['DateTime']>;
  univPwd?: Maybe<Scalars['String']>;
  univPwdWholeFamily?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<UserCreateOneWithoutUserLearningSettingsInput>;
};

export type UserLearningSettingsCreateOneWithoutUserInput = {
  connect?: Maybe<UserLearningSettingsWhereUniqueInput>;
  create?: Maybe<UserLearningSettingsCreateWithoutUserInput>;
};

export type UserLearningSettingsCreateWithoutUserInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  hoursPerDay?: Maybe<Scalars['Int']>;
  schoolEnd?: Maybe<Scalars['DateTime']>;
  schoolOnFri?: Maybe<Scalars['Boolean']>;
  schoolOnMon?: Maybe<Scalars['Boolean']>;
  schoolOnSat?: Maybe<Scalars['Boolean']>;
  schoolOnSun?: Maybe<Scalars['Boolean']>;
  schoolOnThu?: Maybe<Scalars['Boolean']>;
  schoolOnTue?: Maybe<Scalars['Boolean']>;
  schoolOnWed?: Maybe<Scalars['Boolean']>;
  schoolStart?: Maybe<Scalars['DateTime']>;
  univPwd?: Maybe<Scalars['String']>;
  univPwdWholeFamily?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserLearningSettingsOrderByInput = {
  createdAt?: Maybe<OrderByArg>;
  hoursPerDay?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  schoolEnd?: Maybe<OrderByArg>;
  schoolOnFri?: Maybe<OrderByArg>;
  schoolOnMon?: Maybe<OrderByArg>;
  schoolOnSat?: Maybe<OrderByArg>;
  schoolOnSun?: Maybe<OrderByArg>;
  schoolOnThu?: Maybe<OrderByArg>;
  schoolOnTue?: Maybe<OrderByArg>;
  schoolOnWed?: Maybe<OrderByArg>;
  schoolStart?: Maybe<OrderByArg>;
  univPwd?: Maybe<OrderByArg>;
  univPwdWholeFamily?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
};

export type UserLearningSettingsUpdateInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  hoursPerDay?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  schoolEnd?: Maybe<Scalars['DateTime']>;
  schoolOnFri?: Maybe<Scalars['Boolean']>;
  schoolOnMon?: Maybe<Scalars['Boolean']>;
  schoolOnSat?: Maybe<Scalars['Boolean']>;
  schoolOnSun?: Maybe<Scalars['Boolean']>;
  schoolOnThu?: Maybe<Scalars['Boolean']>;
  schoolOnTue?: Maybe<Scalars['Boolean']>;
  schoolOnWed?: Maybe<Scalars['Boolean']>;
  schoolStart?: Maybe<Scalars['DateTime']>;
  univPwd?: Maybe<Scalars['String']>;
  univPwdWholeFamily?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<UserUpdateOneWithoutUserLearningSettingsInput>;
};

export type UserLearningSettingsUpdateManyMutationInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  hoursPerDay?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  schoolEnd?: Maybe<Scalars['DateTime']>;
  schoolOnFri?: Maybe<Scalars['Boolean']>;
  schoolOnMon?: Maybe<Scalars['Boolean']>;
  schoolOnSat?: Maybe<Scalars['Boolean']>;
  schoolOnSun?: Maybe<Scalars['Boolean']>;
  schoolOnThu?: Maybe<Scalars['Boolean']>;
  schoolOnTue?: Maybe<Scalars['Boolean']>;
  schoolOnWed?: Maybe<Scalars['Boolean']>;
  schoolStart?: Maybe<Scalars['DateTime']>;
  univPwd?: Maybe<Scalars['String']>;
  univPwdWholeFamily?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserLearningSettingsUpdateOneWithoutUserInput = {
  connect?: Maybe<UserLearningSettingsWhereUniqueInput>;
  create?: Maybe<UserLearningSettingsCreateWithoutUserInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<UserLearningSettingsUpdateWithoutUserDataInput>;
  upsert?: Maybe<UserLearningSettingsUpsertWithoutUserInput>;
};

export type UserLearningSettingsUpdateWithoutUserDataInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  hoursPerDay?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  schoolEnd?: Maybe<Scalars['DateTime']>;
  schoolOnFri?: Maybe<Scalars['Boolean']>;
  schoolOnMon?: Maybe<Scalars['Boolean']>;
  schoolOnSat?: Maybe<Scalars['Boolean']>;
  schoolOnSun?: Maybe<Scalars['Boolean']>;
  schoolOnThu?: Maybe<Scalars['Boolean']>;
  schoolOnTue?: Maybe<Scalars['Boolean']>;
  schoolOnWed?: Maybe<Scalars['Boolean']>;
  schoolStart?: Maybe<Scalars['DateTime']>;
  univPwd?: Maybe<Scalars['String']>;
  univPwdWholeFamily?: Maybe<Scalars['Boolean']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserLearningSettingsUpsertWithoutUserInput = {
  create: UserLearningSettingsCreateWithoutUserInput;
  update: UserLearningSettingsUpdateWithoutUserDataInput;
};

export type UserLearningSettingsWhereInput = {
  AND?: Maybe<Array<UserLearningSettingsWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  hoursPerDay?: Maybe<NullableIntFilter>;
  id?: Maybe<IntFilter>;
  NOT?: Maybe<Array<UserLearningSettingsWhereInput>>;
  OR?: Maybe<Array<UserLearningSettingsWhereInput>>;
  schoolEnd?: Maybe<NullableDateTimeFilter>;
  schoolOnFri?: Maybe<BooleanFilter>;
  schoolOnMon?: Maybe<BooleanFilter>;
  schoolOnSat?: Maybe<BooleanFilter>;
  schoolOnSun?: Maybe<BooleanFilter>;
  schoolOnThu?: Maybe<BooleanFilter>;
  schoolOnTue?: Maybe<BooleanFilter>;
  schoolOnWed?: Maybe<BooleanFilter>;
  schoolStart?: Maybe<NullableDateTimeFilter>;
  univPwd?: Maybe<NullableStringFilter>;
  univPwdWholeFamily?: Maybe<BooleanFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  user?: Maybe<UserWhereInput>;
};

export type UserLearningSettingsWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type UserLogin = {
  __typename?: 'UserLogin';
  id: Scalars['Int'];
};

export type UserOrderByInput = {
  avatarLink?: Maybe<OrderByArg>;
  canAccessCommunity?: Maybe<OrderByArg>;
  canAddEventsToCalendar?: Maybe<OrderByArg>;
  canReceiveDirectMessages?: Maybe<OrderByArg>;
  canSeeGrades?: Maybe<OrderByArg>;
  communityPostAlertAlways?: Maybe<OrderByArg>;
  createdAt?: Maybe<OrderByArg>;
  font?: Maybe<OrderByArg>;
  id?: Maybe<OrderByArg>;
  isCommunity?: Maybe<OrderByArg>;
  isParent?: Maybe<OrderByArg>;
  isVisible?: Maybe<OrderByArg>;
  lessonsPerDay?: Maybe<OrderByArg>;
  passResetExpires?: Maybe<OrderByArg>;
  password?: Maybe<OrderByArg>;
  passwordResetToken?: Maybe<OrderByArg>;
  pressAcctNum?: Maybe<OrderByArg>;
  updatedAt?: Maybe<OrderByArg>;
  userLearningSettings?: Maybe<OrderByArg>;
  userLearningSettingsId?: Maybe<OrderByArg>;
  username?: Maybe<OrderByArg>;
  userTheme?: Maybe<OrderByArg>;
};

export type UserScalarWhereInput = {
  AND?: Maybe<Array<UserScalarWhereInput>>;
  avatarLink?: Maybe<NullableStringFilter>;
  canAccessCommunity?: Maybe<BooleanFilter>;
  canAddEventsToCalendar?: Maybe<BooleanFilter>;
  canReceiveDirectMessages?: Maybe<BooleanFilter>;
  canSeeGrades?: Maybe<BooleanFilter>;
  communityPostAlertAlways?: Maybe<BooleanFilter>;
  courseTakings?: Maybe<CourseTakingFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  eventInvites?: Maybe<EventFilter>;
  events?: Maybe<EventFilter>;
  font?: Maybe<NullableStringFilter>;
  id?: Maybe<IntFilter>;
  isCommunity?: Maybe<BooleanFilter>;
  isParent?: Maybe<BooleanFilter>;
  isVisible?: Maybe<BooleanFilter>;
  lessonsPerDay?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<UserScalarWhereInput>>;
  OR?: Maybe<Array<UserScalarWhereInput>>;
  passResetExpires?: Maybe<NullableDateTimeFilter>;
  password?: Maybe<StringFilter>;
  passwordResetToken?: Maybe<NullableStringFilter>;
  pressAcctNum?: Maybe<NullableIntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  userLearningSettingsId?: Maybe<NullableIntFilter>;
  username?: Maybe<StringFilter>;
  userTheme?: Maybe<NullableStringFilter>;
};

export type UserUpdateInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventUpdateManyWithoutUsersInput>;
  events?: Maybe<EventUpdateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonUpdateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsUpdateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateManyDataInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateManyMutationInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateManyWithoutEventInvitesInput = {
  connect?: Maybe<Array<UserWhereUniqueInput>>;
  create?: Maybe<Array<UserCreateWithoutEventInvitesInput>>;
  delete?: Maybe<Array<UserWhereUniqueInput>>;
  deleteMany?: Maybe<Array<UserScalarWhereInput>>;
  disconnect?: Maybe<Array<UserWhereUniqueInput>>;
  set?: Maybe<Array<UserWhereUniqueInput>>;
  update?: Maybe<Array<UserUpdateWithWhereUniqueWithoutEventInvitesInput>>;
  updateMany?: Maybe<Array<UserUpdateManyWithWhereNestedInput>>;
  upsert?: Maybe<Array<UserUpsertWithWhereUniqueWithoutEventInvitesInput>>;
};

export type UserUpdateManyWithWhereNestedInput = {
  data: UserUpdateManyDataInput;
  where: UserScalarWhereInput;
};

export type UserUpdateOneRequiredWithoutEventsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutEventsInput>;
  update?: Maybe<UserUpdateWithoutEventsDataInput>;
  upsert?: Maybe<UserUpsertWithoutEventsInput>;
};

export type UserUpdateOneRequiredWithoutPersonInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutPersonInput>;
  update?: Maybe<UserUpdateWithoutPersonDataInput>;
  upsert?: Maybe<UserUpsertWithoutPersonInput>;
};

export type UserUpdateOneWithoutCourseTakingsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutCourseTakingsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<UserUpdateWithoutCourseTakingsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCourseTakingsInput>;
};

export type UserUpdateOneWithoutUserLearningSettingsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  create?: Maybe<UserCreateWithoutUserLearningSettingsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<UserUpdateWithoutUserLearningSettingsDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserLearningSettingsInput>;
};

export type UserUpdateWithoutCourseTakingsDataInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventUpdateManyWithoutUsersInput>;
  events?: Maybe<EventUpdateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonUpdateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsUpdateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateWithoutEventInvitesDataInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  events?: Maybe<EventUpdateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonUpdateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsUpdateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateWithoutEventsDataInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventUpdateManyWithoutUsersInput>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonUpdateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsUpdateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateWithoutPersonDataInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventUpdateManyWithoutUsersInput>;
  events?: Maybe<EventUpdateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userLearningSettings?: Maybe<UserLearningSettingsUpdateOneWithoutUserInput>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateWithoutUserLearningSettingsDataInput = {
  avatarLink?: Maybe<Scalars['String']>;
  canAccessCommunity?: Maybe<Scalars['Boolean']>;
  canAddEventsToCalendar?: Maybe<Scalars['Boolean']>;
  canReceiveDirectMessages?: Maybe<Scalars['Boolean']>;
  canSeeGrades?: Maybe<Scalars['Boolean']>;
  communityPostAlertAlways?: Maybe<Scalars['Boolean']>;
  courseTakings?: Maybe<CourseTakingUpdateManyWithoutUserInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  eventInvites?: Maybe<EventUpdateManyWithoutUsersInput>;
  events?: Maybe<EventUpdateManyWithoutCreatorInput>;
  font?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  isCommunity?: Maybe<Scalars['Boolean']>;
  isParent?: Maybe<Scalars['Boolean']>;
  isVisible?: Maybe<Scalars['Boolean']>;
  lessonsPerDay?: Maybe<Scalars['Int']>;
  passResetExpires?: Maybe<Scalars['DateTime']>;
  password?: Maybe<Scalars['String']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  person?: Maybe<PersonUpdateOneWithoutUserInput>;
  pressAcctNum?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  username?: Maybe<Scalars['String']>;
  userTheme?: Maybe<Scalars['String']>;
};

export type UserUpdateWithWhereUniqueWithoutEventInvitesInput = {
  data: UserUpdateWithoutEventInvitesDataInput;
  where: UserWhereUniqueInput;
};

export type UserUpsertWithoutCourseTakingsInput = {
  create: UserCreateWithoutCourseTakingsInput;
  update: UserUpdateWithoutCourseTakingsDataInput;
};

export type UserUpsertWithoutEventsInput = {
  create: UserCreateWithoutEventsInput;
  update: UserUpdateWithoutEventsDataInput;
};

export type UserUpsertWithoutPersonInput = {
  create: UserCreateWithoutPersonInput;
  update: UserUpdateWithoutPersonDataInput;
};

export type UserUpsertWithoutUserLearningSettingsInput = {
  create: UserCreateWithoutUserLearningSettingsInput;
  update: UserUpdateWithoutUserLearningSettingsDataInput;
};

export type UserUpsertWithWhereUniqueWithoutEventInvitesInput = {
  create: UserCreateWithoutEventInvitesInput;
  update: UserUpdateWithoutEventInvitesDataInput;
  where: UserWhereUniqueInput;
};

export type UserWhereInput = {
  AND?: Maybe<Array<UserWhereInput>>;
  avatarLink?: Maybe<NullableStringFilter>;
  canAccessCommunity?: Maybe<BooleanFilter>;
  canAddEventsToCalendar?: Maybe<BooleanFilter>;
  canReceiveDirectMessages?: Maybe<BooleanFilter>;
  canSeeGrades?: Maybe<BooleanFilter>;
  communityPostAlertAlways?: Maybe<BooleanFilter>;
  courseTakings?: Maybe<CourseTakingFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  eventInvites?: Maybe<EventFilter>;
  events?: Maybe<EventFilter>;
  font?: Maybe<NullableStringFilter>;
  id?: Maybe<IntFilter>;
  isCommunity?: Maybe<BooleanFilter>;
  isParent?: Maybe<BooleanFilter>;
  isVisible?: Maybe<BooleanFilter>;
  lessonsPerDay?: Maybe<NullableIntFilter>;
  NOT?: Maybe<Array<UserWhereInput>>;
  OR?: Maybe<Array<UserWhereInput>>;
  passResetExpires?: Maybe<NullableDateTimeFilter>;
  password?: Maybe<StringFilter>;
  passwordResetToken?: Maybe<NullableStringFilter>;
  person?: Maybe<PersonWhereInput>;
  pressAcctNum?: Maybe<NullableIntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  userLearningSettings?: Maybe<UserLearningSettingsWhereInput>;
  userLearningSettingsId?: Maybe<NullableIntFilter>;
  username?: Maybe<StringFilter>;
  userTheme?: Maybe<NullableStringFilter>;
};

export type UserWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  passwordResetToken?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

export type VerifyPasswordResetToken = {
  __typename?: 'VerifyPasswordResetToken';
  firstName: Scalars['String'];
  valid: Scalars['Boolean'];
};

export type ActivityFragmentFragment = { __typename?: 'Activity' } & Pick<
  Activity,
  'color' | 'createdAt' | 'day' | 'id' | 'title' | 'updatedAt' | 'personId'
> & { person: { __typename?: 'Person' } & Pick<Person, 'id'> };

export type FindOneActivityQueryVariables = {
  where: ActivityWhereUniqueInput;
};

export type FindOneActivityQuery = { __typename?: 'Query' } & {
  findOneActivity?: Maybe<{ __typename?: 'Activity' } & ActivityFragmentFragment>;
};

export type FindManyActivityQueryVariables = {
  where?: Maybe<ActivityWhereInput>;
  orderBy?: Maybe<ActivityOrderByInput>;
  after?: Maybe<ActivityWhereUniqueInput>;
  before?: Maybe<ActivityWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyActivityQuery = { __typename?: 'Query' } & {
  findManyActivity?: Maybe<Array<{ __typename?: 'Activity' } & ActivityFragmentFragment>>;
};

export type FindManyActivityCountQueryVariables = {
  where?: Maybe<ActivityWhereInput>;
  orderBy?: Maybe<ActivityOrderByInput>;
  after?: Maybe<ActivityWhereUniqueInput>;
  before?: Maybe<ActivityWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyActivityCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyActivityCount'>;

export type CreateOneActivityMutationVariables = {
  data: ActivityCreateInput;
};

export type CreateOneActivityMutation = { __typename?: 'Mutation' } & {
  createOneActivity: { __typename?: 'Activity' } & ActivityFragmentFragment;
};

export type UpdateOneActivityMutationVariables = {
  where: ActivityWhereUniqueInput;
  data: ActivityUpdateInput;
};

export type UpdateOneActivityMutation = { __typename?: 'Mutation' } & {
  updateOneActivity: { __typename?: 'Activity' } & ActivityFragmentFragment;
};

export type DeleteOneActivityMutationVariables = {
  where: ActivityWhereUniqueInput;
};

export type DeleteOneActivityMutation = { __typename?: 'Mutation' } & {
  deleteOneActivity?: Maybe<{ __typename?: 'Activity' } & Pick<Activity, 'id'>>;
};

export type DeleteManyActivityMutationVariables = {
  where?: Maybe<ActivityWhereInput>;
};

export type DeleteManyActivityMutation = { __typename?: 'Mutation' } & {
  deleteManyActivity: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyActivityMutationVariables = {
  where?: Maybe<ActivityWhereInput>;
  data: ActivityUpdateManyMutationInput;
};

export type UpdateManyActivityMutation = { __typename?: 'Mutation' } & {
  updateManyActivity: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssessmentContentQuestionFragmentFragment = { __typename?: 'AssessmentContentQuestion' } & Pick<
  AssessmentContentQuestion,
  | 'ccAQTXId'
  | 'ccAXId'
  | 'ccXId'
  | 'courseCodeXId'
  | 'createdAt'
  | 'feedback'
  | 'id'
  | 'isAllOrNothing'
  | 'isInactive'
  | 'isOrLogic'
  | 'maxScore'
  | 'order'
  | 'text'
  | 'updatedAt'
  | 'assessmentContentQuestionTypeId'
  | 'assignmentContentId'
> & {
    assessmentContentQuestionType?: Maybe<
      { __typename?: 'AssessmentContentQuestionType' } & Pick<AssessmentContentQuestionType, 'id'>
    >;
    assignmentContent?: Maybe<{ __typename?: 'AssignmentContent' } & Pick<AssignmentContent, 'id'>>;
  };

export type FindOneAssessmentContentQuestionQueryVariables = {
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type FindOneAssessmentContentQuestionQuery = { __typename?: 'Query' } & {
  findOneAssessmentContentQuestion?: Maybe<
    { __typename?: 'AssessmentContentQuestion' } & AssessmentContentQuestionFragmentFragment
  >;
};

export type FindManyAssessmentContentQuestionQueryVariables = {
  where?: Maybe<AssessmentContentQuestionWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionOrderByInput>;
  after?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionQuery = { __typename?: 'Query' } & {
  findManyAssessmentContentQuestion?: Maybe<
    Array<{ __typename?: 'AssessmentContentQuestion' } & AssessmentContentQuestionFragmentFragment>
  >;
};

export type FindManyAssessmentContentQuestionCountQueryVariables = {
  where?: Maybe<AssessmentContentQuestionWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionOrderByInput>;
  after?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssessmentContentQuestionCount'
>;

export type CreateOneAssessmentContentQuestionMutationVariables = {
  data: AssessmentContentQuestionCreateInput;
};

export type CreateOneAssessmentContentQuestionMutation = { __typename?: 'Mutation' } & {
  createOneAssessmentContentQuestion: {
    __typename?: 'AssessmentContentQuestion';
  } & AssessmentContentQuestionFragmentFragment;
};

export type UpdateOneAssessmentContentQuestionMutationVariables = {
  where: AssessmentContentQuestionWhereUniqueInput;
  data: AssessmentContentQuestionUpdateInput;
};

export type UpdateOneAssessmentContentQuestionMutation = { __typename?: 'Mutation' } & {
  updateOneAssessmentContentQuestion: {
    __typename?: 'AssessmentContentQuestion';
  } & AssessmentContentQuestionFragmentFragment;
};

export type DeleteOneAssessmentContentQuestionMutationVariables = {
  where: AssessmentContentQuestionWhereUniqueInput;
};

export type DeleteOneAssessmentContentQuestionMutation = { __typename?: 'Mutation' } & {
  deleteOneAssessmentContentQuestion?: Maybe<
    { __typename?: 'AssessmentContentQuestion' } & Pick<AssessmentContentQuestion, 'id'>
  >;
};

export type DeleteManyAssessmentContentQuestionMutationVariables = {
  where?: Maybe<AssessmentContentQuestionWhereInput>;
};

export type DeleteManyAssessmentContentQuestionMutation = { __typename?: 'Mutation' } & {
  deleteManyAssessmentContentQuestion: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssessmentContentQuestionMutationVariables = {
  where?: Maybe<AssessmentContentQuestionWhereInput>;
  data: AssessmentContentQuestionUpdateManyMutationInput;
};

export type UpdateManyAssessmentContentQuestionMutation = { __typename?: 'Mutation' } & {
  updateManyAssessmentContentQuestion: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssessmentContentQuestionAnswerFragmentFragment = { __typename?: 'AssessmentContentQuestionAnswer' } & Pick<
  AssessmentContentQuestionAnswer,
  | 'answer'
  | 'ccQXId'
  | 'ccXId'
  | 'courseCodeXId'
  | 'createdAt'
  | 'id'
  | 'isInactive'
  | 'order'
  | 'updatedAt'
  | 'assessmentContentQuestionId'
> & {
    assessmentContentQuestion?: Maybe<
      { __typename?: 'AssessmentContentQuestion' } & Pick<AssessmentContentQuestion, 'id'>
    >;
  };

export type FindOneAssessmentContentQuestionAnswerQueryVariables = {
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
};

export type FindOneAssessmentContentQuestionAnswerQuery = { __typename?: 'Query' } & {
  findOneAssessmentContentQuestionAnswer?: Maybe<
    { __typename?: 'AssessmentContentQuestionAnswer' } & AssessmentContentQuestionAnswerFragmentFragment
  >;
};

export type FindManyAssessmentContentQuestionAnswerQueryVariables = {
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionAnswerOrderByInput>;
  after?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionAnswerQuery = { __typename?: 'Query' } & {
  findManyAssessmentContentQuestionAnswer?: Maybe<
    Array<{ __typename?: 'AssessmentContentQuestionAnswer' } & AssessmentContentQuestionAnswerFragmentFragment>
  >;
};

export type FindManyAssessmentContentQuestionAnswerCountQueryVariables = {
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionAnswerOrderByInput>;
  after?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionAnswerWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionAnswerCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssessmentContentQuestionAnswerCount'
>;

export type CreateOneAssessmentContentQuestionAnswerMutationVariables = {
  data: AssessmentContentQuestionAnswerCreateInput;
};

export type CreateOneAssessmentContentQuestionAnswerMutation = { __typename?: 'Mutation' } & {
  createOneAssessmentContentQuestionAnswer: {
    __typename?: 'AssessmentContentQuestionAnswer';
  } & AssessmentContentQuestionAnswerFragmentFragment;
};

export type UpdateOneAssessmentContentQuestionAnswerMutationVariables = {
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
  data: AssessmentContentQuestionAnswerUpdateInput;
};

export type UpdateOneAssessmentContentQuestionAnswerMutation = { __typename?: 'Mutation' } & {
  updateOneAssessmentContentQuestionAnswer: {
    __typename?: 'AssessmentContentQuestionAnswer';
  } & AssessmentContentQuestionAnswerFragmentFragment;
};

export type DeleteOneAssessmentContentQuestionAnswerMutationVariables = {
  where: AssessmentContentQuestionAnswerWhereUniqueInput;
};

export type DeleteOneAssessmentContentQuestionAnswerMutation = { __typename?: 'Mutation' } & {
  deleteOneAssessmentContentQuestionAnswer?: Maybe<
    { __typename?: 'AssessmentContentQuestionAnswer' } & Pick<AssessmentContentQuestionAnswer, 'id'>
  >;
};

export type DeleteManyAssessmentContentQuestionAnswerMutationVariables = {
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
};

export type DeleteManyAssessmentContentQuestionAnswerMutation = { __typename?: 'Mutation' } & {
  deleteManyAssessmentContentQuestionAnswer: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssessmentContentQuestionAnswerMutationVariables = {
  where?: Maybe<AssessmentContentQuestionAnswerWhereInput>;
  data: AssessmentContentQuestionAnswerUpdateManyMutationInput;
};

export type UpdateManyAssessmentContentQuestionAnswerMutation = { __typename?: 'Mutation' } & {
  updateManyAssessmentContentQuestionAnswer: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssessmentContentQuestionOptionFragmentFragment = { __typename?: 'AssessmentContentQuestionOption' } & Pick<
  AssessmentContentQuestionOption,
  | 'ccQAXId'
  | 'ccQXId'
  | 'ccXId'
  | 'courseCodeXId'
  | 'createdAt'
  | 'id'
  | 'isInactive'
  | 'order'
  | 'score'
  | 'text'
  | 'updatedAt'
  | 'assessmentContentQuestionId'
  | 'assessmentContentQuestionAnswerId'
> & {
    assessmentContentQuestion?: Maybe<
      { __typename?: 'AssessmentContentQuestion' } & Pick<AssessmentContentQuestion, 'id'>
    >;
    assessmentContentQuestionAnswer?: Maybe<
      { __typename?: 'AssessmentContentQuestionAnswer' } & Pick<AssessmentContentQuestionAnswer, 'id'>
    >;
  };

export type FindOneAssessmentContentQuestionOptionQueryVariables = {
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type FindOneAssessmentContentQuestionOptionQuery = { __typename?: 'Query' } & {
  findOneAssessmentContentQuestionOption?: Maybe<
    { __typename?: 'AssessmentContentQuestionOption' } & AssessmentContentQuestionOptionFragmentFragment
  >;
};

export type FindManyAssessmentContentQuestionOptionQueryVariables = {
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionOptionOrderByInput>;
  after?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionOptionQuery = { __typename?: 'Query' } & {
  findManyAssessmentContentQuestionOption?: Maybe<
    Array<{ __typename?: 'AssessmentContentQuestionOption' } & AssessmentContentQuestionOptionFragmentFragment>
  >;
};

export type FindManyAssessmentContentQuestionOptionCountQueryVariables = {
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionOptionOrderByInput>;
  after?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionOptionWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionOptionCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssessmentContentQuestionOptionCount'
>;

export type CreateOneAssessmentContentQuestionOptionMutationVariables = {
  data: AssessmentContentQuestionOptionCreateInput;
};

export type CreateOneAssessmentContentQuestionOptionMutation = { __typename?: 'Mutation' } & {
  createOneAssessmentContentQuestionOption: {
    __typename?: 'AssessmentContentQuestionOption';
  } & AssessmentContentQuestionOptionFragmentFragment;
};

export type UpdateOneAssessmentContentQuestionOptionMutationVariables = {
  where: AssessmentContentQuestionOptionWhereUniqueInput;
  data: AssessmentContentQuestionOptionUpdateInput;
};

export type UpdateOneAssessmentContentQuestionOptionMutation = { __typename?: 'Mutation' } & {
  updateOneAssessmentContentQuestionOption: {
    __typename?: 'AssessmentContentQuestionOption';
  } & AssessmentContentQuestionOptionFragmentFragment;
};

export type DeleteOneAssessmentContentQuestionOptionMutationVariables = {
  where: AssessmentContentQuestionOptionWhereUniqueInput;
};

export type DeleteOneAssessmentContentQuestionOptionMutation = { __typename?: 'Mutation' } & {
  deleteOneAssessmentContentQuestionOption?: Maybe<
    { __typename?: 'AssessmentContentQuestionOption' } & Pick<AssessmentContentQuestionOption, 'id'>
  >;
};

export type DeleteManyAssessmentContentQuestionOptionMutationVariables = {
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
};

export type DeleteManyAssessmentContentQuestionOptionMutation = { __typename?: 'Mutation' } & {
  deleteManyAssessmentContentQuestionOption: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssessmentContentQuestionOptionMutationVariables = {
  where?: Maybe<AssessmentContentQuestionOptionWhereInput>;
  data: AssessmentContentQuestionOptionUpdateManyMutationInput;
};

export type UpdateManyAssessmentContentQuestionOptionMutation = { __typename?: 'Mutation' } & {
  updateManyAssessmentContentQuestionOption: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssessmentContentQuestionToolFragmentFragment = { __typename?: 'AssessmentContentQuestionTool' } & Pick<
  AssessmentContentQuestionTool,
  'createdAt' | 'id' | 'order' | 'textDisplay' | 'textValue' | 'updatedAt' | 'assessmentContentQuestionId'
> & {
    assessmentContentQuestion?: Maybe<
      { __typename?: 'AssessmentContentQuestion' } & Pick<AssessmentContentQuestion, 'id'>
    >;
  };

export type FindOneAssessmentContentQuestionToolQueryVariables = {
  where: AssessmentContentQuestionToolWhereUniqueInput;
};

export type FindOneAssessmentContentQuestionToolQuery = { __typename?: 'Query' } & {
  findOneAssessmentContentQuestionTool?: Maybe<
    { __typename?: 'AssessmentContentQuestionTool' } & AssessmentContentQuestionToolFragmentFragment
  >;
};

export type FindManyAssessmentContentQuestionToolQueryVariables = {
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionToolOrderByInput>;
  after?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionToolQuery = { __typename?: 'Query' } & {
  findManyAssessmentContentQuestionTool?: Maybe<
    Array<{ __typename?: 'AssessmentContentQuestionTool' } & AssessmentContentQuestionToolFragmentFragment>
  >;
};

export type FindManyAssessmentContentQuestionToolCountQueryVariables = {
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionToolOrderByInput>;
  after?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionToolWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionToolCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssessmentContentQuestionToolCount'
>;

export type CreateOneAssessmentContentQuestionToolMutationVariables = {
  data: AssessmentContentQuestionToolCreateInput;
};

export type CreateOneAssessmentContentQuestionToolMutation = { __typename?: 'Mutation' } & {
  createOneAssessmentContentQuestionTool: {
    __typename?: 'AssessmentContentQuestionTool';
  } & AssessmentContentQuestionToolFragmentFragment;
};

export type UpdateOneAssessmentContentQuestionToolMutationVariables = {
  where: AssessmentContentQuestionToolWhereUniqueInput;
  data: AssessmentContentQuestionToolUpdateInput;
};

export type UpdateOneAssessmentContentQuestionToolMutation = { __typename?: 'Mutation' } & {
  updateOneAssessmentContentQuestionTool: {
    __typename?: 'AssessmentContentQuestionTool';
  } & AssessmentContentQuestionToolFragmentFragment;
};

export type DeleteOneAssessmentContentQuestionToolMutationVariables = {
  where: AssessmentContentQuestionToolWhereUniqueInput;
};

export type DeleteOneAssessmentContentQuestionToolMutation = { __typename?: 'Mutation' } & {
  deleteOneAssessmentContentQuestionTool?: Maybe<
    { __typename?: 'AssessmentContentQuestionTool' } & Pick<AssessmentContentQuestionTool, 'id'>
  >;
};

export type DeleteManyAssessmentContentQuestionToolMutationVariables = {
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
};

export type DeleteManyAssessmentContentQuestionToolMutation = { __typename?: 'Mutation' } & {
  deleteManyAssessmentContentQuestionTool: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssessmentContentQuestionToolMutationVariables = {
  where?: Maybe<AssessmentContentQuestionToolWhereInput>;
  data: AssessmentContentQuestionToolUpdateManyMutationInput;
};

export type UpdateManyAssessmentContentQuestionToolMutation = { __typename?: 'Mutation' } & {
  updateManyAssessmentContentQuestionTool: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssessmentContentQuestionTypeFragmentFragment = { __typename?: 'AssessmentContentQuestionType' } & Pick<
  AssessmentContentQuestionType,
  'code' | 'createdAt' | 'description' | 'id' | 'manualGrade' | 'updatedAt'
>;

export type FindOneAssessmentContentQuestionTypeQueryVariables = {
  where: AssessmentContentQuestionTypeWhereUniqueInput;
};

export type FindOneAssessmentContentQuestionTypeQuery = { __typename?: 'Query' } & {
  findOneAssessmentContentQuestionType?: Maybe<
    { __typename?: 'AssessmentContentQuestionType' } & AssessmentContentQuestionTypeFragmentFragment
  >;
};

export type FindManyAssessmentContentQuestionTypeQueryVariables = {
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionTypeOrderByInput>;
  after?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionTypeQuery = { __typename?: 'Query' } & {
  findManyAssessmentContentQuestionType?: Maybe<
    Array<{ __typename?: 'AssessmentContentQuestionType' } & AssessmentContentQuestionTypeFragmentFragment>
  >;
};

export type FindManyAssessmentContentQuestionTypeCountQueryVariables = {
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
  orderBy?: Maybe<AssessmentContentQuestionTypeOrderByInput>;
  after?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  before?: Maybe<AssessmentContentQuestionTypeWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentContentQuestionTypeCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssessmentContentQuestionTypeCount'
>;

export type CreateOneAssessmentContentQuestionTypeMutationVariables = {
  data: AssessmentContentQuestionTypeCreateInput;
};

export type CreateOneAssessmentContentQuestionTypeMutation = { __typename?: 'Mutation' } & {
  createOneAssessmentContentQuestionType: {
    __typename?: 'AssessmentContentQuestionType';
  } & AssessmentContentQuestionTypeFragmentFragment;
};

export type UpdateOneAssessmentContentQuestionTypeMutationVariables = {
  where: AssessmentContentQuestionTypeWhereUniqueInput;
  data: AssessmentContentQuestionTypeUpdateInput;
};

export type UpdateOneAssessmentContentQuestionTypeMutation = { __typename?: 'Mutation' } & {
  updateOneAssessmentContentQuestionType: {
    __typename?: 'AssessmentContentQuestionType';
  } & AssessmentContentQuestionTypeFragmentFragment;
};

export type DeleteOneAssessmentContentQuestionTypeMutationVariables = {
  where: AssessmentContentQuestionTypeWhereUniqueInput;
};

export type DeleteOneAssessmentContentQuestionTypeMutation = { __typename?: 'Mutation' } & {
  deleteOneAssessmentContentQuestionType?: Maybe<
    { __typename?: 'AssessmentContentQuestionType' } & Pick<AssessmentContentQuestionType, 'id'>
  >;
};

export type DeleteManyAssessmentContentQuestionTypeMutationVariables = {
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
};

export type DeleteManyAssessmentContentQuestionTypeMutation = { __typename?: 'Mutation' } & {
  deleteManyAssessmentContentQuestionType: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssessmentContentQuestionTypeMutationVariables = {
  where?: Maybe<AssessmentContentQuestionTypeWhereInput>;
  data: AssessmentContentQuestionTypeUpdateManyMutationInput;
};

export type UpdateManyAssessmentContentQuestionTypeMutation = { __typename?: 'Mutation' } & {
  updateManyAssessmentContentQuestionType: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssessmentTakingQuestionFragmentFragment = { __typename?: 'AssessmentTakingQuestion' } & Pick<
  AssessmentTakingQuestion,
  | 'createdAt'
  | 'id'
  | 'isCorrectOverride'
  | 'parentComment'
  | 'scoreOverride'
  | 'updatedAt'
  | 'assessmentContentQuestionId'
  | 'assignmentTakingId'
> & {
    assessmentContentQuestion?: Maybe<
      { __typename?: 'AssessmentContentQuestion' } & Pick<AssessmentContentQuestion, 'id'>
    >;
    assignmentTaking?: Maybe<{ __typename?: 'AssignmentTaking' } & Pick<AssignmentTaking, 'id'>>;
  };

export type FindOneAssessmentTakingQuestionQueryVariables = {
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type FindOneAssessmentTakingQuestionQuery = { __typename?: 'Query' } & {
  findOneAssessmentTakingQuestion?: Maybe<
    { __typename?: 'AssessmentTakingQuestion' } & AssessmentTakingQuestionFragmentFragment
  >;
};

export type FindManyAssessmentTakingQuestionQueryVariables = {
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
  orderBy?: Maybe<AssessmentTakingQuestionOrderByInput>;
  after?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentTakingQuestionQuery = { __typename?: 'Query' } & {
  findManyAssessmentTakingQuestion?: Maybe<
    Array<{ __typename?: 'AssessmentTakingQuestion' } & AssessmentTakingQuestionFragmentFragment>
  >;
};

export type FindManyAssessmentTakingQuestionCountQueryVariables = {
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
  orderBy?: Maybe<AssessmentTakingQuestionOrderByInput>;
  after?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  before?: Maybe<AssessmentTakingQuestionWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentTakingQuestionCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssessmentTakingQuestionCount'
>;

export type CreateOneAssessmentTakingQuestionMutationVariables = {
  data: AssessmentTakingQuestionCreateInput;
};

export type CreateOneAssessmentTakingQuestionMutation = { __typename?: 'Mutation' } & {
  createOneAssessmentTakingQuestion: {
    __typename?: 'AssessmentTakingQuestion';
  } & AssessmentTakingQuestionFragmentFragment;
};

export type UpdateOneAssessmentTakingQuestionMutationVariables = {
  where: AssessmentTakingQuestionWhereUniqueInput;
  data: AssessmentTakingQuestionUpdateInput;
};

export type UpdateOneAssessmentTakingQuestionMutation = { __typename?: 'Mutation' } & {
  updateOneAssessmentTakingQuestion: {
    __typename?: 'AssessmentTakingQuestion';
  } & AssessmentTakingQuestionFragmentFragment;
};

export type DeleteOneAssessmentTakingQuestionMutationVariables = {
  where: AssessmentTakingQuestionWhereUniqueInput;
};

export type DeleteOneAssessmentTakingQuestionMutation = { __typename?: 'Mutation' } & {
  deleteOneAssessmentTakingQuestion?: Maybe<
    { __typename?: 'AssessmentTakingQuestion' } & Pick<AssessmentTakingQuestion, 'id'>
  >;
};

export type DeleteManyAssessmentTakingQuestionMutationVariables = {
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
};

export type DeleteManyAssessmentTakingQuestionMutation = { __typename?: 'Mutation' } & {
  deleteManyAssessmentTakingQuestion: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssessmentTakingQuestionMutationVariables = {
  where?: Maybe<AssessmentTakingQuestionWhereInput>;
  data: AssessmentTakingQuestionUpdateManyMutationInput;
};

export type UpdateManyAssessmentTakingQuestionMutation = { __typename?: 'Mutation' } & {
  updateManyAssessmentTakingQuestion: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssessmentTakingResponseFragmentFragment = { __typename?: 'AssessmentTakingResponse' } & Pick<
  AssessmentTakingResponse,
  | 'createdAt'
  | 'id'
  | 'isCorrect'
  | 'textAnswer'
  | 'updatedAt'
  | 'assessmentContentQuestionAnswerId'
  | 'assessmentContentQuestionOptionId'
  | 'assessmentTakingQuestionId'
> & {
    assessmentContentQuestionAnswer?: Maybe<
      { __typename?: 'AssessmentContentQuestionAnswer' } & Pick<AssessmentContentQuestionAnswer, 'id'>
    >;
    assessmentContentQuestionOption?: Maybe<
      { __typename?: 'AssessmentContentQuestionOption' } & Pick<AssessmentContentQuestionOption, 'id'>
    >;
    assessmentTakingQuestion?: Maybe<
      { __typename?: 'AssessmentTakingQuestion' } & Pick<AssessmentTakingQuestion, 'id'>
    >;
  };

export type FindOneAssessmentTakingResponseQueryVariables = {
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type FindOneAssessmentTakingResponseQuery = { __typename?: 'Query' } & {
  findOneAssessmentTakingResponse?: Maybe<
    { __typename?: 'AssessmentTakingResponse' } & AssessmentTakingResponseFragmentFragment
  >;
};

export type FindManyAssessmentTakingResponseQueryVariables = {
  where?: Maybe<AssessmentTakingResponseWhereInput>;
  orderBy?: Maybe<AssessmentTakingResponseOrderByInput>;
  after?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  before?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentTakingResponseQuery = { __typename?: 'Query' } & {
  findManyAssessmentTakingResponse?: Maybe<
    Array<{ __typename?: 'AssessmentTakingResponse' } & AssessmentTakingResponseFragmentFragment>
  >;
};

export type FindManyAssessmentTakingResponseCountQueryVariables = {
  where?: Maybe<AssessmentTakingResponseWhereInput>;
  orderBy?: Maybe<AssessmentTakingResponseOrderByInput>;
  after?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  before?: Maybe<AssessmentTakingResponseWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssessmentTakingResponseCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssessmentTakingResponseCount'
>;

export type CreateOneAssessmentTakingResponseMutationVariables = {
  data: AssessmentTakingResponseCreateInput;
};

export type CreateOneAssessmentTakingResponseMutation = { __typename?: 'Mutation' } & {
  createOneAssessmentTakingResponse: {
    __typename?: 'AssessmentTakingResponse';
  } & AssessmentTakingResponseFragmentFragment;
};

export type UpdateOneAssessmentTakingResponseMutationVariables = {
  where: AssessmentTakingResponseWhereUniqueInput;
  data: AssessmentTakingResponseUpdateInput;
};

export type UpdateOneAssessmentTakingResponseMutation = { __typename?: 'Mutation' } & {
  updateOneAssessmentTakingResponse: {
    __typename?: 'AssessmentTakingResponse';
  } & AssessmentTakingResponseFragmentFragment;
};

export type DeleteOneAssessmentTakingResponseMutationVariables = {
  where: AssessmentTakingResponseWhereUniqueInput;
};

export type DeleteOneAssessmentTakingResponseMutation = { __typename?: 'Mutation' } & {
  deleteOneAssessmentTakingResponse?: Maybe<
    { __typename?: 'AssessmentTakingResponse' } & Pick<AssessmentTakingResponse, 'id'>
  >;
};

export type DeleteManyAssessmentTakingResponseMutationVariables = {
  where?: Maybe<AssessmentTakingResponseWhereInput>;
};

export type DeleteManyAssessmentTakingResponseMutation = { __typename?: 'Mutation' } & {
  deleteManyAssessmentTakingResponse: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssessmentTakingResponseMutationVariables = {
  where?: Maybe<AssessmentTakingResponseWhereInput>;
  data: AssessmentTakingResponseUpdateManyMutationInput;
};

export type UpdateManyAssessmentTakingResponseMutation = { __typename?: 'Mutation' } & {
  updateManyAssessmentTakingResponse: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssignmentContentFragmentFragment = { __typename?: 'AssignmentContent' } & Pick<
  AssignmentContent,
  | 'canBeRetaken'
  | 'ccXId'
  | 'courseCodeXId'
  | 'createdAt'
  | 'feedbackType'
  | 'hasParentResource'
  | 'hasStudentResource'
  | 'id'
  | 'isAssessment'
  | 'isCounted'
  | 'isGradeable'
  | 'isOptional'
  | 'isVideo'
  | 'label'
  | 'lessonDayXId'
  | 'link'
  | 'order'
  | 'parentInstructions'
  | 'parentLink'
  | 'parentLinkLabel'
  | 'studentLink'
  | 'studentLinkLabel'
  | 'title'
  | 'totalPoints'
  | 'type'
  | 'typeLabel'
  | 'updatedAt'
  | 'courseContentId'
  | 'lessonContentId'
> & {
    courseContent?: Maybe<{ __typename?: 'CourseContent' } & Pick<CourseContent, 'id'>>;
    lessonContent?: Maybe<{ __typename?: 'LessonContent' } & Pick<LessonContent, 'id'>>;
  };

export type FindOneAssignmentContentQueryVariables = {
  where: AssignmentContentWhereUniqueInput;
};

export type FindOneAssignmentContentQuery = { __typename?: 'Query' } & {
  findOneAssignmentContent?: Maybe<{ __typename?: 'AssignmentContent' } & AssignmentContentFragmentFragment>;
};

export type FindManyAssignmentContentQueryVariables = {
  where?: Maybe<AssignmentContentWhereInput>;
  orderBy?: Maybe<AssignmentContentOrderByInput>;
  after?: Maybe<AssignmentContentWhereUniqueInput>;
  before?: Maybe<AssignmentContentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssignmentContentQuery = { __typename?: 'Query' } & {
  findManyAssignmentContent?: Maybe<Array<{ __typename?: 'AssignmentContent' } & AssignmentContentFragmentFragment>>;
};

export type FindManyAssignmentContentCountQueryVariables = {
  where?: Maybe<AssignmentContentWhereInput>;
  orderBy?: Maybe<AssignmentContentOrderByInput>;
  after?: Maybe<AssignmentContentWhereUniqueInput>;
  before?: Maybe<AssignmentContentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssignmentContentCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssignmentContentCount'
>;

export type CreateOneAssignmentContentMutationVariables = {
  data: AssignmentContentCreateInput;
};

export type CreateOneAssignmentContentMutation = { __typename?: 'Mutation' } & {
  createOneAssignmentContent: { __typename?: 'AssignmentContent' } & AssignmentContentFragmentFragment;
};

export type UpdateOneAssignmentContentMutationVariables = {
  where: AssignmentContentWhereUniqueInput;
  data: AssignmentContentUpdateInput;
};

export type UpdateOneAssignmentContentMutation = { __typename?: 'Mutation' } & {
  updateOneAssignmentContent: { __typename?: 'AssignmentContent' } & AssignmentContentFragmentFragment;
};

export type DeleteOneAssignmentContentMutationVariables = {
  where: AssignmentContentWhereUniqueInput;
};

export type DeleteOneAssignmentContentMutation = { __typename?: 'Mutation' } & {
  deleteOneAssignmentContent?: Maybe<{ __typename?: 'AssignmentContent' } & Pick<AssignmentContent, 'id'>>;
};

export type DeleteManyAssignmentContentMutationVariables = {
  where?: Maybe<AssignmentContentWhereInput>;
};

export type DeleteManyAssignmentContentMutation = { __typename?: 'Mutation' } & {
  deleteManyAssignmentContent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssignmentContentMutationVariables = {
  where?: Maybe<AssignmentContentWhereInput>;
  data: AssignmentContentUpdateManyMutationInput;
};

export type UpdateManyAssignmentContentMutation = { __typename?: 'Mutation' } & {
  updateManyAssignmentContent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssignmentTakingFragmentFragment = { __typename?: 'AssignmentTaking' } & Pick<
  AssignmentTaking,
  | 'assignedAt'
  | 'canBeRetaken'
  | 'createdAt'
  | 'dueDateAt'
  | 'hasBeenGraded'
  | 'id'
  | 'isCounted'
  | 'isDone'
  | 'isGradeable'
  | 'isGradeOverride'
  | 'isSkipped'
  | 'maxPoints'
  | 'maxSecondsAllowed'
  | 'numericGrade'
  | 'order'
  | 'parentInstructions'
  | 'requiresReview'
  | 'startedAt'
  | 'submittedAt'
  | 'timeTaken'
  | 'title'
  | 'totalPoints'
  | 'type'
  | 'updatedAt'
  | 'assignmentContentId'
  | 'assignmentTakingWeightId'
  | 'lessonTakingId'
> & {
    assignmentContent?: Maybe<{ __typename?: 'AssignmentContent' } & Pick<AssignmentContent, 'id'>>;
    assignmentTakingWeight?: Maybe<{ __typename?: 'AssignmentTakingWeight' } & Pick<AssignmentTakingWeight, 'id'>>;
    lessonTaking?: Maybe<{ __typename?: 'LessonTaking' } & Pick<LessonTaking, 'id'>>;
  };

export type FindOneAssignmentTakingQueryVariables = {
  where: AssignmentTakingWhereUniqueInput;
};

export type FindOneAssignmentTakingQuery = { __typename?: 'Query' } & {
  findOneAssignmentTaking?: Maybe<{ __typename?: 'AssignmentTaking' } & AssignmentTakingFragmentFragment>;
};

export type FindManyAssignmentTakingQueryVariables = {
  where?: Maybe<AssignmentTakingWhereInput>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  after?: Maybe<AssignmentTakingWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssignmentTakingQuery = { __typename?: 'Query' } & {
  findManyAssignmentTaking?: Maybe<Array<{ __typename?: 'AssignmentTaking' } & AssignmentTakingFragmentFragment>>;
};

export type FindManyAssignmentTakingCountQueryVariables = {
  where?: Maybe<AssignmentTakingWhereInput>;
  orderBy?: Maybe<AssignmentTakingOrderByInput>;
  after?: Maybe<AssignmentTakingWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssignmentTakingCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssignmentTakingCount'
>;

export type CreateOneAssignmentTakingMutationVariables = {
  data: AssignmentTakingCreateInput;
};

export type CreateOneAssignmentTakingMutation = { __typename?: 'Mutation' } & {
  createOneAssignmentTaking: { __typename?: 'AssignmentTaking' } & AssignmentTakingFragmentFragment;
};

export type UpdateOneAssignmentTakingMutationVariables = {
  where: AssignmentTakingWhereUniqueInput;
  data: AssignmentTakingUpdateInput;
};

export type UpdateOneAssignmentTakingMutation = { __typename?: 'Mutation' } & {
  updateOneAssignmentTaking: { __typename?: 'AssignmentTaking' } & AssignmentTakingFragmentFragment;
};

export type DeleteOneAssignmentTakingMutationVariables = {
  where: AssignmentTakingWhereUniqueInput;
};

export type DeleteOneAssignmentTakingMutation = { __typename?: 'Mutation' } & {
  deleteOneAssignmentTaking?: Maybe<{ __typename?: 'AssignmentTaking' } & Pick<AssignmentTaking, 'id'>>;
};

export type DeleteManyAssignmentTakingMutationVariables = {
  where?: Maybe<AssignmentTakingWhereInput>;
};

export type DeleteManyAssignmentTakingMutation = { __typename?: 'Mutation' } & {
  deleteManyAssignmentTaking: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssignmentTakingMutationVariables = {
  where?: Maybe<AssignmentTakingWhereInput>;
  data: AssignmentTakingUpdateManyMutationInput;
};

export type UpdateManyAssignmentTakingMutation = { __typename?: 'Mutation' } & {
  updateManyAssignmentTaking: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type AssignmentTakingWeightFragmentFragment = { __typename?: 'AssignmentTakingWeight' } & Pick<
  AssignmentTakingWeight,
  'createdAt' | 'id' | 'updatedAt' | 'weightCategoryId'
> & {
    weightCategory: { __typename?: 'CourseTakingWeightCategory' } & Pick<CourseTakingWeightCategory, 'id'>;
    assignmentTaking?: Maybe<{ __typename?: 'AssignmentTaking' } & Pick<AssignmentTaking, 'id'>>;
  };

export type FindOneAssignmentTakingWeightQueryVariables = {
  where: AssignmentTakingWeightWhereUniqueInput;
};

export type FindOneAssignmentTakingWeightQuery = { __typename?: 'Query' } & {
  findOneAssignmentTakingWeight?: Maybe<
    { __typename?: 'AssignmentTakingWeight' } & AssignmentTakingWeightFragmentFragment
  >;
};

export type FindManyAssignmentTakingWeightQueryVariables = {
  where?: Maybe<AssignmentTakingWeightWhereInput>;
  orderBy?: Maybe<AssignmentTakingWeightOrderByInput>;
  after?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssignmentTakingWeightQuery = { __typename?: 'Query' } & {
  findManyAssignmentTakingWeight?: Maybe<
    Array<{ __typename?: 'AssignmentTakingWeight' } & AssignmentTakingWeightFragmentFragment>
  >;
};

export type FindManyAssignmentTakingWeightCountQueryVariables = {
  where?: Maybe<AssignmentTakingWeightWhereInput>;
  orderBy?: Maybe<AssignmentTakingWeightOrderByInput>;
  after?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  before?: Maybe<AssignmentTakingWeightWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyAssignmentTakingWeightCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyAssignmentTakingWeightCount'
>;

export type CreateOneAssignmentTakingWeightMutationVariables = {
  data: AssignmentTakingWeightCreateInput;
};

export type CreateOneAssignmentTakingWeightMutation = { __typename?: 'Mutation' } & {
  createOneAssignmentTakingWeight: { __typename?: 'AssignmentTakingWeight' } & AssignmentTakingWeightFragmentFragment;
};

export type UpdateOneAssignmentTakingWeightMutationVariables = {
  where: AssignmentTakingWeightWhereUniqueInput;
  data: AssignmentTakingWeightUpdateInput;
};

export type UpdateOneAssignmentTakingWeightMutation = { __typename?: 'Mutation' } & {
  updateOneAssignmentTakingWeight: { __typename?: 'AssignmentTakingWeight' } & AssignmentTakingWeightFragmentFragment;
};

export type DeleteOneAssignmentTakingWeightMutationVariables = {
  where: AssignmentTakingWeightWhereUniqueInput;
};

export type DeleteOneAssignmentTakingWeightMutation = { __typename?: 'Mutation' } & {
  deleteOneAssignmentTakingWeight?: Maybe<
    { __typename?: 'AssignmentTakingWeight' } & Pick<AssignmentTakingWeight, 'id'>
  >;
};

export type DeleteManyAssignmentTakingWeightMutationVariables = {
  where?: Maybe<AssignmentTakingWeightWhereInput>;
};

export type DeleteManyAssignmentTakingWeightMutation = { __typename?: 'Mutation' } & {
  deleteManyAssignmentTakingWeight: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyAssignmentTakingWeightMutationVariables = {
  where?: Maybe<AssignmentTakingWeightWhereInput>;
  data: AssignmentTakingWeightUpdateManyMutationInput;
};

export type UpdateManyAssignmentTakingWeightMutation = { __typename?: 'Mutation' } & {
  updateManyAssignmentTakingWeight: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type BjuPressAccountFragmentFragment = { __typename?: 'BjuPressAccount' } & Pick<
  BjuPressAccount,
  | 'address1'
  | 'address2'
  | 'city'
  | 'country'
  | 'createdAt'
  | 'customerId'
  | 'deleted'
  | 'email'
  | 'enabled'
  | 'firstName'
  | 'hubUserXid'
  | 'id'
  | 'lastName'
  | 'originHub'
  | 'state'
  | 'updatedAt'
  | 'zip'
>;

export type FindOneBjuPressAccountQueryVariables = {
  where: BjuPressAccountWhereUniqueInput;
};

export type FindOneBjuPressAccountQuery = { __typename?: 'Query' } & {
  findOneBjuPressAccount?: Maybe<{ __typename?: 'BjuPressAccount' } & BjuPressAccountFragmentFragment>;
};

export type FindManyBjuPressAccountQueryVariables = {
  where?: Maybe<BjuPressAccountWhereInput>;
  orderBy?: Maybe<BjuPressAccountOrderByInput>;
  after?: Maybe<BjuPressAccountWhereUniqueInput>;
  before?: Maybe<BjuPressAccountWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyBjuPressAccountQuery = { __typename?: 'Query' } & {
  findManyBjuPressAccount?: Maybe<Array<{ __typename?: 'BjuPressAccount' } & BjuPressAccountFragmentFragment>>;
};

export type FindManyBjuPressAccountCountQueryVariables = {
  where?: Maybe<BjuPressAccountWhereInput>;
  orderBy?: Maybe<BjuPressAccountOrderByInput>;
  after?: Maybe<BjuPressAccountWhereUniqueInput>;
  before?: Maybe<BjuPressAccountWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyBjuPressAccountCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyBjuPressAccountCount'>;

export type CreateOneBjuPressAccountMutationVariables = {
  data: BjuPressAccountCreateInput;
};

export type CreateOneBjuPressAccountMutation = { __typename?: 'Mutation' } & {
  createOneBjuPressAccount: { __typename?: 'BjuPressAccount' } & BjuPressAccountFragmentFragment;
};

export type UpdateOneBjuPressAccountMutationVariables = {
  where: BjuPressAccountWhereUniqueInput;
  data: BjuPressAccountUpdateInput;
};

export type UpdateOneBjuPressAccountMutation = { __typename?: 'Mutation' } & {
  updateOneBjuPressAccount: { __typename?: 'BjuPressAccount' } & BjuPressAccountFragmentFragment;
};

export type DeleteOneBjuPressAccountMutationVariables = {
  where: BjuPressAccountWhereUniqueInput;
};

export type DeleteOneBjuPressAccountMutation = { __typename?: 'Mutation' } & {
  deleteOneBjuPressAccount?: Maybe<{ __typename?: 'BjuPressAccount' } & Pick<BjuPressAccount, 'id'>>;
};

export type DeleteManyBjuPressAccountMutationVariables = {
  where?: Maybe<BjuPressAccountWhereInput>;
};

export type DeleteManyBjuPressAccountMutation = { __typename?: 'Mutation' } & {
  deleteManyBjuPressAccount: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyBjuPressAccountMutationVariables = {
  where?: Maybe<BjuPressAccountWhereInput>;
  data: BjuPressAccountUpdateManyMutationInput;
};

export type UpdateManyBjuPressAccountMutation = { __typename?: 'Mutation' } & {
  updateManyBjuPressAccount: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type CourseContentFragmentFragment = { __typename?: 'CourseContent' } & Pick<
  CourseContent,
  | 'courseCode'
  | 'courseType'
  | 'createdAt'
  | 'description'
  | 'edition'
  | 'entitlement'
  | 'grade'
  | 'id'
  | 'imageSource'
  | 'information'
  | 'isInactive'
  | 'label'
  | 'pressContentXId'
  | 'pressXId'
  | 'subject'
  | 'teacherBio'
  | 'textbookSource'
  | 'title'
  | 'update'
  | 'updatedAt'
>;

export type FindOneCourseContentQueryVariables = {
  where: CourseContentWhereUniqueInput;
};

export type FindOneCourseContentQuery = { __typename?: 'Query' } & {
  findOneCourseContent?: Maybe<{ __typename?: 'CourseContent' } & CourseContentFragmentFragment>;
};

export type FindManyCourseContentQueryVariables = {
  where?: Maybe<CourseContentWhereInput>;
  orderBy?: Maybe<CourseContentOrderByInput>;
  after?: Maybe<CourseContentWhereUniqueInput>;
  before?: Maybe<CourseContentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseContentQuery = { __typename?: 'Query' } & {
  findManyCourseContent?: Maybe<Array<{ __typename?: 'CourseContent' } & CourseContentFragmentFragment>>;
};

export type FindManyCourseContentCountQueryVariables = {
  where?: Maybe<CourseContentWhereInput>;
  orderBy?: Maybe<CourseContentOrderByInput>;
  after?: Maybe<CourseContentWhereUniqueInput>;
  before?: Maybe<CourseContentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseContentCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyCourseContentCount'>;

export type CreateOneCourseContentMutationVariables = {
  data: CourseContentCreateInput;
};

export type CreateOneCourseContentMutation = { __typename?: 'Mutation' } & {
  createOneCourseContent: { __typename?: 'CourseContent' } & CourseContentFragmentFragment;
};

export type UpdateOneCourseContentMutationVariables = {
  where: CourseContentWhereUniqueInput;
  data: CourseContentUpdateInput;
};

export type UpdateOneCourseContentMutation = { __typename?: 'Mutation' } & {
  updateOneCourseContent: { __typename?: 'CourseContent' } & CourseContentFragmentFragment;
};

export type DeleteOneCourseContentMutationVariables = {
  where: CourseContentWhereUniqueInput;
};

export type DeleteOneCourseContentMutation = { __typename?: 'Mutation' } & {
  deleteOneCourseContent?: Maybe<{ __typename?: 'CourseContent' } & Pick<CourseContent, 'id'>>;
};

export type DeleteManyCourseContentMutationVariables = {
  where?: Maybe<CourseContentWhereInput>;
};

export type DeleteManyCourseContentMutation = { __typename?: 'Mutation' } & {
  deleteManyCourseContent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyCourseContentMutationVariables = {
  where?: Maybe<CourseContentWhereInput>;
  data: CourseContentUpdateManyMutationInput;
};

export type UpdateManyCourseContentMutation = { __typename?: 'Mutation' } & {
  updateManyCourseContent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type CourseContentCodeFragmentFragment = { __typename?: 'CourseContentCode' } & Pick<
  CourseContentCode,
  'code' | 'createdAt' | 'description' | 'id' | 'type' | 'updatedAt'
>;

export type FindOneCourseContentCodeQueryVariables = {
  where: CourseContentCodeWhereUniqueInput;
};

export type FindOneCourseContentCodeQuery = { __typename?: 'Query' } & {
  findOneCourseContentCode?: Maybe<{ __typename?: 'CourseContentCode' } & CourseContentCodeFragmentFragment>;
};

export type FindManyCourseContentCodeQueryVariables = {
  where?: Maybe<CourseContentCodeWhereInput>;
  orderBy?: Maybe<CourseContentCodeOrderByInput>;
  after?: Maybe<CourseContentCodeWhereUniqueInput>;
  before?: Maybe<CourseContentCodeWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseContentCodeQuery = { __typename?: 'Query' } & {
  findManyCourseContentCode?: Maybe<Array<{ __typename?: 'CourseContentCode' } & CourseContentCodeFragmentFragment>>;
};

export type FindManyCourseContentCodeCountQueryVariables = {
  where?: Maybe<CourseContentCodeWhereInput>;
  orderBy?: Maybe<CourseContentCodeOrderByInput>;
  after?: Maybe<CourseContentCodeWhereUniqueInput>;
  before?: Maybe<CourseContentCodeWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseContentCodeCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyCourseContentCodeCount'
>;

export type CreateOneCourseContentCodeMutationVariables = {
  data: CourseContentCodeCreateInput;
};

export type CreateOneCourseContentCodeMutation = { __typename?: 'Mutation' } & {
  createOneCourseContentCode: { __typename?: 'CourseContentCode' } & CourseContentCodeFragmentFragment;
};

export type UpdateOneCourseContentCodeMutationVariables = {
  where: CourseContentCodeWhereUniqueInput;
  data: CourseContentCodeUpdateInput;
};

export type UpdateOneCourseContentCodeMutation = { __typename?: 'Mutation' } & {
  updateOneCourseContentCode: { __typename?: 'CourseContentCode' } & CourseContentCodeFragmentFragment;
};

export type DeleteOneCourseContentCodeMutationVariables = {
  where: CourseContentCodeWhereUniqueInput;
};

export type DeleteOneCourseContentCodeMutation = { __typename?: 'Mutation' } & {
  deleteOneCourseContentCode?: Maybe<{ __typename?: 'CourseContentCode' } & Pick<CourseContentCode, 'id'>>;
};

export type DeleteManyCourseContentCodeMutationVariables = {
  where?: Maybe<CourseContentCodeWhereInput>;
};

export type DeleteManyCourseContentCodeMutation = { __typename?: 'Mutation' } & {
  deleteManyCourseContentCode: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyCourseContentCodeMutationVariables = {
  where?: Maybe<CourseContentCodeWhereInput>;
  data: CourseContentCodeUpdateManyMutationInput;
};

export type UpdateManyCourseContentCodeMutation = { __typename?: 'Mutation' } & {
  updateManyCourseContentCode: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type CourseContentWeightCategoryFragmentFragment = { __typename?: 'CourseContentWeightCategory' } & Pick<
  CourseContentWeightCategory,
  'assignmentType' | 'createdAt' | 'id' | 'title' | 'updatedAt' | 'weight' | 'courseContentId'
> & { courseContent: { __typename?: 'CourseContent' } & Pick<CourseContent, 'id'> };

export type FindOneCourseContentWeightCategoryQueryVariables = {
  where: CourseContentWeightCategoryWhereUniqueInput;
};

export type FindOneCourseContentWeightCategoryQuery = { __typename?: 'Query' } & {
  findOneCourseContentWeightCategory?: Maybe<
    { __typename?: 'CourseContentWeightCategory' } & CourseContentWeightCategoryFragmentFragment
  >;
};

export type FindManyCourseContentWeightCategoryQueryVariables = {
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
  orderBy?: Maybe<CourseContentWeightCategoryOrderByInput>;
  after?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseContentWeightCategoryQuery = { __typename?: 'Query' } & {
  findManyCourseContentWeightCategory?: Maybe<
    Array<{ __typename?: 'CourseContentWeightCategory' } & CourseContentWeightCategoryFragmentFragment>
  >;
};

export type FindManyCourseContentWeightCategoryCountQueryVariables = {
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
  orderBy?: Maybe<CourseContentWeightCategoryOrderByInput>;
  after?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseContentWeightCategoryWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseContentWeightCategoryCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyCourseContentWeightCategoryCount'
>;

export type CreateOneCourseContentWeightCategoryMutationVariables = {
  data: CourseContentWeightCategoryCreateInput;
};

export type CreateOneCourseContentWeightCategoryMutation = { __typename?: 'Mutation' } & {
  createOneCourseContentWeightCategory: {
    __typename?: 'CourseContentWeightCategory';
  } & CourseContentWeightCategoryFragmentFragment;
};

export type UpdateOneCourseContentWeightCategoryMutationVariables = {
  where: CourseContentWeightCategoryWhereUniqueInput;
  data: CourseContentWeightCategoryUpdateInput;
};

export type UpdateOneCourseContentWeightCategoryMutation = { __typename?: 'Mutation' } & {
  updateOneCourseContentWeightCategory: {
    __typename?: 'CourseContentWeightCategory';
  } & CourseContentWeightCategoryFragmentFragment;
};

export type DeleteOneCourseContentWeightCategoryMutationVariables = {
  where: CourseContentWeightCategoryWhereUniqueInput;
};

export type DeleteOneCourseContentWeightCategoryMutation = { __typename?: 'Mutation' } & {
  deleteOneCourseContentWeightCategory?: Maybe<
    { __typename?: 'CourseContentWeightCategory' } & Pick<CourseContentWeightCategory, 'id'>
  >;
};

export type DeleteManyCourseContentWeightCategoryMutationVariables = {
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
};

export type DeleteManyCourseContentWeightCategoryMutation = { __typename?: 'Mutation' } & {
  deleteManyCourseContentWeightCategory: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyCourseContentWeightCategoryMutationVariables = {
  where?: Maybe<CourseContentWeightCategoryWhereInput>;
  data: CourseContentWeightCategoryUpdateManyMutationInput;
};

export type UpdateManyCourseContentWeightCategoryMutation = { __typename?: 'Mutation' } & {
  updateManyCourseContentWeightCategory: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type CourseTakingFragmentFragment = { __typename?: 'CourseTaking' } & Pick<
  CourseTaking,
  | 'assignedFlag'
  | 'assignedAt'
  | 'bookRedemptionCode'
  | 'courseColor'
  | 'createdAt'
  | 'endDate'
  | 'entitlementEndDate'
  | 'entitlementStartDate'
  | 'fri'
  | 'gradeScale'
  | 'hasOnlineAssessments'
  | 'hasOnlineVideos'
  | 'id'
  | 'lessonsPerDay'
  | 'mon'
  | 'numericGrade'
  | 'order'
  | 'pressXid'
  | 'sat'
  | 'startDate'
  | 'status'
  | 'sun'
  | 'thu'
  | 'tue'
  | 'updatedAt'
  | 'useGradeWeights'
  | 'wed'
  | 'courseContentId'
  | 'parentId'
  | 'studentId'
  | 'userId'
> & {
    courseContent: { __typename?: 'CourseContent' } & Pick<CourseContent, 'id'>;
    parent: { __typename?: 'Parent' } & Pick<Parent, 'id'>;
    student?: Maybe<{ __typename?: 'Student' } & Pick<Student, 'id'>>;
    user?: Maybe<{ __typename?: 'User' } & Pick<User, 'id'>>;
  };

export type FindOneCourseTakingQueryVariables = {
  where: CourseTakingWhereUniqueInput;
};

export type FindOneCourseTakingQuery = { __typename?: 'Query' } & {
  findOneCourseTaking?: Maybe<{ __typename?: 'CourseTaking' } & CourseTakingFragmentFragment>;
};

export type FindManyCourseTakingQueryVariables = {
  where?: Maybe<CourseTakingWhereInput>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseTakingQuery = { __typename?: 'Query' } & {
  findManyCourseTaking?: Maybe<Array<{ __typename?: 'CourseTaking' } & CourseTakingFragmentFragment>>;
};

export type FindManyCourseTakingCountQueryVariables = {
  where?: Maybe<CourseTakingWhereInput>;
  orderBy?: Maybe<CourseTakingOrderByInput>;
  after?: Maybe<CourseTakingWhereUniqueInput>;
  before?: Maybe<CourseTakingWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseTakingCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyCourseTakingCount'>;

export type CreateOneCourseTakingMutationVariables = {
  data: CourseTakingCreateInput;
};

export type CreateOneCourseTakingMutation = { __typename?: 'Mutation' } & {
  createOneCourseTaking: { __typename?: 'CourseTaking' } & CourseTakingFragmentFragment;
};

export type UpdateOneCourseTakingMutationVariables = {
  where: CourseTakingWhereUniqueInput;
  data: CourseTakingUpdateInput;
};

export type UpdateOneCourseTakingMutation = { __typename?: 'Mutation' } & {
  updateOneCourseTaking: { __typename?: 'CourseTaking' } & CourseTakingFragmentFragment;
};

export type DeleteOneCourseTakingMutationVariables = {
  where: CourseTakingWhereUniqueInput;
};

export type DeleteOneCourseTakingMutation = { __typename?: 'Mutation' } & {
  deleteOneCourseTaking?: Maybe<{ __typename?: 'CourseTaking' } & Pick<CourseTaking, 'id'>>;
};

export type DeleteManyCourseTakingMutationVariables = {
  where?: Maybe<CourseTakingWhereInput>;
};

export type DeleteManyCourseTakingMutation = { __typename?: 'Mutation' } & {
  deleteManyCourseTaking: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyCourseTakingMutationVariables = {
  where?: Maybe<CourseTakingWhereInput>;
  data: CourseTakingUpdateManyMutationInput;
};

export type UpdateManyCourseTakingMutation = { __typename?: 'Mutation' } & {
  updateManyCourseTaking: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type CourseTakingWeightCategoryFragmentFragment = { __typename?: 'CourseTakingWeightCategory' } & Pick<
  CourseTakingWeightCategory,
  | 'createdAt'
  | 'id'
  | 'originalTitle'
  | 'originalWeight'
  | 'title'
  | 'updatedAt'
  | 'weight'
  | 'courseContentWeightCategoryId'
  | 'courseTakingId'
> & {
    courseContentWeightCategory?: Maybe<
      { __typename?: 'CourseContentWeightCategory' } & Pick<CourseContentWeightCategory, 'id'>
    >;
    courseTaking?: Maybe<{ __typename?: 'CourseTaking' } & Pick<CourseTaking, 'id'>>;
  };

export type FindOneCourseTakingWeightCategoryQueryVariables = {
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type FindOneCourseTakingWeightCategoryQuery = { __typename?: 'Query' } & {
  findOneCourseTakingWeightCategory?: Maybe<
    { __typename?: 'CourseTakingWeightCategory' } & CourseTakingWeightCategoryFragmentFragment
  >;
};

export type FindManyCourseTakingWeightCategoryQueryVariables = {
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
  orderBy?: Maybe<CourseTakingWeightCategoryOrderByInput>;
  after?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseTakingWeightCategoryQuery = { __typename?: 'Query' } & {
  findManyCourseTakingWeightCategory?: Maybe<
    Array<{ __typename?: 'CourseTakingWeightCategory' } & CourseTakingWeightCategoryFragmentFragment>
  >;
};

export type FindManyCourseTakingWeightCategoryCountQueryVariables = {
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
  orderBy?: Maybe<CourseTakingWeightCategoryOrderByInput>;
  after?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  before?: Maybe<CourseTakingWeightCategoryWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyCourseTakingWeightCategoryCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyCourseTakingWeightCategoryCount'
>;

export type CreateOneCourseTakingWeightCategoryMutationVariables = {
  data: CourseTakingWeightCategoryCreateInput;
};

export type CreateOneCourseTakingWeightCategoryMutation = { __typename?: 'Mutation' } & {
  createOneCourseTakingWeightCategory: {
    __typename?: 'CourseTakingWeightCategory';
  } & CourseTakingWeightCategoryFragmentFragment;
};

export type UpdateOneCourseTakingWeightCategoryMutationVariables = {
  where: CourseTakingWeightCategoryWhereUniqueInput;
  data: CourseTakingWeightCategoryUpdateInput;
};

export type UpdateOneCourseTakingWeightCategoryMutation = { __typename?: 'Mutation' } & {
  updateOneCourseTakingWeightCategory: {
    __typename?: 'CourseTakingWeightCategory';
  } & CourseTakingWeightCategoryFragmentFragment;
};

export type DeleteOneCourseTakingWeightCategoryMutationVariables = {
  where: CourseTakingWeightCategoryWhereUniqueInput;
};

export type DeleteOneCourseTakingWeightCategoryMutation = { __typename?: 'Mutation' } & {
  deleteOneCourseTakingWeightCategory?: Maybe<
    { __typename?: 'CourseTakingWeightCategory' } & Pick<CourseTakingWeightCategory, 'id'>
  >;
};

export type DeleteManyCourseTakingWeightCategoryMutationVariables = {
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
};

export type DeleteManyCourseTakingWeightCategoryMutation = { __typename?: 'Mutation' } & {
  deleteManyCourseTakingWeightCategory: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyCourseTakingWeightCategoryMutationVariables = {
  where?: Maybe<CourseTakingWeightCategoryWhereInput>;
  data: CourseTakingWeightCategoryUpdateManyMutationInput;
};

export type UpdateManyCourseTakingWeightCategoryMutation = { __typename?: 'Mutation' } & {
  updateManyCourseTakingWeightCategory: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type EventFragmentFragment = { __typename?: 'Event' } & Pick<
  Event,
  | 'color'
  | 'createdAt'
  | 'description'
  | 'endDate'
  | 'id'
  | 'isFullDayEvent'
  | 'isRecurring'
  | 'order'
  | 'shiftCoursesFlag'
  | 'startDate'
  | 'title'
  | 'updatedAt'
  | 'creatorId'
  | 'personId'
  | 'recurringPatternId'
> & {
    creator: { __typename?: 'User' } & Pick<User, 'id'>;
    person?: Maybe<{ __typename?: 'Person' } & Pick<Person, 'id'>>;
    recurringPattern?: Maybe<{ __typename?: 'EventRecurringPattern' } & Pick<EventRecurringPattern, 'id'>>;
  };

export type FindOneEventQueryVariables = {
  where: EventWhereUniqueInput;
};

export type FindOneEventQuery = { __typename?: 'Query' } & {
  findOneEvent?: Maybe<{ __typename?: 'Event' } & EventFragmentFragment>;
};

export type FindManyEventQueryVariables = {
  where?: Maybe<EventWhereInput>;
  orderBy?: Maybe<EventOrderByInput>;
  after?: Maybe<EventWhereUniqueInput>;
  before?: Maybe<EventWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyEventQuery = { __typename?: 'Query' } & {
  findManyEvent?: Maybe<Array<{ __typename?: 'Event' } & EventFragmentFragment>>;
};

export type FindManyEventCountQueryVariables = {
  where?: Maybe<EventWhereInput>;
  orderBy?: Maybe<EventOrderByInput>;
  after?: Maybe<EventWhereUniqueInput>;
  before?: Maybe<EventWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyEventCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyEventCount'>;

export type CreateOneEventMutationVariables = {
  data: EventCreateInput;
};

export type CreateOneEventMutation = { __typename?: 'Mutation' } & {
  createOneEvent: { __typename?: 'Event' } & EventFragmentFragment;
};

export type UpdateOneEventMutationVariables = {
  where: EventWhereUniqueInput;
  data: EventUpdateInput;
};

export type UpdateOneEventMutation = { __typename?: 'Mutation' } & {
  updateOneEvent: { __typename?: 'Event' } & EventFragmentFragment;
};

export type DeleteManyEventMutationVariables = {
  where?: Maybe<EventWhereInput>;
};

export type DeleteManyEventMutation = { __typename?: 'Mutation' } & {
  deleteManyEvent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyEventMutationVariables = {
  where?: Maybe<EventWhereInput>;
  data: EventUpdateManyMutationInput;
};

export type UpdateManyEventMutation = { __typename?: 'Mutation' } & {
  updateManyEvent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type EventChildrenFragmentFragment = { __typename?: 'EventChildren' } & Pick<
  EventChildren,
  'createdAt' | 'description' | 'endDate' | 'id' | 'startDate' | 'title' | 'updatedAt' | 'parentEventId'
> & { parentEvent: { __typename?: 'Event' } & Pick<Event, 'id'> };

export type FindOneEventChildrenQueryVariables = {
  where: EventChildrenWhereUniqueInput;
};

export type FindOneEventChildrenQuery = { __typename?: 'Query' } & {
  findOneEventChildren?: Maybe<{ __typename?: 'EventChildren' } & EventChildrenFragmentFragment>;
};

export type FindManyEventChildrenQueryVariables = {
  where?: Maybe<EventChildrenWhereInput>;
  orderBy?: Maybe<EventChildrenOrderByInput>;
  after?: Maybe<EventChildrenWhereUniqueInput>;
  before?: Maybe<EventChildrenWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyEventChildrenQuery = { __typename?: 'Query' } & {
  findManyEventChildren?: Maybe<Array<{ __typename?: 'EventChildren' } & EventChildrenFragmentFragment>>;
};

export type FindManyEventChildrenCountQueryVariables = {
  where?: Maybe<EventChildrenWhereInput>;
  orderBy?: Maybe<EventChildrenOrderByInput>;
  after?: Maybe<EventChildrenWhereUniqueInput>;
  before?: Maybe<EventChildrenWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyEventChildrenCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyEventChildrenCount'>;

export type CreateOneEventChildrenMutationVariables = {
  data: EventChildrenCreateInput;
};

export type CreateOneEventChildrenMutation = { __typename?: 'Mutation' } & {
  createOneEventChildren: { __typename?: 'EventChildren' } & EventChildrenFragmentFragment;
};

export type UpdateOneEventChildrenMutationVariables = {
  where: EventChildrenWhereUniqueInput;
  data: EventChildrenUpdateInput;
};

export type UpdateOneEventChildrenMutation = { __typename?: 'Mutation' } & {
  updateOneEventChildren: { __typename?: 'EventChildren' } & EventChildrenFragmentFragment;
};

export type DeleteOneEventChildrenMutationVariables = {
  where: EventChildrenWhereUniqueInput;
};

export type DeleteOneEventChildrenMutation = { __typename?: 'Mutation' } & {
  deleteOneEventChildren?: Maybe<{ __typename?: 'EventChildren' } & Pick<EventChildren, 'id'>>;
};

export type DeleteManyEventChildrenMutationVariables = {
  where?: Maybe<EventChildrenWhereInput>;
};

export type DeleteManyEventChildrenMutation = { __typename?: 'Mutation' } & {
  deleteManyEventChildren: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyEventChildrenMutationVariables = {
  where?: Maybe<EventChildrenWhereInput>;
  data: EventChildrenUpdateManyMutationInput;
};

export type UpdateManyEventChildrenMutation = { __typename?: 'Mutation' } & {
  updateManyEventChildren: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type EventRecurringPatternFragmentFragment = { __typename?: 'EventRecurringPattern' } & Pick<
  EventRecurringPattern,
  | 'createdAt'
  | 'daysOfMonth'
  | 'daysOfWeek'
  | 'id'
  | 'monthsOfYear'
  | 'recurringType'
  | 'separationCount'
  | 'updatedAt'
  | 'weeksOfMonth'
> & { event?: Maybe<{ __typename?: 'Event' } & Pick<Event, 'id'>> };

export type FindOneEventRecurringPatternQueryVariables = {
  where: EventRecurringPatternWhereUniqueInput;
};

export type FindOneEventRecurringPatternQuery = { __typename?: 'Query' } & {
  findOneEventRecurringPattern?: Maybe<
    { __typename?: 'EventRecurringPattern' } & EventRecurringPatternFragmentFragment
  >;
};

export type FindManyEventRecurringPatternQueryVariables = {
  where?: Maybe<EventRecurringPatternWhereInput>;
  orderBy?: Maybe<EventRecurringPatternOrderByInput>;
  after?: Maybe<EventRecurringPatternWhereUniqueInput>;
  before?: Maybe<EventRecurringPatternWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyEventRecurringPatternQuery = { __typename?: 'Query' } & {
  findManyEventRecurringPattern?: Maybe<
    Array<{ __typename?: 'EventRecurringPattern' } & EventRecurringPatternFragmentFragment>
  >;
};

export type FindManyEventRecurringPatternCountQueryVariables = {
  where?: Maybe<EventRecurringPatternWhereInput>;
  orderBy?: Maybe<EventRecurringPatternOrderByInput>;
  after?: Maybe<EventRecurringPatternWhereUniqueInput>;
  before?: Maybe<EventRecurringPatternWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyEventRecurringPatternCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyEventRecurringPatternCount'
>;

export type CreateOneEventRecurringPatternMutationVariables = {
  data: EventRecurringPatternCreateInput;
};

export type CreateOneEventRecurringPatternMutation = { __typename?: 'Mutation' } & {
  createOneEventRecurringPattern: { __typename?: 'EventRecurringPattern' } & EventRecurringPatternFragmentFragment;
};

export type UpdateOneEventRecurringPatternMutationVariables = {
  where: EventRecurringPatternWhereUniqueInput;
  data: EventRecurringPatternUpdateInput;
};

export type UpdateOneEventRecurringPatternMutation = { __typename?: 'Mutation' } & {
  updateOneEventRecurringPattern: { __typename?: 'EventRecurringPattern' } & EventRecurringPatternFragmentFragment;
};

export type DeleteOneEventRecurringPatternMutationVariables = {
  where: EventRecurringPatternWhereUniqueInput;
};

export type DeleteOneEventRecurringPatternMutation = { __typename?: 'Mutation' } & {
  deleteOneEventRecurringPattern?: Maybe<{ __typename?: 'EventRecurringPattern' } & Pick<EventRecurringPattern, 'id'>>;
};

export type DeleteManyEventRecurringPatternMutationVariables = {
  where?: Maybe<EventRecurringPatternWhereInput>;
};

export type DeleteManyEventRecurringPatternMutation = { __typename?: 'Mutation' } & {
  deleteManyEventRecurringPattern: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyEventRecurringPatternMutationVariables = {
  where?: Maybe<EventRecurringPatternWhereInput>;
  data: EventRecurringPatternUpdateManyMutationInput;
};

export type UpdateManyEventRecurringPatternMutation = { __typename?: 'Mutation' } & {
  updateManyEventRecurringPattern: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type FaqFragmentFragment = { __typename?: 'Faq' } & Pick<
  Faq,
  'body' | 'createdAt' | 'featured' | 'id' | 'link' | 'order' | 'title' | 'type' | 'updatedAt' | 'viewCount'
>;

export type FindOneFaqQueryVariables = {
  where: FaqWhereUniqueInput;
};

export type FindOneFaqQuery = { __typename?: 'Query' } & {
  findOneFaq?: Maybe<{ __typename?: 'Faq' } & FaqFragmentFragment>;
};

export type FindManyFaqQueryVariables = {
  where?: Maybe<FaqWhereInput>;
  orderBy?: Maybe<FaqOrderByInput>;
  after?: Maybe<FaqWhereUniqueInput>;
  before?: Maybe<FaqWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyFaqQuery = { __typename?: 'Query' } & {
  findManyFaq?: Maybe<Array<{ __typename?: 'Faq' } & FaqFragmentFragment>>;
};

export type FindManyFaqCountQueryVariables = {
  where?: Maybe<FaqWhereInput>;
  orderBy?: Maybe<FaqOrderByInput>;
  after?: Maybe<FaqWhereUniqueInput>;
  before?: Maybe<FaqWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyFaqCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyFaqCount'>;

export type CreateOneFaqMutationVariables = {
  data: FaqCreateInput;
};

export type CreateOneFaqMutation = { __typename?: 'Mutation' } & {
  createOneFaq: { __typename?: 'Faq' } & FaqFragmentFragment;
};

export type UpdateOneFaqMutationVariables = {
  where: FaqWhereUniqueInput;
  data: FaqUpdateInput;
};

export type UpdateOneFaqMutation = { __typename?: 'Mutation' } & {
  updateOneFaq: { __typename?: 'Faq' } & FaqFragmentFragment;
};

export type DeleteOneFaqMutationVariables = {
  where: FaqWhereUniqueInput;
};

export type DeleteOneFaqMutation = { __typename?: 'Mutation' } & {
  deleteOneFaq?: Maybe<{ __typename?: 'Faq' } & Pick<Faq, 'id'>>;
};

export type DeleteManyFaqMutationVariables = {
  where?: Maybe<FaqWhereInput>;
};

export type DeleteManyFaqMutation = { __typename?: 'Mutation' } & {
  deleteManyFaq: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyFaqMutationVariables = {
  where?: Maybe<FaqWhereInput>;
  data: FaqUpdateManyMutationInput;
};

export type UpdateManyFaqMutation = { __typename?: 'Mutation' } & {
  updateManyFaq: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type FaqTagFragmentFragment = { __typename?: 'FaqTag' } & Pick<
  FaqTag,
  'createdAt' | 'id' | 'name' | 'updatedAt' | 'viewCount'
>;

export type FindOneFaqTagQueryVariables = {
  where: FaqTagWhereUniqueInput;
};

export type FindOneFaqTagQuery = { __typename?: 'Query' } & {
  findOneFaqTag?: Maybe<{ __typename?: 'FaqTag' } & FaqTagFragmentFragment>;
};

export type FindManyFaqTagQueryVariables = {
  where?: Maybe<FaqTagWhereInput>;
  orderBy?: Maybe<FaqTagOrderByInput>;
  after?: Maybe<FaqTagWhereUniqueInput>;
  before?: Maybe<FaqTagWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyFaqTagQuery = { __typename?: 'Query' } & {
  findManyFaqTag?: Maybe<Array<{ __typename?: 'FaqTag' } & FaqTagFragmentFragment>>;
};

export type FindManyFaqTagCountQueryVariables = {
  where?: Maybe<FaqTagWhereInput>;
  orderBy?: Maybe<FaqTagOrderByInput>;
  after?: Maybe<FaqTagWhereUniqueInput>;
  before?: Maybe<FaqTagWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyFaqTagCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyFaqTagCount'>;

export type CreateOneFaqTagMutationVariables = {
  data: FaqTagCreateInput;
};

export type CreateOneFaqTagMutation = { __typename?: 'Mutation' } & {
  createOneFaqTag: { __typename?: 'FaqTag' } & FaqTagFragmentFragment;
};

export type UpdateOneFaqTagMutationVariables = {
  where: FaqTagWhereUniqueInput;
  data: FaqTagUpdateInput;
};

export type UpdateOneFaqTagMutation = { __typename?: 'Mutation' } & {
  updateOneFaqTag: { __typename?: 'FaqTag' } & FaqTagFragmentFragment;
};

export type DeleteOneFaqTagMutationVariables = {
  where: FaqTagWhereUniqueInput;
};

export type DeleteOneFaqTagMutation = { __typename?: 'Mutation' } & {
  deleteOneFaqTag?: Maybe<{ __typename?: 'FaqTag' } & Pick<FaqTag, 'id'>>;
};

export type DeleteManyFaqTagMutationVariables = {
  where?: Maybe<FaqTagWhereInput>;
};

export type DeleteManyFaqTagMutation = { __typename?: 'Mutation' } & {
  deleteManyFaqTag: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyFaqTagMutationVariables = {
  where?: Maybe<FaqTagWhereInput>;
  data: FaqTagUpdateManyMutationInput;
};

export type UpdateManyFaqTagMutation = { __typename?: 'Mutation' } & {
  updateManyFaqTag: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type GradeFragmentFragment = { __typename?: 'Grade' } & Pick<
  Grade,
  'avg' | 'createdAt' | 'id' | 'letter' | 'updatedAt'
>;

export type FindOneGradeQueryVariables = {
  where: GradeWhereUniqueInput;
};

export type FindOneGradeQuery = { __typename?: 'Query' } & {
  findOneGrade?: Maybe<{ __typename?: 'Grade' } & GradeFragmentFragment>;
};

export type FindManyGradeQueryVariables = {
  where?: Maybe<GradeWhereInput>;
  orderBy?: Maybe<GradeOrderByInput>;
  after?: Maybe<GradeWhereUniqueInput>;
  before?: Maybe<GradeWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyGradeQuery = { __typename?: 'Query' } & {
  findManyGrade?: Maybe<Array<{ __typename?: 'Grade' } & GradeFragmentFragment>>;
};

export type FindManyGradeCountQueryVariables = {
  where?: Maybe<GradeWhereInput>;
  orderBy?: Maybe<GradeOrderByInput>;
  after?: Maybe<GradeWhereUniqueInput>;
  before?: Maybe<GradeWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyGradeCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyGradeCount'>;

export type CreateOneGradeMutationVariables = {
  data: GradeCreateInput;
};

export type CreateOneGradeMutation = { __typename?: 'Mutation' } & {
  createOneGrade: { __typename?: 'Grade' } & GradeFragmentFragment;
};

export type UpdateOneGradeMutationVariables = {
  where: GradeWhereUniqueInput;
  data: GradeUpdateInput;
};

export type UpdateOneGradeMutation = { __typename?: 'Mutation' } & {
  updateOneGrade: { __typename?: 'Grade' } & GradeFragmentFragment;
};

export type DeleteOneGradeMutationVariables = {
  where: GradeWhereUniqueInput;
};

export type DeleteOneGradeMutation = { __typename?: 'Mutation' } & {
  deleteOneGrade?: Maybe<{ __typename?: 'Grade' } & Pick<Grade, 'id'>>;
};

export type DeleteManyGradeMutationVariables = {
  where?: Maybe<GradeWhereInput>;
};

export type DeleteManyGradeMutation = { __typename?: 'Mutation' } & {
  deleteManyGrade: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyGradeMutationVariables = {
  where?: Maybe<GradeWhereInput>;
  data: GradeUpdateManyMutationInput;
};

export type UpdateManyGradeMutation = { __typename?: 'Mutation' } & {
  updateManyGrade: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type HubAccountFragmentFragment = { __typename?: 'HubAccount' } & Pick<
  HubAccount,
  | 'accountStatus'
  | 'acctNum'
  | 'address1'
  | 'address2'
  | 'city'
  | 'country'
  | 'createdAt'
  | 'email'
  | 'firstName'
  | 'gender'
  | 'hubUserXid'
  | 'id'
  | 'lastName'
  | 'originHub'
  | 'state'
  | 'updatedAt'
  | 'zip'
>;

export type FindOneHubAccountQueryVariables = {
  where: HubAccountWhereUniqueInput;
};

export type FindOneHubAccountQuery = { __typename?: 'Query' } & {
  findOneHubAccount?: Maybe<{ __typename?: 'HubAccount' } & HubAccountFragmentFragment>;
};

export type FindManyHubAccountQueryVariables = {
  where?: Maybe<HubAccountWhereInput>;
  orderBy?: Maybe<HubAccountOrderByInput>;
  after?: Maybe<HubAccountWhereUniqueInput>;
  before?: Maybe<HubAccountWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyHubAccountQuery = { __typename?: 'Query' } & {
  findManyHubAccount?: Maybe<Array<{ __typename?: 'HubAccount' } & HubAccountFragmentFragment>>;
};

export type FindManyHubAccountCountQueryVariables = {
  where?: Maybe<HubAccountWhereInput>;
  orderBy?: Maybe<HubAccountOrderByInput>;
  after?: Maybe<HubAccountWhereUniqueInput>;
  before?: Maybe<HubAccountWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyHubAccountCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyHubAccountCount'>;

export type CreateOneHubAccountMutationVariables = {
  data: HubAccountCreateInput;
};

export type CreateOneHubAccountMutation = { __typename?: 'Mutation' } & {
  createOneHubAccount: { __typename?: 'HubAccount' } & HubAccountFragmentFragment;
};

export type UpdateOneHubAccountMutationVariables = {
  where: HubAccountWhereUniqueInput;
  data: HubAccountUpdateInput;
};

export type UpdateOneHubAccountMutation = { __typename?: 'Mutation' } & {
  updateOneHubAccount: { __typename?: 'HubAccount' } & HubAccountFragmentFragment;
};

export type DeleteOneHubAccountMutationVariables = {
  where: HubAccountWhereUniqueInput;
};

export type DeleteOneHubAccountMutation = { __typename?: 'Mutation' } & {
  deleteOneHubAccount?: Maybe<{ __typename?: 'HubAccount' } & Pick<HubAccount, 'id'>>;
};

export type DeleteManyHubAccountMutationVariables = {
  where?: Maybe<HubAccountWhereInput>;
};

export type DeleteManyHubAccountMutation = { __typename?: 'Mutation' } & {
  deleteManyHubAccount: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyHubAccountMutationVariables = {
  where?: Maybe<HubAccountWhereInput>;
  data: HubAccountUpdateManyMutationInput;
};

export type UpdateManyHubAccountMutation = { __typename?: 'Mutation' } & {
  updateManyHubAccount: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type HubEntitlementFragmentFragment = { __typename?: 'HubEntitlement' } & Pick<
  HubEntitlement,
  'assignedUserFullName' | 'createdAt' | 'entitlementUnitId' | 'id' | 'pressAcctNum' | 'updatedAt'
>;

export type FindOneHubEntitlementQueryVariables = {
  where: HubEntitlementWhereUniqueInput;
};

export type FindOneHubEntitlementQuery = { __typename?: 'Query' } & {
  findOneHubEntitlement?: Maybe<{ __typename?: 'HubEntitlement' } & HubEntitlementFragmentFragment>;
};

export type FindManyHubEntitlementQueryVariables = {
  where?: Maybe<HubEntitlementWhereInput>;
  orderBy?: Maybe<HubEntitlementOrderByInput>;
  after?: Maybe<HubEntitlementWhereUniqueInput>;
  before?: Maybe<HubEntitlementWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyHubEntitlementQuery = { __typename?: 'Query' } & {
  findManyHubEntitlement?: Maybe<Array<{ __typename?: 'HubEntitlement' } & HubEntitlementFragmentFragment>>;
};

export type FindManyHubEntitlementCountQueryVariables = {
  where?: Maybe<HubEntitlementWhereInput>;
  orderBy?: Maybe<HubEntitlementOrderByInput>;
  after?: Maybe<HubEntitlementWhereUniqueInput>;
  before?: Maybe<HubEntitlementWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyHubEntitlementCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyHubEntitlementCount'>;

export type CreateOneHubEntitlementMutationVariables = {
  data: HubEntitlementCreateInput;
};

export type CreateOneHubEntitlementMutation = { __typename?: 'Mutation' } & {
  createOneHubEntitlement: { __typename?: 'HubEntitlement' } & HubEntitlementFragmentFragment;
};

export type UpdateOneHubEntitlementMutationVariables = {
  where: HubEntitlementWhereUniqueInput;
  data: HubEntitlementUpdateInput;
};

export type UpdateOneHubEntitlementMutation = { __typename?: 'Mutation' } & {
  updateOneHubEntitlement: { __typename?: 'HubEntitlement' } & HubEntitlementFragmentFragment;
};

export type DeleteOneHubEntitlementMutationVariables = {
  where: HubEntitlementWhereUniqueInput;
};

export type DeleteOneHubEntitlementMutation = { __typename?: 'Mutation' } & {
  deleteOneHubEntitlement?: Maybe<{ __typename?: 'HubEntitlement' } & Pick<HubEntitlement, 'id'>>;
};

export type DeleteManyHubEntitlementMutationVariables = {
  where?: Maybe<HubEntitlementWhereInput>;
};

export type DeleteManyHubEntitlementMutation = { __typename?: 'Mutation' } & {
  deleteManyHubEntitlement: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyHubEntitlementMutationVariables = {
  where?: Maybe<HubEntitlementWhereInput>;
  data: HubEntitlementUpdateManyMutationInput;
};

export type UpdateManyHubEntitlementMutation = { __typename?: 'Mutation' } & {
  updateManyHubEntitlement: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type LessonContentFragmentFragment = { __typename?: 'LessonContent' } & Pick<
  LessonContent,
  | 'courseCodeXId'
  | 'createdAt'
  | 'day'
  | 'id'
  | 'isActive'
  | 'lessonDetails'
  | 'materials'
  | 'objectives'
  | 'parentDetails'
  | 'parentInstructions'
  | 'studentInstructions'
  | 'title'
  | 'updatedAt'
  | 'videoCode'
  | 'courseContentId'
> & { courseContent?: Maybe<{ __typename?: 'CourseContent' } & Pick<CourseContent, 'id'>> };

export type FindOneLessonContentQueryVariables = {
  where: LessonContentWhereUniqueInput;
};

export type FindOneLessonContentQuery = { __typename?: 'Query' } & {
  findOneLessonContent?: Maybe<{ __typename?: 'LessonContent' } & LessonContentFragmentFragment>;
};

export type FindManyLessonContentQueryVariables = {
  where?: Maybe<LessonContentWhereInput>;
  orderBy?: Maybe<LessonContentOrderByInput>;
  after?: Maybe<LessonContentWhereUniqueInput>;
  before?: Maybe<LessonContentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyLessonContentQuery = { __typename?: 'Query' } & {
  findManyLessonContent?: Maybe<Array<{ __typename?: 'LessonContent' } & LessonContentFragmentFragment>>;
};

export type FindManyLessonContentCountQueryVariables = {
  where?: Maybe<LessonContentWhereInput>;
  orderBy?: Maybe<LessonContentOrderByInput>;
  after?: Maybe<LessonContentWhereUniqueInput>;
  before?: Maybe<LessonContentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyLessonContentCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyLessonContentCount'>;

export type CreateOneLessonContentMutationVariables = {
  data: LessonContentCreateInput;
};

export type CreateOneLessonContentMutation = { __typename?: 'Mutation' } & {
  createOneLessonContent: { __typename?: 'LessonContent' } & LessonContentFragmentFragment;
};

export type UpdateOneLessonContentMutationVariables = {
  where: LessonContentWhereUniqueInput;
  data: LessonContentUpdateInput;
};

export type UpdateOneLessonContentMutation = { __typename?: 'Mutation' } & {
  updateOneLessonContent: { __typename?: 'LessonContent' } & LessonContentFragmentFragment;
};

export type DeleteOneLessonContentMutationVariables = {
  where: LessonContentWhereUniqueInput;
};

export type DeleteOneLessonContentMutation = { __typename?: 'Mutation' } & {
  deleteOneLessonContent?: Maybe<{ __typename?: 'LessonContent' } & Pick<LessonContent, 'id'>>;
};

export type DeleteManyLessonContentMutationVariables = {
  where?: Maybe<LessonContentWhereInput>;
};

export type DeleteManyLessonContentMutation = { __typename?: 'Mutation' } & {
  deleteManyLessonContent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyLessonContentMutationVariables = {
  where?: Maybe<LessonContentWhereInput>;
  data: LessonContentUpdateManyMutationInput;
};

export type UpdateManyLessonContentMutation = { __typename?: 'Mutation' } & {
  updateManyLessonContent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type LessonContentResourceFragmentFragment = { __typename?: 'LessonContentResource' } & Pick<
  LessonContentResource,
  | 'courseCodeXId'
  | 'createdAt'
  | 'id'
  | 'lessonDayXId'
  | 'resourceType'
  | 'sourceLink'
  | 'updatedAt'
  | 'lessonContentId'
> & { lessonContent?: Maybe<{ __typename?: 'LessonContent' } & Pick<LessonContent, 'id'>> };

export type FindOneLessonContentResourceQueryVariables = {
  where: LessonContentResourceWhereUniqueInput;
};

export type FindOneLessonContentResourceQuery = { __typename?: 'Query' } & {
  findOneLessonContentResource?: Maybe<
    { __typename?: 'LessonContentResource' } & LessonContentResourceFragmentFragment
  >;
};

export type FindManyLessonContentResourceQueryVariables = {
  where?: Maybe<LessonContentResourceWhereInput>;
  orderBy?: Maybe<LessonContentResourceOrderByInput>;
  after?: Maybe<LessonContentResourceWhereUniqueInput>;
  before?: Maybe<LessonContentResourceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyLessonContentResourceQuery = { __typename?: 'Query' } & {
  findManyLessonContentResource?: Maybe<
    Array<{ __typename?: 'LessonContentResource' } & LessonContentResourceFragmentFragment>
  >;
};

export type FindManyLessonContentResourceCountQueryVariables = {
  where?: Maybe<LessonContentResourceWhereInput>;
  orderBy?: Maybe<LessonContentResourceOrderByInput>;
  after?: Maybe<LessonContentResourceWhereUniqueInput>;
  before?: Maybe<LessonContentResourceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyLessonContentResourceCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyLessonContentResourceCount'
>;

export type CreateOneLessonContentResourceMutationVariables = {
  data: LessonContentResourceCreateInput;
};

export type CreateOneLessonContentResourceMutation = { __typename?: 'Mutation' } & {
  createOneLessonContentResource: { __typename?: 'LessonContentResource' } & LessonContentResourceFragmentFragment;
};

export type UpdateOneLessonContentResourceMutationVariables = {
  where: LessonContentResourceWhereUniqueInput;
  data: LessonContentResourceUpdateInput;
};

export type UpdateOneLessonContentResourceMutation = { __typename?: 'Mutation' } & {
  updateOneLessonContentResource: { __typename?: 'LessonContentResource' } & LessonContentResourceFragmentFragment;
};

export type DeleteOneLessonContentResourceMutationVariables = {
  where: LessonContentResourceWhereUniqueInput;
};

export type DeleteOneLessonContentResourceMutation = { __typename?: 'Mutation' } & {
  deleteOneLessonContentResource?: Maybe<{ __typename?: 'LessonContentResource' } & Pick<LessonContentResource, 'id'>>;
};

export type DeleteManyLessonContentResourceMutationVariables = {
  where?: Maybe<LessonContentResourceWhereInput>;
};

export type DeleteManyLessonContentResourceMutation = { __typename?: 'Mutation' } & {
  deleteManyLessonContentResource: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyLessonContentResourceMutationVariables = {
  where?: Maybe<LessonContentResourceWhereInput>;
  data: LessonContentResourceUpdateManyMutationInput;
};

export type UpdateManyLessonContentResourceMutation = { __typename?: 'Mutation' } & {
  updateManyLessonContentResource: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type LessonTakingFragmentFragment = { __typename?: 'LessonTaking' } & Pick<
  LessonTaking,
  'assignedDate' | 'createdAt' | 'day' | 'id' | 'updatedAt' | 'courseTakingId' | 'lessonContentId'
> & {
    courseTaking?: Maybe<{ __typename?: 'CourseTaking' } & Pick<CourseTaking, 'id'>>;
    lessonContent: { __typename?: 'LessonContent' } & Pick<LessonContent, 'id'>;
  };

export type FindOneLessonTakingQueryVariables = {
  where: LessonTakingWhereUniqueInput;
};

export type FindOneLessonTakingQuery = { __typename?: 'Query' } & {
  findOneLessonTaking?: Maybe<{ __typename?: 'LessonTaking' } & LessonTakingFragmentFragment>;
};

export type FindManyLessonTakingQueryVariables = {
  where?: Maybe<LessonTakingWhereInput>;
  orderBy?: Maybe<LessonTakingOrderByInput>;
  after?: Maybe<LessonTakingWhereUniqueInput>;
  before?: Maybe<LessonTakingWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyLessonTakingQuery = { __typename?: 'Query' } & {
  findManyLessonTaking?: Maybe<Array<{ __typename?: 'LessonTaking' } & LessonTakingFragmentFragment>>;
};

export type FindManyLessonTakingCountQueryVariables = {
  where?: Maybe<LessonTakingWhereInput>;
  orderBy?: Maybe<LessonTakingOrderByInput>;
  after?: Maybe<LessonTakingWhereUniqueInput>;
  before?: Maybe<LessonTakingWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyLessonTakingCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyLessonTakingCount'>;

export type CreateOneLessonTakingMutationVariables = {
  data: LessonTakingCreateInput;
};

export type CreateOneLessonTakingMutation = { __typename?: 'Mutation' } & {
  createOneLessonTaking: { __typename?: 'LessonTaking' } & LessonTakingFragmentFragment;
};

export type UpdateOneLessonTakingMutationVariables = {
  where: LessonTakingWhereUniqueInput;
  data: LessonTakingUpdateInput;
};

export type UpdateOneLessonTakingMutation = { __typename?: 'Mutation' } & {
  updateOneLessonTaking: { __typename?: 'LessonTaking' } & LessonTakingFragmentFragment;
};

export type DeleteOneLessonTakingMutationVariables = {
  where: LessonTakingWhereUniqueInput;
};

export type DeleteOneLessonTakingMutation = { __typename?: 'Mutation' } & {
  deleteOneLessonTaking?: Maybe<{ __typename?: 'LessonTaking' } & Pick<LessonTaking, 'id'>>;
};

export type DeleteManyLessonTakingMutationVariables = {
  where?: Maybe<LessonTakingWhereInput>;
};

export type DeleteManyLessonTakingMutation = { __typename?: 'Mutation' } & {
  deleteManyLessonTaking: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyLessonTakingMutationVariables = {
  where?: Maybe<LessonTakingWhereInput>;
  data: LessonTakingUpdateManyMutationInput;
};

export type UpdateManyLessonTakingMutation = { __typename?: 'Mutation' } & {
  updateManyLessonTaking: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type ParentFragmentFragment = { __typename?: 'Parent' } & Pick<
  Parent,
  | 'coppaIsSigned'
  | 'coppaSignedTime'
  | 'createdAt'
  | 'hideVideo'
  | 'id'
  | 'profileEdited'
  | 'updatedAt'
  | 'vitalSourceToken'
  | 'wizardFinished'
  | 'personId'
> & { person: { __typename?: 'Person' } & Pick<Person, 'id'> };

export type FindOneParentQueryVariables = {
  where: ParentWhereUniqueInput;
};

export type FindOneParentQuery = { __typename?: 'Query' } & {
  findOneParent?: Maybe<{ __typename?: 'Parent' } & ParentFragmentFragment>;
};

export type FindManyParentQueryVariables = {
  where?: Maybe<ParentWhereInput>;
  orderBy?: Maybe<ParentOrderByInput>;
  after?: Maybe<ParentWhereUniqueInput>;
  before?: Maybe<ParentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyParentQuery = { __typename?: 'Query' } & {
  findManyParent?: Maybe<Array<{ __typename?: 'Parent' } & ParentFragmentFragment>>;
};

export type FindManyParentCountQueryVariables = {
  where?: Maybe<ParentWhereInput>;
  orderBy?: Maybe<ParentOrderByInput>;
  after?: Maybe<ParentWhereUniqueInput>;
  before?: Maybe<ParentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyParentCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyParentCount'>;

export type CreateOneParentMutationVariables = {
  data: ParentCreateInput;
};

export type CreateOneParentMutation = { __typename?: 'Mutation' } & {
  createOneParent: { __typename?: 'Parent' } & ParentFragmentFragment;
};

export type UpdateOneParentMutationVariables = {
  where: ParentWhereUniqueInput;
  data: ParentUpdateInput;
};

export type UpdateOneParentMutation = { __typename?: 'Mutation' } & {
  updateOneParent: { __typename?: 'Parent' } & ParentFragmentFragment;
};

export type DeleteOneParentMutationVariables = {
  where: ParentWhereUniqueInput;
};

export type DeleteOneParentMutation = { __typename?: 'Mutation' } & {
  deleteOneParent?: Maybe<{ __typename?: 'Parent' } & Pick<Parent, 'id'>>;
};

export type DeleteManyParentMutationVariables = {
  where?: Maybe<ParentWhereInput>;
};

export type DeleteManyParentMutation = { __typename?: 'Mutation' } & {
  deleteManyParent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyParentMutationVariables = {
  where?: Maybe<ParentWhereInput>;
  data: ParentUpdateManyMutationInput;
};

export type UpdateManyParentMutation = { __typename?: 'Mutation' } & {
  updateManyParent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type PersonFragmentFragment = { __typename?: 'Person' } & Pick<
  Person,
  | 'addrLine1'
  | 'addrLine2'
  | 'city'
  | 'country'
  | 'createdAt'
  | 'dob'
  | 'email'
  | 'firstName'
  | 'gender'
  | 'grade'
  | 'id'
  | 'lastName'
  | 'phone'
  | 'state'
  | 'type'
  | 'updatedAt'
  | 'zip'
  | 'studentId'
  | 'userId'
> & {
    parent?: Maybe<{ __typename?: 'Parent' } & Pick<Parent, 'id'>>;
    student?: Maybe<{ __typename?: 'Student' } & Pick<Student, 'id'>>;
    user: { __typename?: 'User' } & Pick<User, 'id'>;
  };

export type FindOnePersonQueryVariables = {
  where: PersonWhereUniqueInput;
};

export type FindOnePersonQuery = { __typename?: 'Query' } & {
  findOnePerson?: Maybe<{ __typename?: 'Person' } & PersonFragmentFragment>;
};

export type FindManyPersonQueryVariables = {
  where?: Maybe<PersonWhereInput>;
  orderBy?: Maybe<PersonOrderByInput>;
  after?: Maybe<PersonWhereUniqueInput>;
  before?: Maybe<PersonWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyPersonQuery = { __typename?: 'Query' } & {
  findManyPerson?: Maybe<Array<{ __typename?: 'Person' } & PersonFragmentFragment>>;
};

export type FindManyPersonCountQueryVariables = {
  where?: Maybe<PersonWhereInput>;
  orderBy?: Maybe<PersonOrderByInput>;
  after?: Maybe<PersonWhereUniqueInput>;
  before?: Maybe<PersonWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyPersonCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyPersonCount'>;

export type CreateOnePersonMutationVariables = {
  data: PersonCreateInput;
};

export type CreateOnePersonMutation = { __typename?: 'Mutation' } & {
  createOnePerson: { __typename?: 'Person' } & PersonFragmentFragment;
};

export type UpdateOnePersonMutationVariables = {
  where: PersonWhereUniqueInput;
  data: PersonUpdateInput;
};

export type UpdateOnePersonMutation = { __typename?: 'Mutation' } & {
  updateOnePerson: { __typename?: 'Person' } & PersonFragmentFragment;
};

export type DeleteOnePersonMutationVariables = {
  where: PersonWhereUniqueInput;
};

export type DeleteOnePersonMutation = { __typename?: 'Mutation' } & {
  deleteOnePerson?: Maybe<{ __typename?: 'Person' } & Pick<Person, 'id'>>;
};

export type DeleteManyPersonMutationVariables = {
  where?: Maybe<PersonWhereInput>;
};

export type DeleteManyPersonMutation = { __typename?: 'Mutation' } & {
  deleteManyPerson: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyPersonMutationVariables = {
  where?: Maybe<PersonWhereInput>;
  data: PersonUpdateManyMutationInput;
};

export type UpdateManyPersonMutation = { __typename?: 'Mutation' } & {
  updateManyPerson: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type ModelFragmentFragment = { __typename?: 'Model' } & Pick<
  Model,
  'id' | 'name' | 'create' | 'delete' | 'update'
> & { fields: Array<{ __typename?: 'Field' } & FieldFragmentFragment> };

export type FieldFragmentFragment = { __typename?: 'Field' } & Pick<
  Field,
  | 'id'
  | 'name'
  | 'title'
  | 'type'
  | 'list'
  | 'kind'
  | 'read'
  | 'required'
  | 'create'
  | 'order'
  | 'update'
  | 'sort'
  | 'filter'
>;

export type EnumFragmentFragment = { __typename?: 'Enum' } & Pick<Enum, 'name' | 'fields'>;

export type GetModelQueryVariables = {
  id: Scalars['String'];
};

export type GetModelQuery = { __typename?: 'Query' } & {
  getModel?: Maybe<{ __typename?: 'Model' } & ModelFragmentFragment>;
};

export type GetModelsQueryVariables = {};

export type GetModelsQuery = { __typename?: 'Query' } & {
  getModels?: Maybe<Array<{ __typename?: 'Model' } & ModelFragmentFragment>>;
};

export type GetEnumQueryVariables = {
  name: Scalars['String'];
};

export type GetEnumQuery = { __typename?: 'Query' } & {
  getEnum?: Maybe<{ __typename?: 'Enum' } & EnumFragmentFragment>;
};

export type UpdateModelMutationVariables = {
  id: Scalars['String'];
  data: UpdateModelInput;
};

export type UpdateModelMutation = { __typename?: 'Mutation' } & {
  updateModel: { __typename?: 'Model' } & ModelFragmentFragment;
};

export type UpdateFieldMutationVariables = {
  id: Scalars['String'];
  modelId: Scalars['String'];
  data: UpdateFieldInput;
};

export type UpdateFieldMutation = { __typename?: 'Mutation' } & {
  updateField: { __typename?: 'Field' } & FieldFragmentFragment;
};

export type StudentFragmentFragment = { __typename?: 'Student' } & Pick<
  Student,
  'assessmentPwd' | 'createdAt' | 'id' | 'lessonsPerDay' | 'updatedAt' | 'parentId'
> & { parent: { __typename?: 'Parent' } & Pick<Parent, 'id'>; person: { __typename?: 'Person' } & Pick<Person, 'id'> };

export type FindOneStudentQueryVariables = {
  where: StudentWhereUniqueInput;
};

export type FindOneStudentQuery = { __typename?: 'Query' } & {
  findOneStudent?: Maybe<{ __typename?: 'Student' } & StudentFragmentFragment>;
};

export type FindManyStudentQueryVariables = {
  where?: Maybe<StudentWhereInput>;
  orderBy?: Maybe<StudentOrderByInput>;
  after?: Maybe<StudentWhereUniqueInput>;
  before?: Maybe<StudentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyStudentQuery = { __typename?: 'Query' } & {
  findManyStudent?: Maybe<Array<{ __typename?: 'Student' } & StudentFragmentFragment>>;
};

export type FindManyStudentCountQueryVariables = {
  where?: Maybe<StudentWhereInput>;
  orderBy?: Maybe<StudentOrderByInput>;
  after?: Maybe<StudentWhereUniqueInput>;
  before?: Maybe<StudentWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyStudentCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyStudentCount'>;

export type CreateOneStudentMutationVariables = {
  data: StudentCreateInput;
};

export type CreateOneStudentMutation = { __typename?: 'Mutation' } & {
  createOneStudent: { __typename?: 'Student' } & StudentFragmentFragment;
};

export type UpdateOneStudentMutationVariables = {
  where: StudentWhereUniqueInput;
  data: StudentUpdateInput;
};

export type UpdateOneStudentMutation = { __typename?: 'Mutation' } & {
  updateOneStudent: { __typename?: 'Student' } & StudentFragmentFragment;
};

export type DeleteOneStudentMutationVariables = {
  where: StudentWhereUniqueInput;
};

export type DeleteOneStudentMutation = { __typename?: 'Mutation' } & {
  deleteOneStudent?: Maybe<{ __typename?: 'Student' } & Pick<Student, 'id'>>;
};

export type DeleteManyStudentMutationVariables = {
  where?: Maybe<StudentWhereInput>;
};

export type DeleteManyStudentMutation = { __typename?: 'Mutation' } & {
  deleteManyStudent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyStudentMutationVariables = {
  where?: Maybe<StudentWhereInput>;
  data: StudentUpdateManyMutationInput;
};

export type UpdateManyStudentMutation = { __typename?: 'Mutation' } & {
  updateManyStudent: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UserFragmentFragment = { __typename?: 'User' } & Pick<
  User,
  | 'avatarLink'
  | 'canAccessCommunity'
  | 'canAddEventsToCalendar'
  | 'canReceiveDirectMessages'
  | 'canSeeGrades'
  | 'communityPostAlertAlways'
  | 'createdAt'
  | 'font'
  | 'id'
  | 'isCommunity'
  | 'isParent'
  | 'isVisible'
  | 'lessonsPerDay'
  | 'passResetExpires'
  | 'password'
  | 'passwordResetToken'
  | 'pressAcctNum'
  | 'updatedAt'
  | 'username'
  | 'userTheme'
  | 'userLearningSettingsId'
> & {
    person?: Maybe<{ __typename?: 'Person' } & Pick<Person, 'id'>>;
    userLearningSettings?: Maybe<{ __typename?: 'UserLearningSettings' } & Pick<UserLearningSettings, 'id'>>;
  };

export type FindOneUserQueryVariables = {
  where: UserWhereUniqueInput;
};

export type FindOneUserQuery = { __typename?: 'Query' } & {
  findOneUser?: Maybe<{ __typename?: 'User' } & UserFragmentFragment>;
};

export type FindManyUserQueryVariables = {
  where?: Maybe<UserWhereInput>;
  orderBy?: Maybe<UserOrderByInput>;
  after?: Maybe<UserWhereUniqueInput>;
  before?: Maybe<UserWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyUserQuery = { __typename?: 'Query' } & {
  findManyUser?: Maybe<Array<{ __typename?: 'User' } & UserFragmentFragment>>;
};

export type FindManyUserCountQueryVariables = {
  where?: Maybe<UserWhereInput>;
  orderBy?: Maybe<UserOrderByInput>;
  after?: Maybe<UserWhereUniqueInput>;
  before?: Maybe<UserWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyUserCountQuery = { __typename?: 'Query' } & Pick<Query, 'findManyUserCount'>;

export type CreateOneUserMutationVariables = {
  data: UserCreateInput;
};

export type CreateOneUserMutation = { __typename?: 'Mutation' } & {
  createOneUser: { __typename?: 'User' } & UserFragmentFragment;
};

export type UpdateOneUserMutationVariables = {
  where: UserWhereUniqueInput;
  data: UserUpdateInput;
};

export type UpdateOneUserMutation = { __typename?: 'Mutation' } & {
  updateOneUser: { __typename?: 'User' } & UserFragmentFragment;
};

export type DeleteOneUserMutationVariables = {
  where: UserWhereUniqueInput;
};

export type DeleteOneUserMutation = { __typename?: 'Mutation' } & {
  deleteOneUser?: Maybe<{ __typename?: 'User' } & Pick<User, 'id'>>;
};

export type DeleteManyUserMutationVariables = {
  where?: Maybe<UserWhereInput>;
};

export type DeleteManyUserMutation = { __typename?: 'Mutation' } & {
  deleteManyUser: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyUserMutationVariables = {
  where?: Maybe<UserWhereInput>;
  data: UserUpdateManyMutationInput;
};

export type UpdateManyUserMutation = { __typename?: 'Mutation' } & {
  updateManyUser: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UserLearningSettingsFragmentFragment = { __typename?: 'UserLearningSettings' } & Pick<
  UserLearningSettings,
  | 'createdAt'
  | 'hoursPerDay'
  | 'id'
  | 'schoolEnd'
  | 'schoolOnFri'
  | 'schoolOnMon'
  | 'schoolOnSat'
  | 'schoolOnSun'
  | 'schoolOnThu'
  | 'schoolOnTue'
  | 'schoolOnWed'
  | 'schoolStart'
  | 'univPwd'
  | 'univPwdWholeFamily'
  | 'updatedAt'
> & { user?: Maybe<{ __typename?: 'User' } & Pick<User, 'id'>> };

export type FindOneUserLearningSettingsQueryVariables = {
  where: UserLearningSettingsWhereUniqueInput;
};

export type FindOneUserLearningSettingsQuery = { __typename?: 'Query' } & {
  findOneUserLearningSettings?: Maybe<{ __typename?: 'UserLearningSettings' } & UserLearningSettingsFragmentFragment>;
};

export type FindManyUserLearningSettingsQueryVariables = {
  where?: Maybe<UserLearningSettingsWhereInput>;
  orderBy?: Maybe<UserLearningSettingsOrderByInput>;
  after?: Maybe<UserLearningSettingsWhereUniqueInput>;
  before?: Maybe<UserLearningSettingsWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyUserLearningSettingsQuery = { __typename?: 'Query' } & {
  findManyUserLearningSettings?: Maybe<
    Array<{ __typename?: 'UserLearningSettings' } & UserLearningSettingsFragmentFragment>
  >;
};

export type FindManyUserLearningSettingsCountQueryVariables = {
  where?: Maybe<UserLearningSettingsWhereInput>;
  orderBy?: Maybe<UserLearningSettingsOrderByInput>;
  after?: Maybe<UserLearningSettingsWhereUniqueInput>;
  before?: Maybe<UserLearningSettingsWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type FindManyUserLearningSettingsCountQuery = { __typename?: 'Query' } & Pick<
  Query,
  'findManyUserLearningSettingsCount'
>;

export type CreateOneUserLearningSettingsMutationVariables = {
  data: UserLearningSettingsCreateInput;
};

export type CreateOneUserLearningSettingsMutation = { __typename?: 'Mutation' } & {
  createOneUserLearningSettings: { __typename?: 'UserLearningSettings' } & UserLearningSettingsFragmentFragment;
};

export type UpdateOneUserLearningSettingsMutationVariables = {
  where: UserLearningSettingsWhereUniqueInput;
  data: UserLearningSettingsUpdateInput;
};

export type UpdateOneUserLearningSettingsMutation = { __typename?: 'Mutation' } & {
  updateOneUserLearningSettings: { __typename?: 'UserLearningSettings' } & UserLearningSettingsFragmentFragment;
};

export type DeleteOneUserLearningSettingsMutationVariables = {
  where: UserLearningSettingsWhereUniqueInput;
};

export type DeleteOneUserLearningSettingsMutation = { __typename?: 'Mutation' } & {
  deleteOneUserLearningSettings?: Maybe<{ __typename?: 'UserLearningSettings' } & Pick<UserLearningSettings, 'id'>>;
};

export type DeleteManyUserLearningSettingsMutationVariables = {
  where?: Maybe<UserLearningSettingsWhereInput>;
};

export type DeleteManyUserLearningSettingsMutation = { __typename?: 'Mutation' } & {
  deleteManyUserLearningSettings: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export type UpdateManyUserLearningSettingsMutationVariables = {
  where?: Maybe<UserLearningSettingsWhereInput>;
  data: UserLearningSettingsUpdateManyMutationInput;
};

export type UpdateManyUserLearningSettingsMutation = { __typename?: 'Mutation' } & {
  updateManyUserLearningSettings: { __typename?: 'BatchPayload' } & Pick<BatchPayload, 'count'>;
};

export const ActivityFragmentFragmentDoc = gql`
  fragment ActivityFragment on Activity {
    color
    createdAt
    day
    id
    title
    updatedAt
    person {
      id
    }
    personId
  }
`;
export const AssessmentContentQuestionFragmentFragmentDoc = gql`
  fragment AssessmentContentQuestionFragment on AssessmentContentQuestion {
    ccAQTXId
    ccAXId
    ccXId
    courseCodeXId
    createdAt
    feedback
    id
    isAllOrNothing
    isInactive
    isOrLogic
    maxScore
    order
    text
    updatedAt
    assessmentContentQuestionType {
      id
    }
    assessmentContentQuestionTypeId
    assignmentContent {
      id
    }
    assignmentContentId
  }
`;
export const AssessmentContentQuestionAnswerFragmentFragmentDoc = gql`
  fragment AssessmentContentQuestionAnswerFragment on AssessmentContentQuestionAnswer {
    answer
    ccQXId
    ccXId
    courseCodeXId
    createdAt
    id
    isInactive
    order
    updatedAt
    assessmentContentQuestion {
      id
    }
    assessmentContentQuestionId
  }
`;
export const AssessmentContentQuestionOptionFragmentFragmentDoc = gql`
  fragment AssessmentContentQuestionOptionFragment on AssessmentContentQuestionOption {
    ccQAXId
    ccQXId
    ccXId
    courseCodeXId
    createdAt
    id
    isInactive
    order
    score
    text
    updatedAt
    assessmentContentQuestion {
      id
    }
    assessmentContentQuestionId
    assessmentContentQuestionAnswer {
      id
    }
    assessmentContentQuestionAnswerId
  }
`;
export const AssessmentContentQuestionToolFragmentFragmentDoc = gql`
  fragment AssessmentContentQuestionToolFragment on AssessmentContentQuestionTool {
    createdAt
    id
    order
    textDisplay
    textValue
    updatedAt
    assessmentContentQuestion {
      id
    }
    assessmentContentQuestionId
  }
`;
export const AssessmentContentQuestionTypeFragmentFragmentDoc = gql`
  fragment AssessmentContentQuestionTypeFragment on AssessmentContentQuestionType {
    code
    createdAt
    description
    id
    manualGrade
    updatedAt
  }
`;
export const AssessmentTakingQuestionFragmentFragmentDoc = gql`
  fragment AssessmentTakingQuestionFragment on AssessmentTakingQuestion {
    createdAt
    id
    isCorrectOverride
    parentComment
    scoreOverride
    updatedAt
    assessmentContentQuestion {
      id
    }
    assessmentContentQuestionId
    assignmentTaking {
      id
    }
    assignmentTakingId
  }
`;
export const AssessmentTakingResponseFragmentFragmentDoc = gql`
  fragment AssessmentTakingResponseFragment on AssessmentTakingResponse {
    createdAt
    id
    isCorrect
    textAnswer
    updatedAt
    assessmentContentQuestionAnswer {
      id
    }
    assessmentContentQuestionAnswerId
    assessmentContentQuestionOption {
      id
    }
    assessmentContentQuestionOptionId
    assessmentTakingQuestion {
      id
    }
    assessmentTakingQuestionId
  }
`;
export const AssignmentContentFragmentFragmentDoc = gql`
  fragment AssignmentContentFragment on AssignmentContent {
    canBeRetaken
    ccXId
    courseCodeXId
    createdAt
    feedbackType
    hasParentResource
    hasStudentResource
    id
    isAssessment
    isCounted
    isGradeable
    isOptional
    isVideo
    label
    lessonDayXId
    link
    order
    parentInstructions
    parentLink
    parentLinkLabel
    studentLink
    studentLinkLabel
    title
    totalPoints
    type
    typeLabel
    updatedAt
    courseContent {
      id
    }
    courseContentId
    lessonContent {
      id
    }
    lessonContentId
  }
`;
export const AssignmentTakingFragmentFragmentDoc = gql`
  fragment AssignmentTakingFragment on AssignmentTaking {
    assignedAt
    canBeRetaken
    createdAt
    dueDateAt
    hasBeenGraded
    id
    isCounted
    isDone
    isGradeable
    isGradeOverride
    isSkipped
    maxPoints
    maxSecondsAllowed
    numericGrade
    order
    parentInstructions
    requiresReview
    startedAt
    submittedAt
    timeTaken
    title
    totalPoints
    type
    updatedAt
    assignmentContent {
      id
    }
    assignmentContentId
    assignmentTakingWeight {
      id
    }
    assignmentTakingWeightId
    lessonTaking {
      id
    }
    lessonTakingId
  }
`;
export const AssignmentTakingWeightFragmentFragmentDoc = gql`
  fragment AssignmentTakingWeightFragment on AssignmentTakingWeight {
    createdAt
    id
    updatedAt
    weightCategory {
      id
    }
    weightCategoryId
    assignmentTaking {
      id
    }
  }
`;
export const BjuPressAccountFragmentFragmentDoc = gql`
  fragment BjuPressAccountFragment on BjuPressAccount {
    address1
    address2
    city
    country
    createdAt
    customerId
    deleted
    email
    enabled
    firstName
    hubUserXid
    id
    lastName
    originHub
    state
    updatedAt
    zip
  }
`;
export const CourseContentFragmentFragmentDoc = gql`
  fragment CourseContentFragment on CourseContent {
    courseCode
    courseType
    createdAt
    description
    edition
    entitlement
    grade
    id
    imageSource
    information
    isInactive
    label
    pressContentXId
    pressXId
    subject
    teacherBio
    textbookSource
    title
    update
    updatedAt
  }
`;
export const CourseContentCodeFragmentFragmentDoc = gql`
  fragment CourseContentCodeFragment on CourseContentCode {
    code
    createdAt
    description
    id
    type
    updatedAt
  }
`;
export const CourseContentWeightCategoryFragmentFragmentDoc = gql`
  fragment CourseContentWeightCategoryFragment on CourseContentWeightCategory {
    assignmentType
    createdAt
    id
    title
    updatedAt
    weight
    courseContent {
      id
    }
    courseContentId
  }
`;
export const CourseTakingFragmentFragmentDoc = gql`
  fragment CourseTakingFragment on CourseTaking {
    assignedFlag
    assignedAt
    bookRedemptionCode
    courseColor
    createdAt
    endDate
    entitlementEndDate
    entitlementStartDate
    fri
    gradeScale
    hasOnlineAssessments
    hasOnlineVideos
    id
    lessonsPerDay
    mon
    numericGrade
    order
    pressXid
    sat
    startDate
    status
    sun
    thu
    tue
    updatedAt
    useGradeWeights
    wed
    courseContent {
      id
    }
    courseContentId
    parent {
      id
    }
    parentId
    student {
      id
    }
    studentId
    user {
      id
    }
    userId
  }
`;
export const CourseTakingWeightCategoryFragmentFragmentDoc = gql`
  fragment CourseTakingWeightCategoryFragment on CourseTakingWeightCategory {
    createdAt
    id
    originalTitle
    originalWeight
    title
    updatedAt
    weight
    courseContentWeightCategory {
      id
    }
    courseContentWeightCategoryId
    courseTaking {
      id
    }
    courseTakingId
  }
`;
export const EventFragmentFragmentDoc = gql`
  fragment EventFragment on Event {
    color
    createdAt
    description
    endDate
    id
    isFullDayEvent
    isRecurring
    order
    shiftCoursesFlag
    startDate
    title
    updatedAt
    creator {
      id
    }
    creatorId
    person {
      id
    }
    personId
    recurringPattern {
      id
    }
    recurringPatternId
  }
`;
export const EventChildrenFragmentFragmentDoc = gql`
  fragment EventChildrenFragment on EventChildren {
    createdAt
    description
    endDate
    id
    startDate
    title
    updatedAt
    parentEvent {
      id
    }
    parentEventId
  }
`;
export const EventRecurringPatternFragmentFragmentDoc = gql`
  fragment EventRecurringPatternFragment on EventRecurringPattern {
    createdAt
    daysOfMonth
    daysOfWeek
    id
    monthsOfYear
    recurringType
    separationCount
    updatedAt
    weeksOfMonth
    event {
      id
    }
  }
`;
export const FaqFragmentFragmentDoc = gql`
  fragment FaqFragment on Faq {
    body
    createdAt
    featured
    id
    link
    order
    title
    type
    updatedAt
    viewCount
  }
`;
export const FaqTagFragmentFragmentDoc = gql`
  fragment FaqTagFragment on FaqTag {
    createdAt
    id
    name
    updatedAt
    viewCount
  }
`;
export const GradeFragmentFragmentDoc = gql`
  fragment GradeFragment on Grade {
    avg
    createdAt
    id
    letter
    updatedAt
  }
`;
export const HubAccountFragmentFragmentDoc = gql`
  fragment HubAccountFragment on HubAccount {
    accountStatus
    acctNum
    address1
    address2
    city
    country
    createdAt
    email
    firstName
    gender
    hubUserXid
    id
    lastName
    originHub
    state
    updatedAt
    zip
  }
`;
export const HubEntitlementFragmentFragmentDoc = gql`
  fragment HubEntitlementFragment on HubEntitlement {
    assignedUserFullName
    createdAt
    entitlementUnitId
    id
    pressAcctNum
    updatedAt
  }
`;
export const LessonContentFragmentFragmentDoc = gql`
  fragment LessonContentFragment on LessonContent {
    courseCodeXId
    createdAt
    day
    id
    isActive
    lessonDetails
    materials
    objectives
    parentDetails
    parentInstructions
    studentInstructions
    title
    updatedAt
    videoCode
    courseContent {
      id
    }
    courseContentId
  }
`;
export const LessonContentResourceFragmentFragmentDoc = gql`
  fragment LessonContentResourceFragment on LessonContentResource {
    courseCodeXId
    createdAt
    id
    lessonDayXId
    resourceType
    sourceLink
    updatedAt
    lessonContent {
      id
    }
    lessonContentId
  }
`;
export const LessonTakingFragmentFragmentDoc = gql`
  fragment LessonTakingFragment on LessonTaking {
    assignedDate
    createdAt
    day
    id
    updatedAt
    courseTaking {
      id
    }
    courseTakingId
    lessonContent {
      id
    }
    lessonContentId
  }
`;
export const ParentFragmentFragmentDoc = gql`
  fragment ParentFragment on Parent {
    coppaIsSigned
    coppaSignedTime
    createdAt
    hideVideo
    id
    profileEdited
    updatedAt
    vitalSourceToken
    wizardFinished
    person {
      id
    }
    personId
  }
`;
export const PersonFragmentFragmentDoc = gql`
  fragment PersonFragment on Person {
    addrLine1
    addrLine2
    city
    country
    createdAt
    dob
    email
    firstName
    gender
    grade
    id
    lastName
    phone
    state
    type
    updatedAt
    zip
    parent {
      id
    }
    student {
      id
    }
    studentId
    user {
      id
    }
    userId
  }
`;
export const FieldFragmentFragmentDoc = gql`
  fragment FieldFragment on Field {
    id
    name
    title
    type
    list
    kind
    read
    required
    create
    order
    update
    sort
    filter
  }
`;
export const ModelFragmentFragmentDoc = gql`
  fragment ModelFragment on Model {
    id
    name
    create
    delete
    update
    fields {
      ...FieldFragment
    }
  }
  ${FieldFragmentFragmentDoc}
`;
export const EnumFragmentFragmentDoc = gql`
  fragment EnumFragment on Enum {
    name
    fields
  }
`;
export const StudentFragmentFragmentDoc = gql`
  fragment StudentFragment on Student {
    assessmentPwd
    createdAt
    id
    lessonsPerDay
    updatedAt
    parent {
      id
    }
    parentId
    person {
      id
    }
  }
`;
export const UserFragmentFragmentDoc = gql`
  fragment UserFragment on User {
    avatarLink
    canAccessCommunity
    canAddEventsToCalendar
    canReceiveDirectMessages
    canSeeGrades
    communityPostAlertAlways
    createdAt
    font
    id
    isCommunity
    isParent
    isVisible
    lessonsPerDay
    passResetExpires
    password
    passwordResetToken
    pressAcctNum
    updatedAt
    username
    userTheme
    person {
      id
    }
    userLearningSettings {
      id
    }
    userLearningSettingsId
  }
`;
export const UserLearningSettingsFragmentFragmentDoc = gql`
  fragment UserLearningSettingsFragment on UserLearningSettings {
    createdAt
    hoursPerDay
    id
    schoolEnd
    schoolOnFri
    schoolOnMon
    schoolOnSat
    schoolOnSun
    schoolOnThu
    schoolOnTue
    schoolOnWed
    schoolStart
    univPwd
    univPwdWholeFamily
    updatedAt
    user {
      id
    }
  }
`;
export const FindOneActivityDocument = gql`
  query findOneActivity($where: ActivityWhereUniqueInput!) {
    findOneActivity(where: $where) {
      ...ActivityFragment
    }
  }
  ${ActivityFragmentFragmentDoc}
`;

/**
 * __useFindOneActivityQuery__
 *
 * To run a query within a React component, call `useFindOneActivityQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneActivityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneActivityQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneActivityQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneActivityQuery, FindOneActivityQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneActivityQuery, FindOneActivityQueryVariables>(
    FindOneActivityDocument,
    baseOptions,
  );
}
export function useFindOneActivityLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneActivityQuery, FindOneActivityQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneActivityQuery, FindOneActivityQueryVariables>(
    FindOneActivityDocument,
    baseOptions,
  );
}
export type FindOneActivityQueryHookResult = ReturnType<typeof useFindOneActivityQuery>;
export type FindOneActivityLazyQueryHookResult = ReturnType<typeof useFindOneActivityLazyQuery>;
export type FindOneActivityQueryResult = ApolloReactCommon.QueryResult<
  FindOneActivityQuery,
  FindOneActivityQueryVariables
>;
export const FindManyActivityDocument = gql`
  query findManyActivity(
    $where: ActivityWhereInput
    $orderBy: ActivityOrderByInput
    $after: ActivityWhereUniqueInput
    $before: ActivityWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyActivity(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...ActivityFragment
    }
  }
  ${ActivityFragmentFragmentDoc}
`;

/**
 * __useFindManyActivityQuery__
 *
 * To run a query within a React component, call `useFindManyActivityQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyActivityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyActivityQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyActivityQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyActivityQuery, FindManyActivityQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyActivityQuery, FindManyActivityQueryVariables>(
    FindManyActivityDocument,
    baseOptions,
  );
}
export function useFindManyActivityLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyActivityQuery, FindManyActivityQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyActivityQuery, FindManyActivityQueryVariables>(
    FindManyActivityDocument,
    baseOptions,
  );
}
export type FindManyActivityQueryHookResult = ReturnType<typeof useFindManyActivityQuery>;
export type FindManyActivityLazyQueryHookResult = ReturnType<typeof useFindManyActivityLazyQuery>;
export type FindManyActivityQueryResult = ApolloReactCommon.QueryResult<
  FindManyActivityQuery,
  FindManyActivityQueryVariables
>;
export const FindManyActivityCountDocument = gql`
  query findManyActivityCount(
    $where: ActivityWhereInput
    $orderBy: ActivityOrderByInput
    $after: ActivityWhereUniqueInput
    $before: ActivityWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyActivityCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyActivityCountQuery__
 *
 * To run a query within a React component, call `useFindManyActivityCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyActivityCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyActivityCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyActivityCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyActivityCountQuery, FindManyActivityCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyActivityCountQuery, FindManyActivityCountQueryVariables>(
    FindManyActivityCountDocument,
    baseOptions,
  );
}
export function useFindManyActivityCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyActivityCountQuery, FindManyActivityCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyActivityCountQuery, FindManyActivityCountQueryVariables>(
    FindManyActivityCountDocument,
    baseOptions,
  );
}
export type FindManyActivityCountQueryHookResult = ReturnType<typeof useFindManyActivityCountQuery>;
export type FindManyActivityCountLazyQueryHookResult = ReturnType<typeof useFindManyActivityCountLazyQuery>;
export type FindManyActivityCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyActivityCountQuery,
  FindManyActivityCountQueryVariables
>;
export const CreateOneActivityDocument = gql`
  mutation createOneActivity($data: ActivityCreateInput!) {
    createOneActivity(data: $data) {
      ...ActivityFragment
    }
  }
  ${ActivityFragmentFragmentDoc}
`;

/**
 * __useCreateOneActivityMutation__
 *
 * To run a mutation, you first call `useCreateOneActivityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneActivityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneActivityMutation, { data, loading, error }] = useCreateOneActivityMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneActivityMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneActivityMutation, CreateOneActivityMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneActivityMutation, CreateOneActivityMutationVariables>(
    CreateOneActivityDocument,
    baseOptions,
  );
}
export type CreateOneActivityMutationHookResult = ReturnType<typeof useCreateOneActivityMutation>;
export type CreateOneActivityMutationResult = ApolloReactCommon.MutationResult<CreateOneActivityMutation>;
export type CreateOneActivityMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneActivityMutation,
  CreateOneActivityMutationVariables
>;
export const UpdateOneActivityDocument = gql`
  mutation updateOneActivity($where: ActivityWhereUniqueInput!, $data: ActivityUpdateInput!) {
    updateOneActivity(where: $where, data: $data) {
      ...ActivityFragment
    }
  }
  ${ActivityFragmentFragmentDoc}
`;

/**
 * __useUpdateOneActivityMutation__
 *
 * To run a mutation, you first call `useUpdateOneActivityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneActivityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneActivityMutation, { data, loading, error }] = useUpdateOneActivityMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneActivityMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneActivityMutation, UpdateOneActivityMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneActivityMutation, UpdateOneActivityMutationVariables>(
    UpdateOneActivityDocument,
    baseOptions,
  );
}
export type UpdateOneActivityMutationHookResult = ReturnType<typeof useUpdateOneActivityMutation>;
export type UpdateOneActivityMutationResult = ApolloReactCommon.MutationResult<UpdateOneActivityMutation>;
export type UpdateOneActivityMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneActivityMutation,
  UpdateOneActivityMutationVariables
>;
export const DeleteOneActivityDocument = gql`
  mutation deleteOneActivity($where: ActivityWhereUniqueInput!) {
    deleteOneActivity(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneActivityMutation__
 *
 * To run a mutation, you first call `useDeleteOneActivityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneActivityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneActivityMutation, { data, loading, error }] = useDeleteOneActivityMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneActivityMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneActivityMutation, DeleteOneActivityMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneActivityMutation, DeleteOneActivityMutationVariables>(
    DeleteOneActivityDocument,
    baseOptions,
  );
}
export type DeleteOneActivityMutationHookResult = ReturnType<typeof useDeleteOneActivityMutation>;
export type DeleteOneActivityMutationResult = ApolloReactCommon.MutationResult<DeleteOneActivityMutation>;
export type DeleteOneActivityMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneActivityMutation,
  DeleteOneActivityMutationVariables
>;
export const DeleteManyActivityDocument = gql`
  mutation deleteManyActivity($where: ActivityWhereInput) {
    deleteManyActivity(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyActivityMutation__
 *
 * To run a mutation, you first call `useDeleteManyActivityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyActivityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyActivityMutation, { data, loading, error }] = useDeleteManyActivityMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyActivityMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyActivityMutation, DeleteManyActivityMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyActivityMutation, DeleteManyActivityMutationVariables>(
    DeleteManyActivityDocument,
    baseOptions,
  );
}
export type DeleteManyActivityMutationHookResult = ReturnType<typeof useDeleteManyActivityMutation>;
export type DeleteManyActivityMutationResult = ApolloReactCommon.MutationResult<DeleteManyActivityMutation>;
export type DeleteManyActivityMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyActivityMutation,
  DeleteManyActivityMutationVariables
>;
export const UpdateManyActivityDocument = gql`
  mutation updateManyActivity($where: ActivityWhereInput, $data: ActivityUpdateManyMutationInput!) {
    updateManyActivity(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyActivityMutation__
 *
 * To run a mutation, you first call `useUpdateManyActivityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyActivityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyActivityMutation, { data, loading, error }] = useUpdateManyActivityMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyActivityMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyActivityMutation, UpdateManyActivityMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyActivityMutation, UpdateManyActivityMutationVariables>(
    UpdateManyActivityDocument,
    baseOptions,
  );
}
export type UpdateManyActivityMutationHookResult = ReturnType<typeof useUpdateManyActivityMutation>;
export type UpdateManyActivityMutationResult = ApolloReactCommon.MutationResult<UpdateManyActivityMutation>;
export type UpdateManyActivityMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyActivityMutation,
  UpdateManyActivityMutationVariables
>;
export const FindOneAssessmentContentQuestionDocument = gql`
  query findOneAssessmentContentQuestion($where: AssessmentContentQuestionWhereUniqueInput!) {
    findOneAssessmentContentQuestion(where: $where) {
      ...AssessmentContentQuestionFragment
    }
  }
  ${AssessmentContentQuestionFragmentFragmentDoc}
`;

/**
 * __useFindOneAssessmentContentQuestionQuery__
 *
 * To run a query within a React component, call `useFindOneAssessmentContentQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssessmentContentQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssessmentContentQuestionQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssessmentContentQuestionQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssessmentContentQuestionQuery,
    FindOneAssessmentContentQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindOneAssessmentContentQuestionQuery,
    FindOneAssessmentContentQuestionQueryVariables
  >(FindOneAssessmentContentQuestionDocument, baseOptions);
}
export function useFindOneAssessmentContentQuestionLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssessmentContentQuestionQuery,
    FindOneAssessmentContentQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneAssessmentContentQuestionQuery,
    FindOneAssessmentContentQuestionQueryVariables
  >(FindOneAssessmentContentQuestionDocument, baseOptions);
}
export type FindOneAssessmentContentQuestionQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionQuery
>;
export type FindOneAssessmentContentQuestionLazyQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionLazyQuery
>;
export type FindOneAssessmentContentQuestionQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssessmentContentQuestionQuery,
  FindOneAssessmentContentQuestionQueryVariables
>;
export const FindManyAssessmentContentQuestionDocument = gql`
  query findManyAssessmentContentQuestion(
    $where: AssessmentContentQuestionWhereInput
    $orderBy: AssessmentContentQuestionOrderByInput
    $after: AssessmentContentQuestionWhereUniqueInput
    $before: AssessmentContentQuestionWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestion(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssessmentContentQuestionFragment
    }
  }
  ${AssessmentContentQuestionFragmentFragmentDoc}
`;

/**
 * __useFindManyAssessmentContentQuestionQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionQuery,
    FindManyAssessmentContentQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionQuery,
    FindManyAssessmentContentQuestionQueryVariables
  >(FindManyAssessmentContentQuestionDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionQuery,
    FindManyAssessmentContentQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionQuery,
    FindManyAssessmentContentQuestionQueryVariables
  >(FindManyAssessmentContentQuestionDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionQuery
>;
export type FindManyAssessmentContentQuestionLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionLazyQuery
>;
export type FindManyAssessmentContentQuestionQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionQuery,
  FindManyAssessmentContentQuestionQueryVariables
>;
export const FindManyAssessmentContentQuestionCountDocument = gql`
  query findManyAssessmentContentQuestionCount(
    $where: AssessmentContentQuestionWhereInput
    $orderBy: AssessmentContentQuestionOrderByInput
    $after: AssessmentContentQuestionWhereUniqueInput
    $before: AssessmentContentQuestionWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssessmentContentQuestionCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionCountQuery,
    FindManyAssessmentContentQuestionCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionCountQuery,
    FindManyAssessmentContentQuestionCountQueryVariables
  >(FindManyAssessmentContentQuestionCountDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionCountQuery,
    FindManyAssessmentContentQuestionCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionCountQuery,
    FindManyAssessmentContentQuestionCountQueryVariables
  >(FindManyAssessmentContentQuestionCountDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionCountQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionCountQuery
>;
export type FindManyAssessmentContentQuestionCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionCountLazyQuery
>;
export type FindManyAssessmentContentQuestionCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionCountQuery,
  FindManyAssessmentContentQuestionCountQueryVariables
>;
export const CreateOneAssessmentContentQuestionDocument = gql`
  mutation createOneAssessmentContentQuestion($data: AssessmentContentQuestionCreateInput!) {
    createOneAssessmentContentQuestion(data: $data) {
      ...AssessmentContentQuestionFragment
    }
  }
  ${AssessmentContentQuestionFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssessmentContentQuestionMutation__
 *
 * To run a mutation, you first call `useCreateOneAssessmentContentQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssessmentContentQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssessmentContentQuestionMutation, { data, loading, error }] = useCreateOneAssessmentContentQuestionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssessmentContentQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssessmentContentQuestionMutation,
    CreateOneAssessmentContentQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssessmentContentQuestionMutation,
    CreateOneAssessmentContentQuestionMutationVariables
  >(CreateOneAssessmentContentQuestionDocument, baseOptions);
}
export type CreateOneAssessmentContentQuestionMutationHookResult = ReturnType<
  typeof useCreateOneAssessmentContentQuestionMutation
>;
export type CreateOneAssessmentContentQuestionMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssessmentContentQuestionMutation
>;
export type CreateOneAssessmentContentQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssessmentContentQuestionMutation,
  CreateOneAssessmentContentQuestionMutationVariables
>;
export const UpdateOneAssessmentContentQuestionDocument = gql`
  mutation updateOneAssessmentContentQuestion(
    $where: AssessmentContentQuestionWhereUniqueInput!
    $data: AssessmentContentQuestionUpdateInput!
  ) {
    updateOneAssessmentContentQuestion(where: $where, data: $data) {
      ...AssessmentContentQuestionFragment
    }
  }
  ${AssessmentContentQuestionFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssessmentContentQuestionMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssessmentContentQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssessmentContentQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssessmentContentQuestionMutation, { data, loading, error }] = useUpdateOneAssessmentContentQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssessmentContentQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssessmentContentQuestionMutation,
    UpdateOneAssessmentContentQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssessmentContentQuestionMutation,
    UpdateOneAssessmentContentQuestionMutationVariables
  >(UpdateOneAssessmentContentQuestionDocument, baseOptions);
}
export type UpdateOneAssessmentContentQuestionMutationHookResult = ReturnType<
  typeof useUpdateOneAssessmentContentQuestionMutation
>;
export type UpdateOneAssessmentContentQuestionMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssessmentContentQuestionMutation
>;
export type UpdateOneAssessmentContentQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssessmentContentQuestionMutation,
  UpdateOneAssessmentContentQuestionMutationVariables
>;
export const DeleteOneAssessmentContentQuestionDocument = gql`
  mutation deleteOneAssessmentContentQuestion($where: AssessmentContentQuestionWhereUniqueInput!) {
    deleteOneAssessmentContentQuestion(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssessmentContentQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssessmentContentQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssessmentContentQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssessmentContentQuestionMutation, { data, loading, error }] = useDeleteOneAssessmentContentQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssessmentContentQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssessmentContentQuestionMutation,
    DeleteOneAssessmentContentQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssessmentContentQuestionMutation,
    DeleteOneAssessmentContentQuestionMutationVariables
  >(DeleteOneAssessmentContentQuestionDocument, baseOptions);
}
export type DeleteOneAssessmentContentQuestionMutationHookResult = ReturnType<
  typeof useDeleteOneAssessmentContentQuestionMutation
>;
export type DeleteOneAssessmentContentQuestionMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssessmentContentQuestionMutation
>;
export type DeleteOneAssessmentContentQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssessmentContentQuestionMutation,
  DeleteOneAssessmentContentQuestionMutationVariables
>;
export const DeleteManyAssessmentContentQuestionDocument = gql`
  mutation deleteManyAssessmentContentQuestion($where: AssessmentContentQuestionWhereInput) {
    deleteManyAssessmentContentQuestion(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssessmentContentQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssessmentContentQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssessmentContentQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssessmentContentQuestionMutation, { data, loading, error }] = useDeleteManyAssessmentContentQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssessmentContentQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssessmentContentQuestionMutation,
    DeleteManyAssessmentContentQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssessmentContentQuestionMutation,
    DeleteManyAssessmentContentQuestionMutationVariables
  >(DeleteManyAssessmentContentQuestionDocument, baseOptions);
}
export type DeleteManyAssessmentContentQuestionMutationHookResult = ReturnType<
  typeof useDeleteManyAssessmentContentQuestionMutation
>;
export type DeleteManyAssessmentContentQuestionMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssessmentContentQuestionMutation
>;
export type DeleteManyAssessmentContentQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssessmentContentQuestionMutation,
  DeleteManyAssessmentContentQuestionMutationVariables
>;
export const UpdateManyAssessmentContentQuestionDocument = gql`
  mutation updateManyAssessmentContentQuestion(
    $where: AssessmentContentQuestionWhereInput
    $data: AssessmentContentQuestionUpdateManyMutationInput!
  ) {
    updateManyAssessmentContentQuestion(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssessmentContentQuestionMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssessmentContentQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssessmentContentQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssessmentContentQuestionMutation, { data, loading, error }] = useUpdateManyAssessmentContentQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssessmentContentQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssessmentContentQuestionMutation,
    UpdateManyAssessmentContentQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssessmentContentQuestionMutation,
    UpdateManyAssessmentContentQuestionMutationVariables
  >(UpdateManyAssessmentContentQuestionDocument, baseOptions);
}
export type UpdateManyAssessmentContentQuestionMutationHookResult = ReturnType<
  typeof useUpdateManyAssessmentContentQuestionMutation
>;
export type UpdateManyAssessmentContentQuestionMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssessmentContentQuestionMutation
>;
export type UpdateManyAssessmentContentQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssessmentContentQuestionMutation,
  UpdateManyAssessmentContentQuestionMutationVariables
>;
export const FindOneAssessmentContentQuestionAnswerDocument = gql`
  query findOneAssessmentContentQuestionAnswer($where: AssessmentContentQuestionAnswerWhereUniqueInput!) {
    findOneAssessmentContentQuestionAnswer(where: $where) {
      ...AssessmentContentQuestionAnswerFragment
    }
  }
  ${AssessmentContentQuestionAnswerFragmentFragmentDoc}
`;

/**
 * __useFindOneAssessmentContentQuestionAnswerQuery__
 *
 * To run a query within a React component, call `useFindOneAssessmentContentQuestionAnswerQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssessmentContentQuestionAnswerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssessmentContentQuestionAnswerQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssessmentContentQuestionAnswerQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssessmentContentQuestionAnswerQuery,
    FindOneAssessmentContentQuestionAnswerQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindOneAssessmentContentQuestionAnswerQuery,
    FindOneAssessmentContentQuestionAnswerQueryVariables
  >(FindOneAssessmentContentQuestionAnswerDocument, baseOptions);
}
export function useFindOneAssessmentContentQuestionAnswerLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssessmentContentQuestionAnswerQuery,
    FindOneAssessmentContentQuestionAnswerQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneAssessmentContentQuestionAnswerQuery,
    FindOneAssessmentContentQuestionAnswerQueryVariables
  >(FindOneAssessmentContentQuestionAnswerDocument, baseOptions);
}
export type FindOneAssessmentContentQuestionAnswerQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionAnswerQuery
>;
export type FindOneAssessmentContentQuestionAnswerLazyQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionAnswerLazyQuery
>;
export type FindOneAssessmentContentQuestionAnswerQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssessmentContentQuestionAnswerQuery,
  FindOneAssessmentContentQuestionAnswerQueryVariables
>;
export const FindManyAssessmentContentQuestionAnswerDocument = gql`
  query findManyAssessmentContentQuestionAnswer(
    $where: AssessmentContentQuestionAnswerWhereInput
    $orderBy: AssessmentContentQuestionAnswerOrderByInput
    $after: AssessmentContentQuestionAnswerWhereUniqueInput
    $before: AssessmentContentQuestionAnswerWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionAnswer(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssessmentContentQuestionAnswerFragment
    }
  }
  ${AssessmentContentQuestionAnswerFragmentFragmentDoc}
`;

/**
 * __useFindManyAssessmentContentQuestionAnswerQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionAnswerQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionAnswerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionAnswerQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionAnswerQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionAnswerQuery,
    FindManyAssessmentContentQuestionAnswerQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionAnswerQuery,
    FindManyAssessmentContentQuestionAnswerQueryVariables
  >(FindManyAssessmentContentQuestionAnswerDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionAnswerLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionAnswerQuery,
    FindManyAssessmentContentQuestionAnswerQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionAnswerQuery,
    FindManyAssessmentContentQuestionAnswerQueryVariables
  >(FindManyAssessmentContentQuestionAnswerDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionAnswerQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionAnswerQuery
>;
export type FindManyAssessmentContentQuestionAnswerLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionAnswerLazyQuery
>;
export type FindManyAssessmentContentQuestionAnswerQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionAnswerQuery,
  FindManyAssessmentContentQuestionAnswerQueryVariables
>;
export const FindManyAssessmentContentQuestionAnswerCountDocument = gql`
  query findManyAssessmentContentQuestionAnswerCount(
    $where: AssessmentContentQuestionAnswerWhereInput
    $orderBy: AssessmentContentQuestionAnswerOrderByInput
    $after: AssessmentContentQuestionAnswerWhereUniqueInput
    $before: AssessmentContentQuestionAnswerWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionAnswerCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssessmentContentQuestionAnswerCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionAnswerCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionAnswerCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionAnswerCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionAnswerCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionAnswerCountQuery,
    FindManyAssessmentContentQuestionAnswerCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionAnswerCountQuery,
    FindManyAssessmentContentQuestionAnswerCountQueryVariables
  >(FindManyAssessmentContentQuestionAnswerCountDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionAnswerCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionAnswerCountQuery,
    FindManyAssessmentContentQuestionAnswerCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionAnswerCountQuery,
    FindManyAssessmentContentQuestionAnswerCountQueryVariables
  >(FindManyAssessmentContentQuestionAnswerCountDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionAnswerCountQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionAnswerCountQuery
>;
export type FindManyAssessmentContentQuestionAnswerCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionAnswerCountLazyQuery
>;
export type FindManyAssessmentContentQuestionAnswerCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionAnswerCountQuery,
  FindManyAssessmentContentQuestionAnswerCountQueryVariables
>;
export const CreateOneAssessmentContentQuestionAnswerDocument = gql`
  mutation createOneAssessmentContentQuestionAnswer($data: AssessmentContentQuestionAnswerCreateInput!) {
    createOneAssessmentContentQuestionAnswer(data: $data) {
      ...AssessmentContentQuestionAnswerFragment
    }
  }
  ${AssessmentContentQuestionAnswerFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssessmentContentQuestionAnswerMutation__
 *
 * To run a mutation, you first call `useCreateOneAssessmentContentQuestionAnswerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssessmentContentQuestionAnswerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssessmentContentQuestionAnswerMutation, { data, loading, error }] = useCreateOneAssessmentContentQuestionAnswerMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssessmentContentQuestionAnswerMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssessmentContentQuestionAnswerMutation,
    CreateOneAssessmentContentQuestionAnswerMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssessmentContentQuestionAnswerMutation,
    CreateOneAssessmentContentQuestionAnswerMutationVariables
  >(CreateOneAssessmentContentQuestionAnswerDocument, baseOptions);
}
export type CreateOneAssessmentContentQuestionAnswerMutationHookResult = ReturnType<
  typeof useCreateOneAssessmentContentQuestionAnswerMutation
>;
export type CreateOneAssessmentContentQuestionAnswerMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssessmentContentQuestionAnswerMutation
>;
export type CreateOneAssessmentContentQuestionAnswerMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssessmentContentQuestionAnswerMutation,
  CreateOneAssessmentContentQuestionAnswerMutationVariables
>;
export const UpdateOneAssessmentContentQuestionAnswerDocument = gql`
  mutation updateOneAssessmentContentQuestionAnswer(
    $where: AssessmentContentQuestionAnswerWhereUniqueInput!
    $data: AssessmentContentQuestionAnswerUpdateInput!
  ) {
    updateOneAssessmentContentQuestionAnswer(where: $where, data: $data) {
      ...AssessmentContentQuestionAnswerFragment
    }
  }
  ${AssessmentContentQuestionAnswerFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssessmentContentQuestionAnswerMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssessmentContentQuestionAnswerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssessmentContentQuestionAnswerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssessmentContentQuestionAnswerMutation, { data, loading, error }] = useUpdateOneAssessmentContentQuestionAnswerMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssessmentContentQuestionAnswerMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssessmentContentQuestionAnswerMutation,
    UpdateOneAssessmentContentQuestionAnswerMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssessmentContentQuestionAnswerMutation,
    UpdateOneAssessmentContentQuestionAnswerMutationVariables
  >(UpdateOneAssessmentContentQuestionAnswerDocument, baseOptions);
}
export type UpdateOneAssessmentContentQuestionAnswerMutationHookResult = ReturnType<
  typeof useUpdateOneAssessmentContentQuestionAnswerMutation
>;
export type UpdateOneAssessmentContentQuestionAnswerMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssessmentContentQuestionAnswerMutation
>;
export type UpdateOneAssessmentContentQuestionAnswerMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssessmentContentQuestionAnswerMutation,
  UpdateOneAssessmentContentQuestionAnswerMutationVariables
>;
export const DeleteOneAssessmentContentQuestionAnswerDocument = gql`
  mutation deleteOneAssessmentContentQuestionAnswer($where: AssessmentContentQuestionAnswerWhereUniqueInput!) {
    deleteOneAssessmentContentQuestionAnswer(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssessmentContentQuestionAnswerMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssessmentContentQuestionAnswerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssessmentContentQuestionAnswerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssessmentContentQuestionAnswerMutation, { data, loading, error }] = useDeleteOneAssessmentContentQuestionAnswerMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssessmentContentQuestionAnswerMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssessmentContentQuestionAnswerMutation,
    DeleteOneAssessmentContentQuestionAnswerMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssessmentContentQuestionAnswerMutation,
    DeleteOneAssessmentContentQuestionAnswerMutationVariables
  >(DeleteOneAssessmentContentQuestionAnswerDocument, baseOptions);
}
export type DeleteOneAssessmentContentQuestionAnswerMutationHookResult = ReturnType<
  typeof useDeleteOneAssessmentContentQuestionAnswerMutation
>;
export type DeleteOneAssessmentContentQuestionAnswerMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssessmentContentQuestionAnswerMutation
>;
export type DeleteOneAssessmentContentQuestionAnswerMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssessmentContentQuestionAnswerMutation,
  DeleteOneAssessmentContentQuestionAnswerMutationVariables
>;
export const DeleteManyAssessmentContentQuestionAnswerDocument = gql`
  mutation deleteManyAssessmentContentQuestionAnswer($where: AssessmentContentQuestionAnswerWhereInput) {
    deleteManyAssessmentContentQuestionAnswer(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssessmentContentQuestionAnswerMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssessmentContentQuestionAnswerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssessmentContentQuestionAnswerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssessmentContentQuestionAnswerMutation, { data, loading, error }] = useDeleteManyAssessmentContentQuestionAnswerMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssessmentContentQuestionAnswerMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssessmentContentQuestionAnswerMutation,
    DeleteManyAssessmentContentQuestionAnswerMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssessmentContentQuestionAnswerMutation,
    DeleteManyAssessmentContentQuestionAnswerMutationVariables
  >(DeleteManyAssessmentContentQuestionAnswerDocument, baseOptions);
}
export type DeleteManyAssessmentContentQuestionAnswerMutationHookResult = ReturnType<
  typeof useDeleteManyAssessmentContentQuestionAnswerMutation
>;
export type DeleteManyAssessmentContentQuestionAnswerMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssessmentContentQuestionAnswerMutation
>;
export type DeleteManyAssessmentContentQuestionAnswerMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssessmentContentQuestionAnswerMutation,
  DeleteManyAssessmentContentQuestionAnswerMutationVariables
>;
export const UpdateManyAssessmentContentQuestionAnswerDocument = gql`
  mutation updateManyAssessmentContentQuestionAnswer(
    $where: AssessmentContentQuestionAnswerWhereInput
    $data: AssessmentContentQuestionAnswerUpdateManyMutationInput!
  ) {
    updateManyAssessmentContentQuestionAnswer(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssessmentContentQuestionAnswerMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssessmentContentQuestionAnswerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssessmentContentQuestionAnswerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssessmentContentQuestionAnswerMutation, { data, loading, error }] = useUpdateManyAssessmentContentQuestionAnswerMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssessmentContentQuestionAnswerMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssessmentContentQuestionAnswerMutation,
    UpdateManyAssessmentContentQuestionAnswerMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssessmentContentQuestionAnswerMutation,
    UpdateManyAssessmentContentQuestionAnswerMutationVariables
  >(UpdateManyAssessmentContentQuestionAnswerDocument, baseOptions);
}
export type UpdateManyAssessmentContentQuestionAnswerMutationHookResult = ReturnType<
  typeof useUpdateManyAssessmentContentQuestionAnswerMutation
>;
export type UpdateManyAssessmentContentQuestionAnswerMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssessmentContentQuestionAnswerMutation
>;
export type UpdateManyAssessmentContentQuestionAnswerMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssessmentContentQuestionAnswerMutation,
  UpdateManyAssessmentContentQuestionAnswerMutationVariables
>;
export const FindOneAssessmentContentQuestionOptionDocument = gql`
  query findOneAssessmentContentQuestionOption($where: AssessmentContentQuestionOptionWhereUniqueInput!) {
    findOneAssessmentContentQuestionOption(where: $where) {
      ...AssessmentContentQuestionOptionFragment
    }
  }
  ${AssessmentContentQuestionOptionFragmentFragmentDoc}
`;

/**
 * __useFindOneAssessmentContentQuestionOptionQuery__
 *
 * To run a query within a React component, call `useFindOneAssessmentContentQuestionOptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssessmentContentQuestionOptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssessmentContentQuestionOptionQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssessmentContentQuestionOptionQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssessmentContentQuestionOptionQuery,
    FindOneAssessmentContentQuestionOptionQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindOneAssessmentContentQuestionOptionQuery,
    FindOneAssessmentContentQuestionOptionQueryVariables
  >(FindOneAssessmentContentQuestionOptionDocument, baseOptions);
}
export function useFindOneAssessmentContentQuestionOptionLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssessmentContentQuestionOptionQuery,
    FindOneAssessmentContentQuestionOptionQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneAssessmentContentQuestionOptionQuery,
    FindOneAssessmentContentQuestionOptionQueryVariables
  >(FindOneAssessmentContentQuestionOptionDocument, baseOptions);
}
export type FindOneAssessmentContentQuestionOptionQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionOptionQuery
>;
export type FindOneAssessmentContentQuestionOptionLazyQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionOptionLazyQuery
>;
export type FindOneAssessmentContentQuestionOptionQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssessmentContentQuestionOptionQuery,
  FindOneAssessmentContentQuestionOptionQueryVariables
>;
export const FindManyAssessmentContentQuestionOptionDocument = gql`
  query findManyAssessmentContentQuestionOption(
    $where: AssessmentContentQuestionOptionWhereInput
    $orderBy: AssessmentContentQuestionOptionOrderByInput
    $after: AssessmentContentQuestionOptionWhereUniqueInput
    $before: AssessmentContentQuestionOptionWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionOption(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssessmentContentQuestionOptionFragment
    }
  }
  ${AssessmentContentQuestionOptionFragmentFragmentDoc}
`;

/**
 * __useFindManyAssessmentContentQuestionOptionQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionOptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionOptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionOptionQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionOptionQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionOptionQuery,
    FindManyAssessmentContentQuestionOptionQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionOptionQuery,
    FindManyAssessmentContentQuestionOptionQueryVariables
  >(FindManyAssessmentContentQuestionOptionDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionOptionLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionOptionQuery,
    FindManyAssessmentContentQuestionOptionQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionOptionQuery,
    FindManyAssessmentContentQuestionOptionQueryVariables
  >(FindManyAssessmentContentQuestionOptionDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionOptionQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionOptionQuery
>;
export type FindManyAssessmentContentQuestionOptionLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionOptionLazyQuery
>;
export type FindManyAssessmentContentQuestionOptionQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionOptionQuery,
  FindManyAssessmentContentQuestionOptionQueryVariables
>;
export const FindManyAssessmentContentQuestionOptionCountDocument = gql`
  query findManyAssessmentContentQuestionOptionCount(
    $where: AssessmentContentQuestionOptionWhereInput
    $orderBy: AssessmentContentQuestionOptionOrderByInput
    $after: AssessmentContentQuestionOptionWhereUniqueInput
    $before: AssessmentContentQuestionOptionWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionOptionCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssessmentContentQuestionOptionCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionOptionCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionOptionCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionOptionCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionOptionCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionOptionCountQuery,
    FindManyAssessmentContentQuestionOptionCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionOptionCountQuery,
    FindManyAssessmentContentQuestionOptionCountQueryVariables
  >(FindManyAssessmentContentQuestionOptionCountDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionOptionCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionOptionCountQuery,
    FindManyAssessmentContentQuestionOptionCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionOptionCountQuery,
    FindManyAssessmentContentQuestionOptionCountQueryVariables
  >(FindManyAssessmentContentQuestionOptionCountDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionOptionCountQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionOptionCountQuery
>;
export type FindManyAssessmentContentQuestionOptionCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionOptionCountLazyQuery
>;
export type FindManyAssessmentContentQuestionOptionCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionOptionCountQuery,
  FindManyAssessmentContentQuestionOptionCountQueryVariables
>;
export const CreateOneAssessmentContentQuestionOptionDocument = gql`
  mutation createOneAssessmentContentQuestionOption($data: AssessmentContentQuestionOptionCreateInput!) {
    createOneAssessmentContentQuestionOption(data: $data) {
      ...AssessmentContentQuestionOptionFragment
    }
  }
  ${AssessmentContentQuestionOptionFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssessmentContentQuestionOptionMutation__
 *
 * To run a mutation, you first call `useCreateOneAssessmentContentQuestionOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssessmentContentQuestionOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssessmentContentQuestionOptionMutation, { data, loading, error }] = useCreateOneAssessmentContentQuestionOptionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssessmentContentQuestionOptionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssessmentContentQuestionOptionMutation,
    CreateOneAssessmentContentQuestionOptionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssessmentContentQuestionOptionMutation,
    CreateOneAssessmentContentQuestionOptionMutationVariables
  >(CreateOneAssessmentContentQuestionOptionDocument, baseOptions);
}
export type CreateOneAssessmentContentQuestionOptionMutationHookResult = ReturnType<
  typeof useCreateOneAssessmentContentQuestionOptionMutation
>;
export type CreateOneAssessmentContentQuestionOptionMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssessmentContentQuestionOptionMutation
>;
export type CreateOneAssessmentContentQuestionOptionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssessmentContentQuestionOptionMutation,
  CreateOneAssessmentContentQuestionOptionMutationVariables
>;
export const UpdateOneAssessmentContentQuestionOptionDocument = gql`
  mutation updateOneAssessmentContentQuestionOption(
    $where: AssessmentContentQuestionOptionWhereUniqueInput!
    $data: AssessmentContentQuestionOptionUpdateInput!
  ) {
    updateOneAssessmentContentQuestionOption(where: $where, data: $data) {
      ...AssessmentContentQuestionOptionFragment
    }
  }
  ${AssessmentContentQuestionOptionFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssessmentContentQuestionOptionMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssessmentContentQuestionOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssessmentContentQuestionOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssessmentContentQuestionOptionMutation, { data, loading, error }] = useUpdateOneAssessmentContentQuestionOptionMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssessmentContentQuestionOptionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssessmentContentQuestionOptionMutation,
    UpdateOneAssessmentContentQuestionOptionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssessmentContentQuestionOptionMutation,
    UpdateOneAssessmentContentQuestionOptionMutationVariables
  >(UpdateOneAssessmentContentQuestionOptionDocument, baseOptions);
}
export type UpdateOneAssessmentContentQuestionOptionMutationHookResult = ReturnType<
  typeof useUpdateOneAssessmentContentQuestionOptionMutation
>;
export type UpdateOneAssessmentContentQuestionOptionMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssessmentContentQuestionOptionMutation
>;
export type UpdateOneAssessmentContentQuestionOptionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssessmentContentQuestionOptionMutation,
  UpdateOneAssessmentContentQuestionOptionMutationVariables
>;
export const DeleteOneAssessmentContentQuestionOptionDocument = gql`
  mutation deleteOneAssessmentContentQuestionOption($where: AssessmentContentQuestionOptionWhereUniqueInput!) {
    deleteOneAssessmentContentQuestionOption(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssessmentContentQuestionOptionMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssessmentContentQuestionOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssessmentContentQuestionOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssessmentContentQuestionOptionMutation, { data, loading, error }] = useDeleteOneAssessmentContentQuestionOptionMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssessmentContentQuestionOptionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssessmentContentQuestionOptionMutation,
    DeleteOneAssessmentContentQuestionOptionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssessmentContentQuestionOptionMutation,
    DeleteOneAssessmentContentQuestionOptionMutationVariables
  >(DeleteOneAssessmentContentQuestionOptionDocument, baseOptions);
}
export type DeleteOneAssessmentContentQuestionOptionMutationHookResult = ReturnType<
  typeof useDeleteOneAssessmentContentQuestionOptionMutation
>;
export type DeleteOneAssessmentContentQuestionOptionMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssessmentContentQuestionOptionMutation
>;
export type DeleteOneAssessmentContentQuestionOptionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssessmentContentQuestionOptionMutation,
  DeleteOneAssessmentContentQuestionOptionMutationVariables
>;
export const DeleteManyAssessmentContentQuestionOptionDocument = gql`
  mutation deleteManyAssessmentContentQuestionOption($where: AssessmentContentQuestionOptionWhereInput) {
    deleteManyAssessmentContentQuestionOption(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssessmentContentQuestionOptionMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssessmentContentQuestionOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssessmentContentQuestionOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssessmentContentQuestionOptionMutation, { data, loading, error }] = useDeleteManyAssessmentContentQuestionOptionMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssessmentContentQuestionOptionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssessmentContentQuestionOptionMutation,
    DeleteManyAssessmentContentQuestionOptionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssessmentContentQuestionOptionMutation,
    DeleteManyAssessmentContentQuestionOptionMutationVariables
  >(DeleteManyAssessmentContentQuestionOptionDocument, baseOptions);
}
export type DeleteManyAssessmentContentQuestionOptionMutationHookResult = ReturnType<
  typeof useDeleteManyAssessmentContentQuestionOptionMutation
>;
export type DeleteManyAssessmentContentQuestionOptionMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssessmentContentQuestionOptionMutation
>;
export type DeleteManyAssessmentContentQuestionOptionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssessmentContentQuestionOptionMutation,
  DeleteManyAssessmentContentQuestionOptionMutationVariables
>;
export const UpdateManyAssessmentContentQuestionOptionDocument = gql`
  mutation updateManyAssessmentContentQuestionOption(
    $where: AssessmentContentQuestionOptionWhereInput
    $data: AssessmentContentQuestionOptionUpdateManyMutationInput!
  ) {
    updateManyAssessmentContentQuestionOption(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssessmentContentQuestionOptionMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssessmentContentQuestionOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssessmentContentQuestionOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssessmentContentQuestionOptionMutation, { data, loading, error }] = useUpdateManyAssessmentContentQuestionOptionMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssessmentContentQuestionOptionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssessmentContentQuestionOptionMutation,
    UpdateManyAssessmentContentQuestionOptionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssessmentContentQuestionOptionMutation,
    UpdateManyAssessmentContentQuestionOptionMutationVariables
  >(UpdateManyAssessmentContentQuestionOptionDocument, baseOptions);
}
export type UpdateManyAssessmentContentQuestionOptionMutationHookResult = ReturnType<
  typeof useUpdateManyAssessmentContentQuestionOptionMutation
>;
export type UpdateManyAssessmentContentQuestionOptionMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssessmentContentQuestionOptionMutation
>;
export type UpdateManyAssessmentContentQuestionOptionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssessmentContentQuestionOptionMutation,
  UpdateManyAssessmentContentQuestionOptionMutationVariables
>;
export const FindOneAssessmentContentQuestionToolDocument = gql`
  query findOneAssessmentContentQuestionTool($where: AssessmentContentQuestionToolWhereUniqueInput!) {
    findOneAssessmentContentQuestionTool(where: $where) {
      ...AssessmentContentQuestionToolFragment
    }
  }
  ${AssessmentContentQuestionToolFragmentFragmentDoc}
`;

/**
 * __useFindOneAssessmentContentQuestionToolQuery__
 *
 * To run a query within a React component, call `useFindOneAssessmentContentQuestionToolQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssessmentContentQuestionToolQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssessmentContentQuestionToolQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssessmentContentQuestionToolQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssessmentContentQuestionToolQuery,
    FindOneAssessmentContentQuestionToolQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindOneAssessmentContentQuestionToolQuery,
    FindOneAssessmentContentQuestionToolQueryVariables
  >(FindOneAssessmentContentQuestionToolDocument, baseOptions);
}
export function useFindOneAssessmentContentQuestionToolLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssessmentContentQuestionToolQuery,
    FindOneAssessmentContentQuestionToolQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneAssessmentContentQuestionToolQuery,
    FindOneAssessmentContentQuestionToolQueryVariables
  >(FindOneAssessmentContentQuestionToolDocument, baseOptions);
}
export type FindOneAssessmentContentQuestionToolQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionToolQuery
>;
export type FindOneAssessmentContentQuestionToolLazyQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionToolLazyQuery
>;
export type FindOneAssessmentContentQuestionToolQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssessmentContentQuestionToolQuery,
  FindOneAssessmentContentQuestionToolQueryVariables
>;
export const FindManyAssessmentContentQuestionToolDocument = gql`
  query findManyAssessmentContentQuestionTool(
    $where: AssessmentContentQuestionToolWhereInput
    $orderBy: AssessmentContentQuestionToolOrderByInput
    $after: AssessmentContentQuestionToolWhereUniqueInput
    $before: AssessmentContentQuestionToolWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionTool(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssessmentContentQuestionToolFragment
    }
  }
  ${AssessmentContentQuestionToolFragmentFragmentDoc}
`;

/**
 * __useFindManyAssessmentContentQuestionToolQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionToolQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionToolQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionToolQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionToolQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionToolQuery,
    FindManyAssessmentContentQuestionToolQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionToolQuery,
    FindManyAssessmentContentQuestionToolQueryVariables
  >(FindManyAssessmentContentQuestionToolDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionToolLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionToolQuery,
    FindManyAssessmentContentQuestionToolQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionToolQuery,
    FindManyAssessmentContentQuestionToolQueryVariables
  >(FindManyAssessmentContentQuestionToolDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionToolQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionToolQuery
>;
export type FindManyAssessmentContentQuestionToolLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionToolLazyQuery
>;
export type FindManyAssessmentContentQuestionToolQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionToolQuery,
  FindManyAssessmentContentQuestionToolQueryVariables
>;
export const FindManyAssessmentContentQuestionToolCountDocument = gql`
  query findManyAssessmentContentQuestionToolCount(
    $where: AssessmentContentQuestionToolWhereInput
    $orderBy: AssessmentContentQuestionToolOrderByInput
    $after: AssessmentContentQuestionToolWhereUniqueInput
    $before: AssessmentContentQuestionToolWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionToolCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssessmentContentQuestionToolCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionToolCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionToolCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionToolCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionToolCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionToolCountQuery,
    FindManyAssessmentContentQuestionToolCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionToolCountQuery,
    FindManyAssessmentContentQuestionToolCountQueryVariables
  >(FindManyAssessmentContentQuestionToolCountDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionToolCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionToolCountQuery,
    FindManyAssessmentContentQuestionToolCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionToolCountQuery,
    FindManyAssessmentContentQuestionToolCountQueryVariables
  >(FindManyAssessmentContentQuestionToolCountDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionToolCountQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionToolCountQuery
>;
export type FindManyAssessmentContentQuestionToolCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionToolCountLazyQuery
>;
export type FindManyAssessmentContentQuestionToolCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionToolCountQuery,
  FindManyAssessmentContentQuestionToolCountQueryVariables
>;
export const CreateOneAssessmentContentQuestionToolDocument = gql`
  mutation createOneAssessmentContentQuestionTool($data: AssessmentContentQuestionToolCreateInput!) {
    createOneAssessmentContentQuestionTool(data: $data) {
      ...AssessmentContentQuestionToolFragment
    }
  }
  ${AssessmentContentQuestionToolFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssessmentContentQuestionToolMutation__
 *
 * To run a mutation, you first call `useCreateOneAssessmentContentQuestionToolMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssessmentContentQuestionToolMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssessmentContentQuestionToolMutation, { data, loading, error }] = useCreateOneAssessmentContentQuestionToolMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssessmentContentQuestionToolMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssessmentContentQuestionToolMutation,
    CreateOneAssessmentContentQuestionToolMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssessmentContentQuestionToolMutation,
    CreateOneAssessmentContentQuestionToolMutationVariables
  >(CreateOneAssessmentContentQuestionToolDocument, baseOptions);
}
export type CreateOneAssessmentContentQuestionToolMutationHookResult = ReturnType<
  typeof useCreateOneAssessmentContentQuestionToolMutation
>;
export type CreateOneAssessmentContentQuestionToolMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssessmentContentQuestionToolMutation
>;
export type CreateOneAssessmentContentQuestionToolMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssessmentContentQuestionToolMutation,
  CreateOneAssessmentContentQuestionToolMutationVariables
>;
export const UpdateOneAssessmentContentQuestionToolDocument = gql`
  mutation updateOneAssessmentContentQuestionTool(
    $where: AssessmentContentQuestionToolWhereUniqueInput!
    $data: AssessmentContentQuestionToolUpdateInput!
  ) {
    updateOneAssessmentContentQuestionTool(where: $where, data: $data) {
      ...AssessmentContentQuestionToolFragment
    }
  }
  ${AssessmentContentQuestionToolFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssessmentContentQuestionToolMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssessmentContentQuestionToolMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssessmentContentQuestionToolMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssessmentContentQuestionToolMutation, { data, loading, error }] = useUpdateOneAssessmentContentQuestionToolMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssessmentContentQuestionToolMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssessmentContentQuestionToolMutation,
    UpdateOneAssessmentContentQuestionToolMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssessmentContentQuestionToolMutation,
    UpdateOneAssessmentContentQuestionToolMutationVariables
  >(UpdateOneAssessmentContentQuestionToolDocument, baseOptions);
}
export type UpdateOneAssessmentContentQuestionToolMutationHookResult = ReturnType<
  typeof useUpdateOneAssessmentContentQuestionToolMutation
>;
export type UpdateOneAssessmentContentQuestionToolMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssessmentContentQuestionToolMutation
>;
export type UpdateOneAssessmentContentQuestionToolMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssessmentContentQuestionToolMutation,
  UpdateOneAssessmentContentQuestionToolMutationVariables
>;
export const DeleteOneAssessmentContentQuestionToolDocument = gql`
  mutation deleteOneAssessmentContentQuestionTool($where: AssessmentContentQuestionToolWhereUniqueInput!) {
    deleteOneAssessmentContentQuestionTool(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssessmentContentQuestionToolMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssessmentContentQuestionToolMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssessmentContentQuestionToolMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssessmentContentQuestionToolMutation, { data, loading, error }] = useDeleteOneAssessmentContentQuestionToolMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssessmentContentQuestionToolMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssessmentContentQuestionToolMutation,
    DeleteOneAssessmentContentQuestionToolMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssessmentContentQuestionToolMutation,
    DeleteOneAssessmentContentQuestionToolMutationVariables
  >(DeleteOneAssessmentContentQuestionToolDocument, baseOptions);
}
export type DeleteOneAssessmentContentQuestionToolMutationHookResult = ReturnType<
  typeof useDeleteOneAssessmentContentQuestionToolMutation
>;
export type DeleteOneAssessmentContentQuestionToolMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssessmentContentQuestionToolMutation
>;
export type DeleteOneAssessmentContentQuestionToolMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssessmentContentQuestionToolMutation,
  DeleteOneAssessmentContentQuestionToolMutationVariables
>;
export const DeleteManyAssessmentContentQuestionToolDocument = gql`
  mutation deleteManyAssessmentContentQuestionTool($where: AssessmentContentQuestionToolWhereInput) {
    deleteManyAssessmentContentQuestionTool(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssessmentContentQuestionToolMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssessmentContentQuestionToolMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssessmentContentQuestionToolMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssessmentContentQuestionToolMutation, { data, loading, error }] = useDeleteManyAssessmentContentQuestionToolMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssessmentContentQuestionToolMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssessmentContentQuestionToolMutation,
    DeleteManyAssessmentContentQuestionToolMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssessmentContentQuestionToolMutation,
    DeleteManyAssessmentContentQuestionToolMutationVariables
  >(DeleteManyAssessmentContentQuestionToolDocument, baseOptions);
}
export type DeleteManyAssessmentContentQuestionToolMutationHookResult = ReturnType<
  typeof useDeleteManyAssessmentContentQuestionToolMutation
>;
export type DeleteManyAssessmentContentQuestionToolMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssessmentContentQuestionToolMutation
>;
export type DeleteManyAssessmentContentQuestionToolMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssessmentContentQuestionToolMutation,
  DeleteManyAssessmentContentQuestionToolMutationVariables
>;
export const UpdateManyAssessmentContentQuestionToolDocument = gql`
  mutation updateManyAssessmentContentQuestionTool(
    $where: AssessmentContentQuestionToolWhereInput
    $data: AssessmentContentQuestionToolUpdateManyMutationInput!
  ) {
    updateManyAssessmentContentQuestionTool(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssessmentContentQuestionToolMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssessmentContentQuestionToolMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssessmentContentQuestionToolMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssessmentContentQuestionToolMutation, { data, loading, error }] = useUpdateManyAssessmentContentQuestionToolMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssessmentContentQuestionToolMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssessmentContentQuestionToolMutation,
    UpdateManyAssessmentContentQuestionToolMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssessmentContentQuestionToolMutation,
    UpdateManyAssessmentContentQuestionToolMutationVariables
  >(UpdateManyAssessmentContentQuestionToolDocument, baseOptions);
}
export type UpdateManyAssessmentContentQuestionToolMutationHookResult = ReturnType<
  typeof useUpdateManyAssessmentContentQuestionToolMutation
>;
export type UpdateManyAssessmentContentQuestionToolMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssessmentContentQuestionToolMutation
>;
export type UpdateManyAssessmentContentQuestionToolMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssessmentContentQuestionToolMutation,
  UpdateManyAssessmentContentQuestionToolMutationVariables
>;
export const FindOneAssessmentContentQuestionTypeDocument = gql`
  query findOneAssessmentContentQuestionType($where: AssessmentContentQuestionTypeWhereUniqueInput!) {
    findOneAssessmentContentQuestionType(where: $where) {
      ...AssessmentContentQuestionTypeFragment
    }
  }
  ${AssessmentContentQuestionTypeFragmentFragmentDoc}
`;

/**
 * __useFindOneAssessmentContentQuestionTypeQuery__
 *
 * To run a query within a React component, call `useFindOneAssessmentContentQuestionTypeQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssessmentContentQuestionTypeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssessmentContentQuestionTypeQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssessmentContentQuestionTypeQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssessmentContentQuestionTypeQuery,
    FindOneAssessmentContentQuestionTypeQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindOneAssessmentContentQuestionTypeQuery,
    FindOneAssessmentContentQuestionTypeQueryVariables
  >(FindOneAssessmentContentQuestionTypeDocument, baseOptions);
}
export function useFindOneAssessmentContentQuestionTypeLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssessmentContentQuestionTypeQuery,
    FindOneAssessmentContentQuestionTypeQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneAssessmentContentQuestionTypeQuery,
    FindOneAssessmentContentQuestionTypeQueryVariables
  >(FindOneAssessmentContentQuestionTypeDocument, baseOptions);
}
export type FindOneAssessmentContentQuestionTypeQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionTypeQuery
>;
export type FindOneAssessmentContentQuestionTypeLazyQueryHookResult = ReturnType<
  typeof useFindOneAssessmentContentQuestionTypeLazyQuery
>;
export type FindOneAssessmentContentQuestionTypeQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssessmentContentQuestionTypeQuery,
  FindOneAssessmentContentQuestionTypeQueryVariables
>;
export const FindManyAssessmentContentQuestionTypeDocument = gql`
  query findManyAssessmentContentQuestionType(
    $where: AssessmentContentQuestionTypeWhereInput
    $orderBy: AssessmentContentQuestionTypeOrderByInput
    $after: AssessmentContentQuestionTypeWhereUniqueInput
    $before: AssessmentContentQuestionTypeWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionType(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssessmentContentQuestionTypeFragment
    }
  }
  ${AssessmentContentQuestionTypeFragmentFragmentDoc}
`;

/**
 * __useFindManyAssessmentContentQuestionTypeQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionTypeQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionTypeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionTypeQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionTypeQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionTypeQuery,
    FindManyAssessmentContentQuestionTypeQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionTypeQuery,
    FindManyAssessmentContentQuestionTypeQueryVariables
  >(FindManyAssessmentContentQuestionTypeDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionTypeLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionTypeQuery,
    FindManyAssessmentContentQuestionTypeQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionTypeQuery,
    FindManyAssessmentContentQuestionTypeQueryVariables
  >(FindManyAssessmentContentQuestionTypeDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionTypeQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionTypeQuery
>;
export type FindManyAssessmentContentQuestionTypeLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionTypeLazyQuery
>;
export type FindManyAssessmentContentQuestionTypeQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionTypeQuery,
  FindManyAssessmentContentQuestionTypeQueryVariables
>;
export const FindManyAssessmentContentQuestionTypeCountDocument = gql`
  query findManyAssessmentContentQuestionTypeCount(
    $where: AssessmentContentQuestionTypeWhereInput
    $orderBy: AssessmentContentQuestionTypeOrderByInput
    $after: AssessmentContentQuestionTypeWhereUniqueInput
    $before: AssessmentContentQuestionTypeWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentContentQuestionTypeCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssessmentContentQuestionTypeCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentContentQuestionTypeCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentContentQuestionTypeCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentContentQuestionTypeCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentContentQuestionTypeCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentContentQuestionTypeCountQuery,
    FindManyAssessmentContentQuestionTypeCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentContentQuestionTypeCountQuery,
    FindManyAssessmentContentQuestionTypeCountQueryVariables
  >(FindManyAssessmentContentQuestionTypeCountDocument, baseOptions);
}
export function useFindManyAssessmentContentQuestionTypeCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentContentQuestionTypeCountQuery,
    FindManyAssessmentContentQuestionTypeCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentContentQuestionTypeCountQuery,
    FindManyAssessmentContentQuestionTypeCountQueryVariables
  >(FindManyAssessmentContentQuestionTypeCountDocument, baseOptions);
}
export type FindManyAssessmentContentQuestionTypeCountQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionTypeCountQuery
>;
export type FindManyAssessmentContentQuestionTypeCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentContentQuestionTypeCountLazyQuery
>;
export type FindManyAssessmentContentQuestionTypeCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentContentQuestionTypeCountQuery,
  FindManyAssessmentContentQuestionTypeCountQueryVariables
>;
export const CreateOneAssessmentContentQuestionTypeDocument = gql`
  mutation createOneAssessmentContentQuestionType($data: AssessmentContentQuestionTypeCreateInput!) {
    createOneAssessmentContentQuestionType(data: $data) {
      ...AssessmentContentQuestionTypeFragment
    }
  }
  ${AssessmentContentQuestionTypeFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssessmentContentQuestionTypeMutation__
 *
 * To run a mutation, you first call `useCreateOneAssessmentContentQuestionTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssessmentContentQuestionTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssessmentContentQuestionTypeMutation, { data, loading, error }] = useCreateOneAssessmentContentQuestionTypeMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssessmentContentQuestionTypeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssessmentContentQuestionTypeMutation,
    CreateOneAssessmentContentQuestionTypeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssessmentContentQuestionTypeMutation,
    CreateOneAssessmentContentQuestionTypeMutationVariables
  >(CreateOneAssessmentContentQuestionTypeDocument, baseOptions);
}
export type CreateOneAssessmentContentQuestionTypeMutationHookResult = ReturnType<
  typeof useCreateOneAssessmentContentQuestionTypeMutation
>;
export type CreateOneAssessmentContentQuestionTypeMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssessmentContentQuestionTypeMutation
>;
export type CreateOneAssessmentContentQuestionTypeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssessmentContentQuestionTypeMutation,
  CreateOneAssessmentContentQuestionTypeMutationVariables
>;
export const UpdateOneAssessmentContentQuestionTypeDocument = gql`
  mutation updateOneAssessmentContentQuestionType(
    $where: AssessmentContentQuestionTypeWhereUniqueInput!
    $data: AssessmentContentQuestionTypeUpdateInput!
  ) {
    updateOneAssessmentContentQuestionType(where: $where, data: $data) {
      ...AssessmentContentQuestionTypeFragment
    }
  }
  ${AssessmentContentQuestionTypeFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssessmentContentQuestionTypeMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssessmentContentQuestionTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssessmentContentQuestionTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssessmentContentQuestionTypeMutation, { data, loading, error }] = useUpdateOneAssessmentContentQuestionTypeMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssessmentContentQuestionTypeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssessmentContentQuestionTypeMutation,
    UpdateOneAssessmentContentQuestionTypeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssessmentContentQuestionTypeMutation,
    UpdateOneAssessmentContentQuestionTypeMutationVariables
  >(UpdateOneAssessmentContentQuestionTypeDocument, baseOptions);
}
export type UpdateOneAssessmentContentQuestionTypeMutationHookResult = ReturnType<
  typeof useUpdateOneAssessmentContentQuestionTypeMutation
>;
export type UpdateOneAssessmentContentQuestionTypeMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssessmentContentQuestionTypeMutation
>;
export type UpdateOneAssessmentContentQuestionTypeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssessmentContentQuestionTypeMutation,
  UpdateOneAssessmentContentQuestionTypeMutationVariables
>;
export const DeleteOneAssessmentContentQuestionTypeDocument = gql`
  mutation deleteOneAssessmentContentQuestionType($where: AssessmentContentQuestionTypeWhereUniqueInput!) {
    deleteOneAssessmentContentQuestionType(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssessmentContentQuestionTypeMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssessmentContentQuestionTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssessmentContentQuestionTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssessmentContentQuestionTypeMutation, { data, loading, error }] = useDeleteOneAssessmentContentQuestionTypeMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssessmentContentQuestionTypeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssessmentContentQuestionTypeMutation,
    DeleteOneAssessmentContentQuestionTypeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssessmentContentQuestionTypeMutation,
    DeleteOneAssessmentContentQuestionTypeMutationVariables
  >(DeleteOneAssessmentContentQuestionTypeDocument, baseOptions);
}
export type DeleteOneAssessmentContentQuestionTypeMutationHookResult = ReturnType<
  typeof useDeleteOneAssessmentContentQuestionTypeMutation
>;
export type DeleteOneAssessmentContentQuestionTypeMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssessmentContentQuestionTypeMutation
>;
export type DeleteOneAssessmentContentQuestionTypeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssessmentContentQuestionTypeMutation,
  DeleteOneAssessmentContentQuestionTypeMutationVariables
>;
export const DeleteManyAssessmentContentQuestionTypeDocument = gql`
  mutation deleteManyAssessmentContentQuestionType($where: AssessmentContentQuestionTypeWhereInput) {
    deleteManyAssessmentContentQuestionType(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssessmentContentQuestionTypeMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssessmentContentQuestionTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssessmentContentQuestionTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssessmentContentQuestionTypeMutation, { data, loading, error }] = useDeleteManyAssessmentContentQuestionTypeMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssessmentContentQuestionTypeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssessmentContentQuestionTypeMutation,
    DeleteManyAssessmentContentQuestionTypeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssessmentContentQuestionTypeMutation,
    DeleteManyAssessmentContentQuestionTypeMutationVariables
  >(DeleteManyAssessmentContentQuestionTypeDocument, baseOptions);
}
export type DeleteManyAssessmentContentQuestionTypeMutationHookResult = ReturnType<
  typeof useDeleteManyAssessmentContentQuestionTypeMutation
>;
export type DeleteManyAssessmentContentQuestionTypeMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssessmentContentQuestionTypeMutation
>;
export type DeleteManyAssessmentContentQuestionTypeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssessmentContentQuestionTypeMutation,
  DeleteManyAssessmentContentQuestionTypeMutationVariables
>;
export const UpdateManyAssessmentContentQuestionTypeDocument = gql`
  mutation updateManyAssessmentContentQuestionType(
    $where: AssessmentContentQuestionTypeWhereInput
    $data: AssessmentContentQuestionTypeUpdateManyMutationInput!
  ) {
    updateManyAssessmentContentQuestionType(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssessmentContentQuestionTypeMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssessmentContentQuestionTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssessmentContentQuestionTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssessmentContentQuestionTypeMutation, { data, loading, error }] = useUpdateManyAssessmentContentQuestionTypeMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssessmentContentQuestionTypeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssessmentContentQuestionTypeMutation,
    UpdateManyAssessmentContentQuestionTypeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssessmentContentQuestionTypeMutation,
    UpdateManyAssessmentContentQuestionTypeMutationVariables
  >(UpdateManyAssessmentContentQuestionTypeDocument, baseOptions);
}
export type UpdateManyAssessmentContentQuestionTypeMutationHookResult = ReturnType<
  typeof useUpdateManyAssessmentContentQuestionTypeMutation
>;
export type UpdateManyAssessmentContentQuestionTypeMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssessmentContentQuestionTypeMutation
>;
export type UpdateManyAssessmentContentQuestionTypeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssessmentContentQuestionTypeMutation,
  UpdateManyAssessmentContentQuestionTypeMutationVariables
>;
export const FindOneAssessmentTakingQuestionDocument = gql`
  query findOneAssessmentTakingQuestion($where: AssessmentTakingQuestionWhereUniqueInput!) {
    findOneAssessmentTakingQuestion(where: $where) {
      ...AssessmentTakingQuestionFragment
    }
  }
  ${AssessmentTakingQuestionFragmentFragmentDoc}
`;

/**
 * __useFindOneAssessmentTakingQuestionQuery__
 *
 * To run a query within a React component, call `useFindOneAssessmentTakingQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssessmentTakingQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssessmentTakingQuestionQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssessmentTakingQuestionQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssessmentTakingQuestionQuery,
    FindOneAssessmentTakingQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneAssessmentTakingQuestionQuery, FindOneAssessmentTakingQuestionQueryVariables>(
    FindOneAssessmentTakingQuestionDocument,
    baseOptions,
  );
}
export function useFindOneAssessmentTakingQuestionLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssessmentTakingQuestionQuery,
    FindOneAssessmentTakingQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneAssessmentTakingQuestionQuery,
    FindOneAssessmentTakingQuestionQueryVariables
  >(FindOneAssessmentTakingQuestionDocument, baseOptions);
}
export type FindOneAssessmentTakingQuestionQueryHookResult = ReturnType<typeof useFindOneAssessmentTakingQuestionQuery>;
export type FindOneAssessmentTakingQuestionLazyQueryHookResult = ReturnType<
  typeof useFindOneAssessmentTakingQuestionLazyQuery
>;
export type FindOneAssessmentTakingQuestionQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssessmentTakingQuestionQuery,
  FindOneAssessmentTakingQuestionQueryVariables
>;
export const FindManyAssessmentTakingQuestionDocument = gql`
  query findManyAssessmentTakingQuestion(
    $where: AssessmentTakingQuestionWhereInput
    $orderBy: AssessmentTakingQuestionOrderByInput
    $after: AssessmentTakingQuestionWhereUniqueInput
    $before: AssessmentTakingQuestionWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentTakingQuestion(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssessmentTakingQuestionFragment
    }
  }
  ${AssessmentTakingQuestionFragmentFragmentDoc}
`;

/**
 * __useFindManyAssessmentTakingQuestionQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentTakingQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentTakingQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentTakingQuestionQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentTakingQuestionQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentTakingQuestionQuery,
    FindManyAssessmentTakingQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentTakingQuestionQuery,
    FindManyAssessmentTakingQuestionQueryVariables
  >(FindManyAssessmentTakingQuestionDocument, baseOptions);
}
export function useFindManyAssessmentTakingQuestionLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentTakingQuestionQuery,
    FindManyAssessmentTakingQuestionQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentTakingQuestionQuery,
    FindManyAssessmentTakingQuestionQueryVariables
  >(FindManyAssessmentTakingQuestionDocument, baseOptions);
}
export type FindManyAssessmentTakingQuestionQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingQuestionQuery
>;
export type FindManyAssessmentTakingQuestionLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingQuestionLazyQuery
>;
export type FindManyAssessmentTakingQuestionQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentTakingQuestionQuery,
  FindManyAssessmentTakingQuestionQueryVariables
>;
export const FindManyAssessmentTakingQuestionCountDocument = gql`
  query findManyAssessmentTakingQuestionCount(
    $where: AssessmentTakingQuestionWhereInput
    $orderBy: AssessmentTakingQuestionOrderByInput
    $after: AssessmentTakingQuestionWhereUniqueInput
    $before: AssessmentTakingQuestionWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentTakingQuestionCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssessmentTakingQuestionCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentTakingQuestionCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentTakingQuestionCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentTakingQuestionCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentTakingQuestionCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentTakingQuestionCountQuery,
    FindManyAssessmentTakingQuestionCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentTakingQuestionCountQuery,
    FindManyAssessmentTakingQuestionCountQueryVariables
  >(FindManyAssessmentTakingQuestionCountDocument, baseOptions);
}
export function useFindManyAssessmentTakingQuestionCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentTakingQuestionCountQuery,
    FindManyAssessmentTakingQuestionCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentTakingQuestionCountQuery,
    FindManyAssessmentTakingQuestionCountQueryVariables
  >(FindManyAssessmentTakingQuestionCountDocument, baseOptions);
}
export type FindManyAssessmentTakingQuestionCountQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingQuestionCountQuery
>;
export type FindManyAssessmentTakingQuestionCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingQuestionCountLazyQuery
>;
export type FindManyAssessmentTakingQuestionCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentTakingQuestionCountQuery,
  FindManyAssessmentTakingQuestionCountQueryVariables
>;
export const CreateOneAssessmentTakingQuestionDocument = gql`
  mutation createOneAssessmentTakingQuestion($data: AssessmentTakingQuestionCreateInput!) {
    createOneAssessmentTakingQuestion(data: $data) {
      ...AssessmentTakingQuestionFragment
    }
  }
  ${AssessmentTakingQuestionFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssessmentTakingQuestionMutation__
 *
 * To run a mutation, you first call `useCreateOneAssessmentTakingQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssessmentTakingQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssessmentTakingQuestionMutation, { data, loading, error }] = useCreateOneAssessmentTakingQuestionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssessmentTakingQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssessmentTakingQuestionMutation,
    CreateOneAssessmentTakingQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssessmentTakingQuestionMutation,
    CreateOneAssessmentTakingQuestionMutationVariables
  >(CreateOneAssessmentTakingQuestionDocument, baseOptions);
}
export type CreateOneAssessmentTakingQuestionMutationHookResult = ReturnType<
  typeof useCreateOneAssessmentTakingQuestionMutation
>;
export type CreateOneAssessmentTakingQuestionMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssessmentTakingQuestionMutation
>;
export type CreateOneAssessmentTakingQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssessmentTakingQuestionMutation,
  CreateOneAssessmentTakingQuestionMutationVariables
>;
export const UpdateOneAssessmentTakingQuestionDocument = gql`
  mutation updateOneAssessmentTakingQuestion(
    $where: AssessmentTakingQuestionWhereUniqueInput!
    $data: AssessmentTakingQuestionUpdateInput!
  ) {
    updateOneAssessmentTakingQuestion(where: $where, data: $data) {
      ...AssessmentTakingQuestionFragment
    }
  }
  ${AssessmentTakingQuestionFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssessmentTakingQuestionMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssessmentTakingQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssessmentTakingQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssessmentTakingQuestionMutation, { data, loading, error }] = useUpdateOneAssessmentTakingQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssessmentTakingQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssessmentTakingQuestionMutation,
    UpdateOneAssessmentTakingQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssessmentTakingQuestionMutation,
    UpdateOneAssessmentTakingQuestionMutationVariables
  >(UpdateOneAssessmentTakingQuestionDocument, baseOptions);
}
export type UpdateOneAssessmentTakingQuestionMutationHookResult = ReturnType<
  typeof useUpdateOneAssessmentTakingQuestionMutation
>;
export type UpdateOneAssessmentTakingQuestionMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssessmentTakingQuestionMutation
>;
export type UpdateOneAssessmentTakingQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssessmentTakingQuestionMutation,
  UpdateOneAssessmentTakingQuestionMutationVariables
>;
export const DeleteOneAssessmentTakingQuestionDocument = gql`
  mutation deleteOneAssessmentTakingQuestion($where: AssessmentTakingQuestionWhereUniqueInput!) {
    deleteOneAssessmentTakingQuestion(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssessmentTakingQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssessmentTakingQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssessmentTakingQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssessmentTakingQuestionMutation, { data, loading, error }] = useDeleteOneAssessmentTakingQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssessmentTakingQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssessmentTakingQuestionMutation,
    DeleteOneAssessmentTakingQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssessmentTakingQuestionMutation,
    DeleteOneAssessmentTakingQuestionMutationVariables
  >(DeleteOneAssessmentTakingQuestionDocument, baseOptions);
}
export type DeleteOneAssessmentTakingQuestionMutationHookResult = ReturnType<
  typeof useDeleteOneAssessmentTakingQuestionMutation
>;
export type DeleteOneAssessmentTakingQuestionMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssessmentTakingQuestionMutation
>;
export type DeleteOneAssessmentTakingQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssessmentTakingQuestionMutation,
  DeleteOneAssessmentTakingQuestionMutationVariables
>;
export const DeleteManyAssessmentTakingQuestionDocument = gql`
  mutation deleteManyAssessmentTakingQuestion($where: AssessmentTakingQuestionWhereInput) {
    deleteManyAssessmentTakingQuestion(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssessmentTakingQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssessmentTakingQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssessmentTakingQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssessmentTakingQuestionMutation, { data, loading, error }] = useDeleteManyAssessmentTakingQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssessmentTakingQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssessmentTakingQuestionMutation,
    DeleteManyAssessmentTakingQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssessmentTakingQuestionMutation,
    DeleteManyAssessmentTakingQuestionMutationVariables
  >(DeleteManyAssessmentTakingQuestionDocument, baseOptions);
}
export type DeleteManyAssessmentTakingQuestionMutationHookResult = ReturnType<
  typeof useDeleteManyAssessmentTakingQuestionMutation
>;
export type DeleteManyAssessmentTakingQuestionMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssessmentTakingQuestionMutation
>;
export type DeleteManyAssessmentTakingQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssessmentTakingQuestionMutation,
  DeleteManyAssessmentTakingQuestionMutationVariables
>;
export const UpdateManyAssessmentTakingQuestionDocument = gql`
  mutation updateManyAssessmentTakingQuestion(
    $where: AssessmentTakingQuestionWhereInput
    $data: AssessmentTakingQuestionUpdateManyMutationInput!
  ) {
    updateManyAssessmentTakingQuestion(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssessmentTakingQuestionMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssessmentTakingQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssessmentTakingQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssessmentTakingQuestionMutation, { data, loading, error }] = useUpdateManyAssessmentTakingQuestionMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssessmentTakingQuestionMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssessmentTakingQuestionMutation,
    UpdateManyAssessmentTakingQuestionMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssessmentTakingQuestionMutation,
    UpdateManyAssessmentTakingQuestionMutationVariables
  >(UpdateManyAssessmentTakingQuestionDocument, baseOptions);
}
export type UpdateManyAssessmentTakingQuestionMutationHookResult = ReturnType<
  typeof useUpdateManyAssessmentTakingQuestionMutation
>;
export type UpdateManyAssessmentTakingQuestionMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssessmentTakingQuestionMutation
>;
export type UpdateManyAssessmentTakingQuestionMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssessmentTakingQuestionMutation,
  UpdateManyAssessmentTakingQuestionMutationVariables
>;
export const FindOneAssessmentTakingResponseDocument = gql`
  query findOneAssessmentTakingResponse($where: AssessmentTakingResponseWhereUniqueInput!) {
    findOneAssessmentTakingResponse(where: $where) {
      ...AssessmentTakingResponseFragment
    }
  }
  ${AssessmentTakingResponseFragmentFragmentDoc}
`;

/**
 * __useFindOneAssessmentTakingResponseQuery__
 *
 * To run a query within a React component, call `useFindOneAssessmentTakingResponseQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssessmentTakingResponseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssessmentTakingResponseQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssessmentTakingResponseQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssessmentTakingResponseQuery,
    FindOneAssessmentTakingResponseQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneAssessmentTakingResponseQuery, FindOneAssessmentTakingResponseQueryVariables>(
    FindOneAssessmentTakingResponseDocument,
    baseOptions,
  );
}
export function useFindOneAssessmentTakingResponseLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssessmentTakingResponseQuery,
    FindOneAssessmentTakingResponseQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneAssessmentTakingResponseQuery,
    FindOneAssessmentTakingResponseQueryVariables
  >(FindOneAssessmentTakingResponseDocument, baseOptions);
}
export type FindOneAssessmentTakingResponseQueryHookResult = ReturnType<typeof useFindOneAssessmentTakingResponseQuery>;
export type FindOneAssessmentTakingResponseLazyQueryHookResult = ReturnType<
  typeof useFindOneAssessmentTakingResponseLazyQuery
>;
export type FindOneAssessmentTakingResponseQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssessmentTakingResponseQuery,
  FindOneAssessmentTakingResponseQueryVariables
>;
export const FindManyAssessmentTakingResponseDocument = gql`
  query findManyAssessmentTakingResponse(
    $where: AssessmentTakingResponseWhereInput
    $orderBy: AssessmentTakingResponseOrderByInput
    $after: AssessmentTakingResponseWhereUniqueInput
    $before: AssessmentTakingResponseWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentTakingResponse(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssessmentTakingResponseFragment
    }
  }
  ${AssessmentTakingResponseFragmentFragmentDoc}
`;

/**
 * __useFindManyAssessmentTakingResponseQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentTakingResponseQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentTakingResponseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentTakingResponseQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentTakingResponseQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentTakingResponseQuery,
    FindManyAssessmentTakingResponseQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentTakingResponseQuery,
    FindManyAssessmentTakingResponseQueryVariables
  >(FindManyAssessmentTakingResponseDocument, baseOptions);
}
export function useFindManyAssessmentTakingResponseLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentTakingResponseQuery,
    FindManyAssessmentTakingResponseQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentTakingResponseQuery,
    FindManyAssessmentTakingResponseQueryVariables
  >(FindManyAssessmentTakingResponseDocument, baseOptions);
}
export type FindManyAssessmentTakingResponseQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingResponseQuery
>;
export type FindManyAssessmentTakingResponseLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingResponseLazyQuery
>;
export type FindManyAssessmentTakingResponseQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentTakingResponseQuery,
  FindManyAssessmentTakingResponseQueryVariables
>;
export const FindManyAssessmentTakingResponseCountDocument = gql`
  query findManyAssessmentTakingResponseCount(
    $where: AssessmentTakingResponseWhereInput
    $orderBy: AssessmentTakingResponseOrderByInput
    $after: AssessmentTakingResponseWhereUniqueInput
    $before: AssessmentTakingResponseWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssessmentTakingResponseCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssessmentTakingResponseCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssessmentTakingResponseCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssessmentTakingResponseCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssessmentTakingResponseCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssessmentTakingResponseCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssessmentTakingResponseCountQuery,
    FindManyAssessmentTakingResponseCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssessmentTakingResponseCountQuery,
    FindManyAssessmentTakingResponseCountQueryVariables
  >(FindManyAssessmentTakingResponseCountDocument, baseOptions);
}
export function useFindManyAssessmentTakingResponseCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssessmentTakingResponseCountQuery,
    FindManyAssessmentTakingResponseCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssessmentTakingResponseCountQuery,
    FindManyAssessmentTakingResponseCountQueryVariables
  >(FindManyAssessmentTakingResponseCountDocument, baseOptions);
}
export type FindManyAssessmentTakingResponseCountQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingResponseCountQuery
>;
export type FindManyAssessmentTakingResponseCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssessmentTakingResponseCountLazyQuery
>;
export type FindManyAssessmentTakingResponseCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssessmentTakingResponseCountQuery,
  FindManyAssessmentTakingResponseCountQueryVariables
>;
export const CreateOneAssessmentTakingResponseDocument = gql`
  mutation createOneAssessmentTakingResponse($data: AssessmentTakingResponseCreateInput!) {
    createOneAssessmentTakingResponse(data: $data) {
      ...AssessmentTakingResponseFragment
    }
  }
  ${AssessmentTakingResponseFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssessmentTakingResponseMutation__
 *
 * To run a mutation, you first call `useCreateOneAssessmentTakingResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssessmentTakingResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssessmentTakingResponseMutation, { data, loading, error }] = useCreateOneAssessmentTakingResponseMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssessmentTakingResponseMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssessmentTakingResponseMutation,
    CreateOneAssessmentTakingResponseMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssessmentTakingResponseMutation,
    CreateOneAssessmentTakingResponseMutationVariables
  >(CreateOneAssessmentTakingResponseDocument, baseOptions);
}
export type CreateOneAssessmentTakingResponseMutationHookResult = ReturnType<
  typeof useCreateOneAssessmentTakingResponseMutation
>;
export type CreateOneAssessmentTakingResponseMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssessmentTakingResponseMutation
>;
export type CreateOneAssessmentTakingResponseMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssessmentTakingResponseMutation,
  CreateOneAssessmentTakingResponseMutationVariables
>;
export const UpdateOneAssessmentTakingResponseDocument = gql`
  mutation updateOneAssessmentTakingResponse(
    $where: AssessmentTakingResponseWhereUniqueInput!
    $data: AssessmentTakingResponseUpdateInput!
  ) {
    updateOneAssessmentTakingResponse(where: $where, data: $data) {
      ...AssessmentTakingResponseFragment
    }
  }
  ${AssessmentTakingResponseFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssessmentTakingResponseMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssessmentTakingResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssessmentTakingResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssessmentTakingResponseMutation, { data, loading, error }] = useUpdateOneAssessmentTakingResponseMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssessmentTakingResponseMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssessmentTakingResponseMutation,
    UpdateOneAssessmentTakingResponseMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssessmentTakingResponseMutation,
    UpdateOneAssessmentTakingResponseMutationVariables
  >(UpdateOneAssessmentTakingResponseDocument, baseOptions);
}
export type UpdateOneAssessmentTakingResponseMutationHookResult = ReturnType<
  typeof useUpdateOneAssessmentTakingResponseMutation
>;
export type UpdateOneAssessmentTakingResponseMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssessmentTakingResponseMutation
>;
export type UpdateOneAssessmentTakingResponseMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssessmentTakingResponseMutation,
  UpdateOneAssessmentTakingResponseMutationVariables
>;
export const DeleteOneAssessmentTakingResponseDocument = gql`
  mutation deleteOneAssessmentTakingResponse($where: AssessmentTakingResponseWhereUniqueInput!) {
    deleteOneAssessmentTakingResponse(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssessmentTakingResponseMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssessmentTakingResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssessmentTakingResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssessmentTakingResponseMutation, { data, loading, error }] = useDeleteOneAssessmentTakingResponseMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssessmentTakingResponseMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssessmentTakingResponseMutation,
    DeleteOneAssessmentTakingResponseMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssessmentTakingResponseMutation,
    DeleteOneAssessmentTakingResponseMutationVariables
  >(DeleteOneAssessmentTakingResponseDocument, baseOptions);
}
export type DeleteOneAssessmentTakingResponseMutationHookResult = ReturnType<
  typeof useDeleteOneAssessmentTakingResponseMutation
>;
export type DeleteOneAssessmentTakingResponseMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssessmentTakingResponseMutation
>;
export type DeleteOneAssessmentTakingResponseMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssessmentTakingResponseMutation,
  DeleteOneAssessmentTakingResponseMutationVariables
>;
export const DeleteManyAssessmentTakingResponseDocument = gql`
  mutation deleteManyAssessmentTakingResponse($where: AssessmentTakingResponseWhereInput) {
    deleteManyAssessmentTakingResponse(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssessmentTakingResponseMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssessmentTakingResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssessmentTakingResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssessmentTakingResponseMutation, { data, loading, error }] = useDeleteManyAssessmentTakingResponseMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssessmentTakingResponseMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssessmentTakingResponseMutation,
    DeleteManyAssessmentTakingResponseMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssessmentTakingResponseMutation,
    DeleteManyAssessmentTakingResponseMutationVariables
  >(DeleteManyAssessmentTakingResponseDocument, baseOptions);
}
export type DeleteManyAssessmentTakingResponseMutationHookResult = ReturnType<
  typeof useDeleteManyAssessmentTakingResponseMutation
>;
export type DeleteManyAssessmentTakingResponseMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssessmentTakingResponseMutation
>;
export type DeleteManyAssessmentTakingResponseMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssessmentTakingResponseMutation,
  DeleteManyAssessmentTakingResponseMutationVariables
>;
export const UpdateManyAssessmentTakingResponseDocument = gql`
  mutation updateManyAssessmentTakingResponse(
    $where: AssessmentTakingResponseWhereInput
    $data: AssessmentTakingResponseUpdateManyMutationInput!
  ) {
    updateManyAssessmentTakingResponse(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssessmentTakingResponseMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssessmentTakingResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssessmentTakingResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssessmentTakingResponseMutation, { data, loading, error }] = useUpdateManyAssessmentTakingResponseMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssessmentTakingResponseMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssessmentTakingResponseMutation,
    UpdateManyAssessmentTakingResponseMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssessmentTakingResponseMutation,
    UpdateManyAssessmentTakingResponseMutationVariables
  >(UpdateManyAssessmentTakingResponseDocument, baseOptions);
}
export type UpdateManyAssessmentTakingResponseMutationHookResult = ReturnType<
  typeof useUpdateManyAssessmentTakingResponseMutation
>;
export type UpdateManyAssessmentTakingResponseMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssessmentTakingResponseMutation
>;
export type UpdateManyAssessmentTakingResponseMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssessmentTakingResponseMutation,
  UpdateManyAssessmentTakingResponseMutationVariables
>;
export const FindOneAssignmentContentDocument = gql`
  query findOneAssignmentContent($where: AssignmentContentWhereUniqueInput!) {
    findOneAssignmentContent(where: $where) {
      ...AssignmentContentFragment
    }
  }
  ${AssignmentContentFragmentFragmentDoc}
`;

/**
 * __useFindOneAssignmentContentQuery__
 *
 * To run a query within a React component, call `useFindOneAssignmentContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssignmentContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssignmentContentQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssignmentContentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssignmentContentQuery,
    FindOneAssignmentContentQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneAssignmentContentQuery, FindOneAssignmentContentQueryVariables>(
    FindOneAssignmentContentDocument,
    baseOptions,
  );
}
export function useFindOneAssignmentContentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssignmentContentQuery,
    FindOneAssignmentContentQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneAssignmentContentQuery, FindOneAssignmentContentQueryVariables>(
    FindOneAssignmentContentDocument,
    baseOptions,
  );
}
export type FindOneAssignmentContentQueryHookResult = ReturnType<typeof useFindOneAssignmentContentQuery>;
export type FindOneAssignmentContentLazyQueryHookResult = ReturnType<typeof useFindOneAssignmentContentLazyQuery>;
export type FindOneAssignmentContentQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssignmentContentQuery,
  FindOneAssignmentContentQueryVariables
>;
export const FindManyAssignmentContentDocument = gql`
  query findManyAssignmentContent(
    $where: AssignmentContentWhereInput
    $orderBy: AssignmentContentOrderByInput
    $after: AssignmentContentWhereUniqueInput
    $before: AssignmentContentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssignmentContent(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssignmentContentFragment
    }
  }
  ${AssignmentContentFragmentFragmentDoc}
`;

/**
 * __useFindManyAssignmentContentQuery__
 *
 * To run a query within a React component, call `useFindManyAssignmentContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssignmentContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssignmentContentQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssignmentContentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssignmentContentQuery,
    FindManyAssignmentContentQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyAssignmentContentQuery, FindManyAssignmentContentQueryVariables>(
    FindManyAssignmentContentDocument,
    baseOptions,
  );
}
export function useFindManyAssignmentContentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssignmentContentQuery,
    FindManyAssignmentContentQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyAssignmentContentQuery, FindManyAssignmentContentQueryVariables>(
    FindManyAssignmentContentDocument,
    baseOptions,
  );
}
export type FindManyAssignmentContentQueryHookResult = ReturnType<typeof useFindManyAssignmentContentQuery>;
export type FindManyAssignmentContentLazyQueryHookResult = ReturnType<typeof useFindManyAssignmentContentLazyQuery>;
export type FindManyAssignmentContentQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssignmentContentQuery,
  FindManyAssignmentContentQueryVariables
>;
export const FindManyAssignmentContentCountDocument = gql`
  query findManyAssignmentContentCount(
    $where: AssignmentContentWhereInput
    $orderBy: AssignmentContentOrderByInput
    $after: AssignmentContentWhereUniqueInput
    $before: AssignmentContentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssignmentContentCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssignmentContentCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssignmentContentCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssignmentContentCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssignmentContentCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssignmentContentCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssignmentContentCountQuery,
    FindManyAssignmentContentCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyAssignmentContentCountQuery, FindManyAssignmentContentCountQueryVariables>(
    FindManyAssignmentContentCountDocument,
    baseOptions,
  );
}
export function useFindManyAssignmentContentCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssignmentContentCountQuery,
    FindManyAssignmentContentCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssignmentContentCountQuery,
    FindManyAssignmentContentCountQueryVariables
  >(FindManyAssignmentContentCountDocument, baseOptions);
}
export type FindManyAssignmentContentCountQueryHookResult = ReturnType<typeof useFindManyAssignmentContentCountQuery>;
export type FindManyAssignmentContentCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssignmentContentCountLazyQuery
>;
export type FindManyAssignmentContentCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssignmentContentCountQuery,
  FindManyAssignmentContentCountQueryVariables
>;
export const CreateOneAssignmentContentDocument = gql`
  mutation createOneAssignmentContent($data: AssignmentContentCreateInput!) {
    createOneAssignmentContent(data: $data) {
      ...AssignmentContentFragment
    }
  }
  ${AssignmentContentFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssignmentContentMutation__
 *
 * To run a mutation, you first call `useCreateOneAssignmentContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssignmentContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssignmentContentMutation, { data, loading, error }] = useCreateOneAssignmentContentMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssignmentContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssignmentContentMutation,
    CreateOneAssignmentContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneAssignmentContentMutation, CreateOneAssignmentContentMutationVariables>(
    CreateOneAssignmentContentDocument,
    baseOptions,
  );
}
export type CreateOneAssignmentContentMutationHookResult = ReturnType<typeof useCreateOneAssignmentContentMutation>;
export type CreateOneAssignmentContentMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssignmentContentMutation
>;
export type CreateOneAssignmentContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssignmentContentMutation,
  CreateOneAssignmentContentMutationVariables
>;
export const UpdateOneAssignmentContentDocument = gql`
  mutation updateOneAssignmentContent(
    $where: AssignmentContentWhereUniqueInput!
    $data: AssignmentContentUpdateInput!
  ) {
    updateOneAssignmentContent(where: $where, data: $data) {
      ...AssignmentContentFragment
    }
  }
  ${AssignmentContentFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssignmentContentMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssignmentContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssignmentContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssignmentContentMutation, { data, loading, error }] = useUpdateOneAssignmentContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssignmentContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssignmentContentMutation,
    UpdateOneAssignmentContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneAssignmentContentMutation, UpdateOneAssignmentContentMutationVariables>(
    UpdateOneAssignmentContentDocument,
    baseOptions,
  );
}
export type UpdateOneAssignmentContentMutationHookResult = ReturnType<typeof useUpdateOneAssignmentContentMutation>;
export type UpdateOneAssignmentContentMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssignmentContentMutation
>;
export type UpdateOneAssignmentContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssignmentContentMutation,
  UpdateOneAssignmentContentMutationVariables
>;
export const DeleteOneAssignmentContentDocument = gql`
  mutation deleteOneAssignmentContent($where: AssignmentContentWhereUniqueInput!) {
    deleteOneAssignmentContent(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssignmentContentMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssignmentContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssignmentContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssignmentContentMutation, { data, loading, error }] = useDeleteOneAssignmentContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssignmentContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssignmentContentMutation,
    DeleteOneAssignmentContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneAssignmentContentMutation, DeleteOneAssignmentContentMutationVariables>(
    DeleteOneAssignmentContentDocument,
    baseOptions,
  );
}
export type DeleteOneAssignmentContentMutationHookResult = ReturnType<typeof useDeleteOneAssignmentContentMutation>;
export type DeleteOneAssignmentContentMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssignmentContentMutation
>;
export type DeleteOneAssignmentContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssignmentContentMutation,
  DeleteOneAssignmentContentMutationVariables
>;
export const DeleteManyAssignmentContentDocument = gql`
  mutation deleteManyAssignmentContent($where: AssignmentContentWhereInput) {
    deleteManyAssignmentContent(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssignmentContentMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssignmentContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssignmentContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssignmentContentMutation, { data, loading, error }] = useDeleteManyAssignmentContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssignmentContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssignmentContentMutation,
    DeleteManyAssignmentContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssignmentContentMutation,
    DeleteManyAssignmentContentMutationVariables
  >(DeleteManyAssignmentContentDocument, baseOptions);
}
export type DeleteManyAssignmentContentMutationHookResult = ReturnType<typeof useDeleteManyAssignmentContentMutation>;
export type DeleteManyAssignmentContentMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssignmentContentMutation
>;
export type DeleteManyAssignmentContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssignmentContentMutation,
  DeleteManyAssignmentContentMutationVariables
>;
export const UpdateManyAssignmentContentDocument = gql`
  mutation updateManyAssignmentContent(
    $where: AssignmentContentWhereInput
    $data: AssignmentContentUpdateManyMutationInput!
  ) {
    updateManyAssignmentContent(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssignmentContentMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssignmentContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssignmentContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssignmentContentMutation, { data, loading, error }] = useUpdateManyAssignmentContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssignmentContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssignmentContentMutation,
    UpdateManyAssignmentContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssignmentContentMutation,
    UpdateManyAssignmentContentMutationVariables
  >(UpdateManyAssignmentContentDocument, baseOptions);
}
export type UpdateManyAssignmentContentMutationHookResult = ReturnType<typeof useUpdateManyAssignmentContentMutation>;
export type UpdateManyAssignmentContentMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssignmentContentMutation
>;
export type UpdateManyAssignmentContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssignmentContentMutation,
  UpdateManyAssignmentContentMutationVariables
>;
export const FindOneAssignmentTakingDocument = gql`
  query findOneAssignmentTaking($where: AssignmentTakingWhereUniqueInput!) {
    findOneAssignmentTaking(where: $where) {
      ...AssignmentTakingFragment
    }
  }
  ${AssignmentTakingFragmentFragmentDoc}
`;

/**
 * __useFindOneAssignmentTakingQuery__
 *
 * To run a query within a React component, call `useFindOneAssignmentTakingQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssignmentTakingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssignmentTakingQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssignmentTakingQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneAssignmentTakingQuery, FindOneAssignmentTakingQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneAssignmentTakingQuery, FindOneAssignmentTakingQueryVariables>(
    FindOneAssignmentTakingDocument,
    baseOptions,
  );
}
export function useFindOneAssignmentTakingLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssignmentTakingQuery,
    FindOneAssignmentTakingQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneAssignmentTakingQuery, FindOneAssignmentTakingQueryVariables>(
    FindOneAssignmentTakingDocument,
    baseOptions,
  );
}
export type FindOneAssignmentTakingQueryHookResult = ReturnType<typeof useFindOneAssignmentTakingQuery>;
export type FindOneAssignmentTakingLazyQueryHookResult = ReturnType<typeof useFindOneAssignmentTakingLazyQuery>;
export type FindOneAssignmentTakingQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssignmentTakingQuery,
  FindOneAssignmentTakingQueryVariables
>;
export const FindManyAssignmentTakingDocument = gql`
  query findManyAssignmentTaking(
    $where: AssignmentTakingWhereInput
    $orderBy: AssignmentTakingOrderByInput
    $after: AssignmentTakingWhereUniqueInput
    $before: AssignmentTakingWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssignmentTaking(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssignmentTakingFragment
    }
  }
  ${AssignmentTakingFragmentFragmentDoc}
`;

/**
 * __useFindManyAssignmentTakingQuery__
 *
 * To run a query within a React component, call `useFindManyAssignmentTakingQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssignmentTakingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssignmentTakingQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssignmentTakingQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssignmentTakingQuery,
    FindManyAssignmentTakingQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyAssignmentTakingQuery, FindManyAssignmentTakingQueryVariables>(
    FindManyAssignmentTakingDocument,
    baseOptions,
  );
}
export function useFindManyAssignmentTakingLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssignmentTakingQuery,
    FindManyAssignmentTakingQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyAssignmentTakingQuery, FindManyAssignmentTakingQueryVariables>(
    FindManyAssignmentTakingDocument,
    baseOptions,
  );
}
export type FindManyAssignmentTakingQueryHookResult = ReturnType<typeof useFindManyAssignmentTakingQuery>;
export type FindManyAssignmentTakingLazyQueryHookResult = ReturnType<typeof useFindManyAssignmentTakingLazyQuery>;
export type FindManyAssignmentTakingQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssignmentTakingQuery,
  FindManyAssignmentTakingQueryVariables
>;
export const FindManyAssignmentTakingCountDocument = gql`
  query findManyAssignmentTakingCount(
    $where: AssignmentTakingWhereInput
    $orderBy: AssignmentTakingOrderByInput
    $after: AssignmentTakingWhereUniqueInput
    $before: AssignmentTakingWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssignmentTakingCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssignmentTakingCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssignmentTakingCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssignmentTakingCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssignmentTakingCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssignmentTakingCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssignmentTakingCountQuery,
    FindManyAssignmentTakingCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyAssignmentTakingCountQuery, FindManyAssignmentTakingCountQueryVariables>(
    FindManyAssignmentTakingCountDocument,
    baseOptions,
  );
}
export function useFindManyAssignmentTakingCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssignmentTakingCountQuery,
    FindManyAssignmentTakingCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyAssignmentTakingCountQuery, FindManyAssignmentTakingCountQueryVariables>(
    FindManyAssignmentTakingCountDocument,
    baseOptions,
  );
}
export type FindManyAssignmentTakingCountQueryHookResult = ReturnType<typeof useFindManyAssignmentTakingCountQuery>;
export type FindManyAssignmentTakingCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssignmentTakingCountLazyQuery
>;
export type FindManyAssignmentTakingCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssignmentTakingCountQuery,
  FindManyAssignmentTakingCountQueryVariables
>;
export const CreateOneAssignmentTakingDocument = gql`
  mutation createOneAssignmentTaking($data: AssignmentTakingCreateInput!) {
    createOneAssignmentTaking(data: $data) {
      ...AssignmentTakingFragment
    }
  }
  ${AssignmentTakingFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssignmentTakingMutation__
 *
 * To run a mutation, you first call `useCreateOneAssignmentTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssignmentTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssignmentTakingMutation, { data, loading, error }] = useCreateOneAssignmentTakingMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssignmentTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssignmentTakingMutation,
    CreateOneAssignmentTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneAssignmentTakingMutation, CreateOneAssignmentTakingMutationVariables>(
    CreateOneAssignmentTakingDocument,
    baseOptions,
  );
}
export type CreateOneAssignmentTakingMutationHookResult = ReturnType<typeof useCreateOneAssignmentTakingMutation>;
export type CreateOneAssignmentTakingMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssignmentTakingMutation
>;
export type CreateOneAssignmentTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssignmentTakingMutation,
  CreateOneAssignmentTakingMutationVariables
>;
export const UpdateOneAssignmentTakingDocument = gql`
  mutation updateOneAssignmentTaking($where: AssignmentTakingWhereUniqueInput!, $data: AssignmentTakingUpdateInput!) {
    updateOneAssignmentTaking(where: $where, data: $data) {
      ...AssignmentTakingFragment
    }
  }
  ${AssignmentTakingFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssignmentTakingMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssignmentTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssignmentTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssignmentTakingMutation, { data, loading, error }] = useUpdateOneAssignmentTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssignmentTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssignmentTakingMutation,
    UpdateOneAssignmentTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneAssignmentTakingMutation, UpdateOneAssignmentTakingMutationVariables>(
    UpdateOneAssignmentTakingDocument,
    baseOptions,
  );
}
export type UpdateOneAssignmentTakingMutationHookResult = ReturnType<typeof useUpdateOneAssignmentTakingMutation>;
export type UpdateOneAssignmentTakingMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssignmentTakingMutation
>;
export type UpdateOneAssignmentTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssignmentTakingMutation,
  UpdateOneAssignmentTakingMutationVariables
>;
export const DeleteOneAssignmentTakingDocument = gql`
  mutation deleteOneAssignmentTaking($where: AssignmentTakingWhereUniqueInput!) {
    deleteOneAssignmentTaking(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssignmentTakingMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssignmentTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssignmentTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssignmentTakingMutation, { data, loading, error }] = useDeleteOneAssignmentTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssignmentTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssignmentTakingMutation,
    DeleteOneAssignmentTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneAssignmentTakingMutation, DeleteOneAssignmentTakingMutationVariables>(
    DeleteOneAssignmentTakingDocument,
    baseOptions,
  );
}
export type DeleteOneAssignmentTakingMutationHookResult = ReturnType<typeof useDeleteOneAssignmentTakingMutation>;
export type DeleteOneAssignmentTakingMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssignmentTakingMutation
>;
export type DeleteOneAssignmentTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssignmentTakingMutation,
  DeleteOneAssignmentTakingMutationVariables
>;
export const DeleteManyAssignmentTakingDocument = gql`
  mutation deleteManyAssignmentTaking($where: AssignmentTakingWhereInput) {
    deleteManyAssignmentTaking(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssignmentTakingMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssignmentTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssignmentTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssignmentTakingMutation, { data, loading, error }] = useDeleteManyAssignmentTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssignmentTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssignmentTakingMutation,
    DeleteManyAssignmentTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyAssignmentTakingMutation, DeleteManyAssignmentTakingMutationVariables>(
    DeleteManyAssignmentTakingDocument,
    baseOptions,
  );
}
export type DeleteManyAssignmentTakingMutationHookResult = ReturnType<typeof useDeleteManyAssignmentTakingMutation>;
export type DeleteManyAssignmentTakingMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssignmentTakingMutation
>;
export type DeleteManyAssignmentTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssignmentTakingMutation,
  DeleteManyAssignmentTakingMutationVariables
>;
export const UpdateManyAssignmentTakingDocument = gql`
  mutation updateManyAssignmentTaking(
    $where: AssignmentTakingWhereInput
    $data: AssignmentTakingUpdateManyMutationInput!
  ) {
    updateManyAssignmentTaking(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssignmentTakingMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssignmentTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssignmentTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssignmentTakingMutation, { data, loading, error }] = useUpdateManyAssignmentTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssignmentTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssignmentTakingMutation,
    UpdateManyAssignmentTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyAssignmentTakingMutation, UpdateManyAssignmentTakingMutationVariables>(
    UpdateManyAssignmentTakingDocument,
    baseOptions,
  );
}
export type UpdateManyAssignmentTakingMutationHookResult = ReturnType<typeof useUpdateManyAssignmentTakingMutation>;
export type UpdateManyAssignmentTakingMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssignmentTakingMutation
>;
export type UpdateManyAssignmentTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssignmentTakingMutation,
  UpdateManyAssignmentTakingMutationVariables
>;
export const FindOneAssignmentTakingWeightDocument = gql`
  query findOneAssignmentTakingWeight($where: AssignmentTakingWeightWhereUniqueInput!) {
    findOneAssignmentTakingWeight(where: $where) {
      ...AssignmentTakingWeightFragment
    }
  }
  ${AssignmentTakingWeightFragmentFragmentDoc}
`;

/**
 * __useFindOneAssignmentTakingWeightQuery__
 *
 * To run a query within a React component, call `useFindOneAssignmentTakingWeightQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneAssignmentTakingWeightQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneAssignmentTakingWeightQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneAssignmentTakingWeightQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneAssignmentTakingWeightQuery,
    FindOneAssignmentTakingWeightQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneAssignmentTakingWeightQuery, FindOneAssignmentTakingWeightQueryVariables>(
    FindOneAssignmentTakingWeightDocument,
    baseOptions,
  );
}
export function useFindOneAssignmentTakingWeightLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneAssignmentTakingWeightQuery,
    FindOneAssignmentTakingWeightQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneAssignmentTakingWeightQuery, FindOneAssignmentTakingWeightQueryVariables>(
    FindOneAssignmentTakingWeightDocument,
    baseOptions,
  );
}
export type FindOneAssignmentTakingWeightQueryHookResult = ReturnType<typeof useFindOneAssignmentTakingWeightQuery>;
export type FindOneAssignmentTakingWeightLazyQueryHookResult = ReturnType<
  typeof useFindOneAssignmentTakingWeightLazyQuery
>;
export type FindOneAssignmentTakingWeightQueryResult = ApolloReactCommon.QueryResult<
  FindOneAssignmentTakingWeightQuery,
  FindOneAssignmentTakingWeightQueryVariables
>;
export const FindManyAssignmentTakingWeightDocument = gql`
  query findManyAssignmentTakingWeight(
    $where: AssignmentTakingWeightWhereInput
    $orderBy: AssignmentTakingWeightOrderByInput
    $after: AssignmentTakingWeightWhereUniqueInput
    $before: AssignmentTakingWeightWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssignmentTakingWeight(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...AssignmentTakingWeightFragment
    }
  }
  ${AssignmentTakingWeightFragmentFragmentDoc}
`;

/**
 * __useFindManyAssignmentTakingWeightQuery__
 *
 * To run a query within a React component, call `useFindManyAssignmentTakingWeightQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssignmentTakingWeightQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssignmentTakingWeightQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssignmentTakingWeightQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssignmentTakingWeightQuery,
    FindManyAssignmentTakingWeightQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyAssignmentTakingWeightQuery, FindManyAssignmentTakingWeightQueryVariables>(
    FindManyAssignmentTakingWeightDocument,
    baseOptions,
  );
}
export function useFindManyAssignmentTakingWeightLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssignmentTakingWeightQuery,
    FindManyAssignmentTakingWeightQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssignmentTakingWeightQuery,
    FindManyAssignmentTakingWeightQueryVariables
  >(FindManyAssignmentTakingWeightDocument, baseOptions);
}
export type FindManyAssignmentTakingWeightQueryHookResult = ReturnType<typeof useFindManyAssignmentTakingWeightQuery>;
export type FindManyAssignmentTakingWeightLazyQueryHookResult = ReturnType<
  typeof useFindManyAssignmentTakingWeightLazyQuery
>;
export type FindManyAssignmentTakingWeightQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssignmentTakingWeightQuery,
  FindManyAssignmentTakingWeightQueryVariables
>;
export const FindManyAssignmentTakingWeightCountDocument = gql`
  query findManyAssignmentTakingWeightCount(
    $where: AssignmentTakingWeightWhereInput
    $orderBy: AssignmentTakingWeightOrderByInput
    $after: AssignmentTakingWeightWhereUniqueInput
    $before: AssignmentTakingWeightWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyAssignmentTakingWeightCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyAssignmentTakingWeightCountQuery__
 *
 * To run a query within a React component, call `useFindManyAssignmentTakingWeightCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyAssignmentTakingWeightCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyAssignmentTakingWeightCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyAssignmentTakingWeightCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyAssignmentTakingWeightCountQuery,
    FindManyAssignmentTakingWeightCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyAssignmentTakingWeightCountQuery,
    FindManyAssignmentTakingWeightCountQueryVariables
  >(FindManyAssignmentTakingWeightCountDocument, baseOptions);
}
export function useFindManyAssignmentTakingWeightCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyAssignmentTakingWeightCountQuery,
    FindManyAssignmentTakingWeightCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyAssignmentTakingWeightCountQuery,
    FindManyAssignmentTakingWeightCountQueryVariables
  >(FindManyAssignmentTakingWeightCountDocument, baseOptions);
}
export type FindManyAssignmentTakingWeightCountQueryHookResult = ReturnType<
  typeof useFindManyAssignmentTakingWeightCountQuery
>;
export type FindManyAssignmentTakingWeightCountLazyQueryHookResult = ReturnType<
  typeof useFindManyAssignmentTakingWeightCountLazyQuery
>;
export type FindManyAssignmentTakingWeightCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyAssignmentTakingWeightCountQuery,
  FindManyAssignmentTakingWeightCountQueryVariables
>;
export const CreateOneAssignmentTakingWeightDocument = gql`
  mutation createOneAssignmentTakingWeight($data: AssignmentTakingWeightCreateInput!) {
    createOneAssignmentTakingWeight(data: $data) {
      ...AssignmentTakingWeightFragment
    }
  }
  ${AssignmentTakingWeightFragmentFragmentDoc}
`;

/**
 * __useCreateOneAssignmentTakingWeightMutation__
 *
 * To run a mutation, you first call `useCreateOneAssignmentTakingWeightMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneAssignmentTakingWeightMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneAssignmentTakingWeightMutation, { data, loading, error }] = useCreateOneAssignmentTakingWeightMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneAssignmentTakingWeightMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneAssignmentTakingWeightMutation,
    CreateOneAssignmentTakingWeightMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneAssignmentTakingWeightMutation,
    CreateOneAssignmentTakingWeightMutationVariables
  >(CreateOneAssignmentTakingWeightDocument, baseOptions);
}
export type CreateOneAssignmentTakingWeightMutationHookResult = ReturnType<
  typeof useCreateOneAssignmentTakingWeightMutation
>;
export type CreateOneAssignmentTakingWeightMutationResult = ApolloReactCommon.MutationResult<
  CreateOneAssignmentTakingWeightMutation
>;
export type CreateOneAssignmentTakingWeightMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneAssignmentTakingWeightMutation,
  CreateOneAssignmentTakingWeightMutationVariables
>;
export const UpdateOneAssignmentTakingWeightDocument = gql`
  mutation updateOneAssignmentTakingWeight(
    $where: AssignmentTakingWeightWhereUniqueInput!
    $data: AssignmentTakingWeightUpdateInput!
  ) {
    updateOneAssignmentTakingWeight(where: $where, data: $data) {
      ...AssignmentTakingWeightFragment
    }
  }
  ${AssignmentTakingWeightFragmentFragmentDoc}
`;

/**
 * __useUpdateOneAssignmentTakingWeightMutation__
 *
 * To run a mutation, you first call `useUpdateOneAssignmentTakingWeightMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneAssignmentTakingWeightMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneAssignmentTakingWeightMutation, { data, loading, error }] = useUpdateOneAssignmentTakingWeightMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneAssignmentTakingWeightMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneAssignmentTakingWeightMutation,
    UpdateOneAssignmentTakingWeightMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneAssignmentTakingWeightMutation,
    UpdateOneAssignmentTakingWeightMutationVariables
  >(UpdateOneAssignmentTakingWeightDocument, baseOptions);
}
export type UpdateOneAssignmentTakingWeightMutationHookResult = ReturnType<
  typeof useUpdateOneAssignmentTakingWeightMutation
>;
export type UpdateOneAssignmentTakingWeightMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneAssignmentTakingWeightMutation
>;
export type UpdateOneAssignmentTakingWeightMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneAssignmentTakingWeightMutation,
  UpdateOneAssignmentTakingWeightMutationVariables
>;
export const DeleteOneAssignmentTakingWeightDocument = gql`
  mutation deleteOneAssignmentTakingWeight($where: AssignmentTakingWeightWhereUniqueInput!) {
    deleteOneAssignmentTakingWeight(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneAssignmentTakingWeightMutation__
 *
 * To run a mutation, you first call `useDeleteOneAssignmentTakingWeightMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneAssignmentTakingWeightMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneAssignmentTakingWeightMutation, { data, loading, error }] = useDeleteOneAssignmentTakingWeightMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneAssignmentTakingWeightMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneAssignmentTakingWeightMutation,
    DeleteOneAssignmentTakingWeightMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneAssignmentTakingWeightMutation,
    DeleteOneAssignmentTakingWeightMutationVariables
  >(DeleteOneAssignmentTakingWeightDocument, baseOptions);
}
export type DeleteOneAssignmentTakingWeightMutationHookResult = ReturnType<
  typeof useDeleteOneAssignmentTakingWeightMutation
>;
export type DeleteOneAssignmentTakingWeightMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneAssignmentTakingWeightMutation
>;
export type DeleteOneAssignmentTakingWeightMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneAssignmentTakingWeightMutation,
  DeleteOneAssignmentTakingWeightMutationVariables
>;
export const DeleteManyAssignmentTakingWeightDocument = gql`
  mutation deleteManyAssignmentTakingWeight($where: AssignmentTakingWeightWhereInput) {
    deleteManyAssignmentTakingWeight(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyAssignmentTakingWeightMutation__
 *
 * To run a mutation, you first call `useDeleteManyAssignmentTakingWeightMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyAssignmentTakingWeightMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyAssignmentTakingWeightMutation, { data, loading, error }] = useDeleteManyAssignmentTakingWeightMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyAssignmentTakingWeightMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyAssignmentTakingWeightMutation,
    DeleteManyAssignmentTakingWeightMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyAssignmentTakingWeightMutation,
    DeleteManyAssignmentTakingWeightMutationVariables
  >(DeleteManyAssignmentTakingWeightDocument, baseOptions);
}
export type DeleteManyAssignmentTakingWeightMutationHookResult = ReturnType<
  typeof useDeleteManyAssignmentTakingWeightMutation
>;
export type DeleteManyAssignmentTakingWeightMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyAssignmentTakingWeightMutation
>;
export type DeleteManyAssignmentTakingWeightMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyAssignmentTakingWeightMutation,
  DeleteManyAssignmentTakingWeightMutationVariables
>;
export const UpdateManyAssignmentTakingWeightDocument = gql`
  mutation updateManyAssignmentTakingWeight(
    $where: AssignmentTakingWeightWhereInput
    $data: AssignmentTakingWeightUpdateManyMutationInput!
  ) {
    updateManyAssignmentTakingWeight(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyAssignmentTakingWeightMutation__
 *
 * To run a mutation, you first call `useUpdateManyAssignmentTakingWeightMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyAssignmentTakingWeightMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyAssignmentTakingWeightMutation, { data, loading, error }] = useUpdateManyAssignmentTakingWeightMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyAssignmentTakingWeightMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyAssignmentTakingWeightMutation,
    UpdateManyAssignmentTakingWeightMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyAssignmentTakingWeightMutation,
    UpdateManyAssignmentTakingWeightMutationVariables
  >(UpdateManyAssignmentTakingWeightDocument, baseOptions);
}
export type UpdateManyAssignmentTakingWeightMutationHookResult = ReturnType<
  typeof useUpdateManyAssignmentTakingWeightMutation
>;
export type UpdateManyAssignmentTakingWeightMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyAssignmentTakingWeightMutation
>;
export type UpdateManyAssignmentTakingWeightMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyAssignmentTakingWeightMutation,
  UpdateManyAssignmentTakingWeightMutationVariables
>;
export const FindOneBjuPressAccountDocument = gql`
  query findOneBjuPressAccount($where: BjuPressAccountWhereUniqueInput!) {
    findOneBjuPressAccount(where: $where) {
      ...BjuPressAccountFragment
    }
  }
  ${BjuPressAccountFragmentFragmentDoc}
`;

/**
 * __useFindOneBjuPressAccountQuery__
 *
 * To run a query within a React component, call `useFindOneBjuPressAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneBjuPressAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneBjuPressAccountQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneBjuPressAccountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneBjuPressAccountQuery, FindOneBjuPressAccountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneBjuPressAccountQuery, FindOneBjuPressAccountQueryVariables>(
    FindOneBjuPressAccountDocument,
    baseOptions,
  );
}
export function useFindOneBjuPressAccountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneBjuPressAccountQuery,
    FindOneBjuPressAccountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneBjuPressAccountQuery, FindOneBjuPressAccountQueryVariables>(
    FindOneBjuPressAccountDocument,
    baseOptions,
  );
}
export type FindOneBjuPressAccountQueryHookResult = ReturnType<typeof useFindOneBjuPressAccountQuery>;
export type FindOneBjuPressAccountLazyQueryHookResult = ReturnType<typeof useFindOneBjuPressAccountLazyQuery>;
export type FindOneBjuPressAccountQueryResult = ApolloReactCommon.QueryResult<
  FindOneBjuPressAccountQuery,
  FindOneBjuPressAccountQueryVariables
>;
export const FindManyBjuPressAccountDocument = gql`
  query findManyBjuPressAccount(
    $where: BjuPressAccountWhereInput
    $orderBy: BjuPressAccountOrderByInput
    $after: BjuPressAccountWhereUniqueInput
    $before: BjuPressAccountWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyBjuPressAccount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...BjuPressAccountFragment
    }
  }
  ${BjuPressAccountFragmentFragmentDoc}
`;

/**
 * __useFindManyBjuPressAccountQuery__
 *
 * To run a query within a React component, call `useFindManyBjuPressAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyBjuPressAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyBjuPressAccountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyBjuPressAccountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyBjuPressAccountQuery, FindManyBjuPressAccountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyBjuPressAccountQuery, FindManyBjuPressAccountQueryVariables>(
    FindManyBjuPressAccountDocument,
    baseOptions,
  );
}
export function useFindManyBjuPressAccountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyBjuPressAccountQuery,
    FindManyBjuPressAccountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyBjuPressAccountQuery, FindManyBjuPressAccountQueryVariables>(
    FindManyBjuPressAccountDocument,
    baseOptions,
  );
}
export type FindManyBjuPressAccountQueryHookResult = ReturnType<typeof useFindManyBjuPressAccountQuery>;
export type FindManyBjuPressAccountLazyQueryHookResult = ReturnType<typeof useFindManyBjuPressAccountLazyQuery>;
export type FindManyBjuPressAccountQueryResult = ApolloReactCommon.QueryResult<
  FindManyBjuPressAccountQuery,
  FindManyBjuPressAccountQueryVariables
>;
export const FindManyBjuPressAccountCountDocument = gql`
  query findManyBjuPressAccountCount(
    $where: BjuPressAccountWhereInput
    $orderBy: BjuPressAccountOrderByInput
    $after: BjuPressAccountWhereUniqueInput
    $before: BjuPressAccountWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyBjuPressAccountCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyBjuPressAccountCountQuery__
 *
 * To run a query within a React component, call `useFindManyBjuPressAccountCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyBjuPressAccountCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyBjuPressAccountCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyBjuPressAccountCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyBjuPressAccountCountQuery,
    FindManyBjuPressAccountCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyBjuPressAccountCountQuery, FindManyBjuPressAccountCountQueryVariables>(
    FindManyBjuPressAccountCountDocument,
    baseOptions,
  );
}
export function useFindManyBjuPressAccountCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyBjuPressAccountCountQuery,
    FindManyBjuPressAccountCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyBjuPressAccountCountQuery, FindManyBjuPressAccountCountQueryVariables>(
    FindManyBjuPressAccountCountDocument,
    baseOptions,
  );
}
export type FindManyBjuPressAccountCountQueryHookResult = ReturnType<typeof useFindManyBjuPressAccountCountQuery>;
export type FindManyBjuPressAccountCountLazyQueryHookResult = ReturnType<
  typeof useFindManyBjuPressAccountCountLazyQuery
>;
export type FindManyBjuPressAccountCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyBjuPressAccountCountQuery,
  FindManyBjuPressAccountCountQueryVariables
>;
export const CreateOneBjuPressAccountDocument = gql`
  mutation createOneBjuPressAccount($data: BjuPressAccountCreateInput!) {
    createOneBjuPressAccount(data: $data) {
      ...BjuPressAccountFragment
    }
  }
  ${BjuPressAccountFragmentFragmentDoc}
`;

/**
 * __useCreateOneBjuPressAccountMutation__
 *
 * To run a mutation, you first call `useCreateOneBjuPressAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneBjuPressAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneBjuPressAccountMutation, { data, loading, error }] = useCreateOneBjuPressAccountMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneBjuPressAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneBjuPressAccountMutation,
    CreateOneBjuPressAccountMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneBjuPressAccountMutation, CreateOneBjuPressAccountMutationVariables>(
    CreateOneBjuPressAccountDocument,
    baseOptions,
  );
}
export type CreateOneBjuPressAccountMutationHookResult = ReturnType<typeof useCreateOneBjuPressAccountMutation>;
export type CreateOneBjuPressAccountMutationResult = ApolloReactCommon.MutationResult<CreateOneBjuPressAccountMutation>;
export type CreateOneBjuPressAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneBjuPressAccountMutation,
  CreateOneBjuPressAccountMutationVariables
>;
export const UpdateOneBjuPressAccountDocument = gql`
  mutation updateOneBjuPressAccount($where: BjuPressAccountWhereUniqueInput!, $data: BjuPressAccountUpdateInput!) {
    updateOneBjuPressAccount(where: $where, data: $data) {
      ...BjuPressAccountFragment
    }
  }
  ${BjuPressAccountFragmentFragmentDoc}
`;

/**
 * __useUpdateOneBjuPressAccountMutation__
 *
 * To run a mutation, you first call `useUpdateOneBjuPressAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneBjuPressAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneBjuPressAccountMutation, { data, loading, error }] = useUpdateOneBjuPressAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneBjuPressAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneBjuPressAccountMutation,
    UpdateOneBjuPressAccountMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneBjuPressAccountMutation, UpdateOneBjuPressAccountMutationVariables>(
    UpdateOneBjuPressAccountDocument,
    baseOptions,
  );
}
export type UpdateOneBjuPressAccountMutationHookResult = ReturnType<typeof useUpdateOneBjuPressAccountMutation>;
export type UpdateOneBjuPressAccountMutationResult = ApolloReactCommon.MutationResult<UpdateOneBjuPressAccountMutation>;
export type UpdateOneBjuPressAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneBjuPressAccountMutation,
  UpdateOneBjuPressAccountMutationVariables
>;
export const DeleteOneBjuPressAccountDocument = gql`
  mutation deleteOneBjuPressAccount($where: BjuPressAccountWhereUniqueInput!) {
    deleteOneBjuPressAccount(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneBjuPressAccountMutation__
 *
 * To run a mutation, you first call `useDeleteOneBjuPressAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneBjuPressAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneBjuPressAccountMutation, { data, loading, error }] = useDeleteOneBjuPressAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneBjuPressAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneBjuPressAccountMutation,
    DeleteOneBjuPressAccountMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneBjuPressAccountMutation, DeleteOneBjuPressAccountMutationVariables>(
    DeleteOneBjuPressAccountDocument,
    baseOptions,
  );
}
export type DeleteOneBjuPressAccountMutationHookResult = ReturnType<typeof useDeleteOneBjuPressAccountMutation>;
export type DeleteOneBjuPressAccountMutationResult = ApolloReactCommon.MutationResult<DeleteOneBjuPressAccountMutation>;
export type DeleteOneBjuPressAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneBjuPressAccountMutation,
  DeleteOneBjuPressAccountMutationVariables
>;
export const DeleteManyBjuPressAccountDocument = gql`
  mutation deleteManyBjuPressAccount($where: BjuPressAccountWhereInput) {
    deleteManyBjuPressAccount(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyBjuPressAccountMutation__
 *
 * To run a mutation, you first call `useDeleteManyBjuPressAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyBjuPressAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyBjuPressAccountMutation, { data, loading, error }] = useDeleteManyBjuPressAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyBjuPressAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyBjuPressAccountMutation,
    DeleteManyBjuPressAccountMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyBjuPressAccountMutation, DeleteManyBjuPressAccountMutationVariables>(
    DeleteManyBjuPressAccountDocument,
    baseOptions,
  );
}
export type DeleteManyBjuPressAccountMutationHookResult = ReturnType<typeof useDeleteManyBjuPressAccountMutation>;
export type DeleteManyBjuPressAccountMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyBjuPressAccountMutation
>;
export type DeleteManyBjuPressAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyBjuPressAccountMutation,
  DeleteManyBjuPressAccountMutationVariables
>;
export const UpdateManyBjuPressAccountDocument = gql`
  mutation updateManyBjuPressAccount(
    $where: BjuPressAccountWhereInput
    $data: BjuPressAccountUpdateManyMutationInput!
  ) {
    updateManyBjuPressAccount(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyBjuPressAccountMutation__
 *
 * To run a mutation, you first call `useUpdateManyBjuPressAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyBjuPressAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyBjuPressAccountMutation, { data, loading, error }] = useUpdateManyBjuPressAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyBjuPressAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyBjuPressAccountMutation,
    UpdateManyBjuPressAccountMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyBjuPressAccountMutation, UpdateManyBjuPressAccountMutationVariables>(
    UpdateManyBjuPressAccountDocument,
    baseOptions,
  );
}
export type UpdateManyBjuPressAccountMutationHookResult = ReturnType<typeof useUpdateManyBjuPressAccountMutation>;
export type UpdateManyBjuPressAccountMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyBjuPressAccountMutation
>;
export type UpdateManyBjuPressAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyBjuPressAccountMutation,
  UpdateManyBjuPressAccountMutationVariables
>;
export const FindOneCourseContentDocument = gql`
  query findOneCourseContent($where: CourseContentWhereUniqueInput!) {
    findOneCourseContent(where: $where) {
      ...CourseContentFragment
    }
  }
  ${CourseContentFragmentFragmentDoc}
`;

/**
 * __useFindOneCourseContentQuery__
 *
 * To run a query within a React component, call `useFindOneCourseContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneCourseContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneCourseContentQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneCourseContentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneCourseContentQuery, FindOneCourseContentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneCourseContentQuery, FindOneCourseContentQueryVariables>(
    FindOneCourseContentDocument,
    baseOptions,
  );
}
export function useFindOneCourseContentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneCourseContentQuery, FindOneCourseContentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneCourseContentQuery, FindOneCourseContentQueryVariables>(
    FindOneCourseContentDocument,
    baseOptions,
  );
}
export type FindOneCourseContentQueryHookResult = ReturnType<typeof useFindOneCourseContentQuery>;
export type FindOneCourseContentLazyQueryHookResult = ReturnType<typeof useFindOneCourseContentLazyQuery>;
export type FindOneCourseContentQueryResult = ApolloReactCommon.QueryResult<
  FindOneCourseContentQuery,
  FindOneCourseContentQueryVariables
>;
export const FindManyCourseContentDocument = gql`
  query findManyCourseContent(
    $where: CourseContentWhereInput
    $orderBy: CourseContentOrderByInput
    $after: CourseContentWhereUniqueInput
    $before: CourseContentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseContent(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...CourseContentFragment
    }
  }
  ${CourseContentFragmentFragmentDoc}
`;

/**
 * __useFindManyCourseContentQuery__
 *
 * To run a query within a React component, call `useFindManyCourseContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseContentQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseContentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyCourseContentQuery, FindManyCourseContentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyCourseContentQuery, FindManyCourseContentQueryVariables>(
    FindManyCourseContentDocument,
    baseOptions,
  );
}
export function useFindManyCourseContentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyCourseContentQuery, FindManyCourseContentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyCourseContentQuery, FindManyCourseContentQueryVariables>(
    FindManyCourseContentDocument,
    baseOptions,
  );
}
export type FindManyCourseContentQueryHookResult = ReturnType<typeof useFindManyCourseContentQuery>;
export type FindManyCourseContentLazyQueryHookResult = ReturnType<typeof useFindManyCourseContentLazyQuery>;
export type FindManyCourseContentQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseContentQuery,
  FindManyCourseContentQueryVariables
>;
export const FindManyCourseContentCountDocument = gql`
  query findManyCourseContentCount(
    $where: CourseContentWhereInput
    $orderBy: CourseContentOrderByInput
    $after: CourseContentWhereUniqueInput
    $before: CourseContentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseContentCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyCourseContentCountQuery__
 *
 * To run a query within a React component, call `useFindManyCourseContentCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseContentCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseContentCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseContentCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseContentCountQuery,
    FindManyCourseContentCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyCourseContentCountQuery, FindManyCourseContentCountQueryVariables>(
    FindManyCourseContentCountDocument,
    baseOptions,
  );
}
export function useFindManyCourseContentCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseContentCountQuery,
    FindManyCourseContentCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyCourseContentCountQuery, FindManyCourseContentCountQueryVariables>(
    FindManyCourseContentCountDocument,
    baseOptions,
  );
}
export type FindManyCourseContentCountQueryHookResult = ReturnType<typeof useFindManyCourseContentCountQuery>;
export type FindManyCourseContentCountLazyQueryHookResult = ReturnType<typeof useFindManyCourseContentCountLazyQuery>;
export type FindManyCourseContentCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseContentCountQuery,
  FindManyCourseContentCountQueryVariables
>;
export const CreateOneCourseContentDocument = gql`
  mutation createOneCourseContent($data: CourseContentCreateInput!) {
    createOneCourseContent(data: $data) {
      ...CourseContentFragment
    }
  }
  ${CourseContentFragmentFragmentDoc}
`;

/**
 * __useCreateOneCourseContentMutation__
 *
 * To run a mutation, you first call `useCreateOneCourseContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneCourseContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneCourseContentMutation, { data, loading, error }] = useCreateOneCourseContentMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneCourseContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneCourseContentMutation,
    CreateOneCourseContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneCourseContentMutation, CreateOneCourseContentMutationVariables>(
    CreateOneCourseContentDocument,
    baseOptions,
  );
}
export type CreateOneCourseContentMutationHookResult = ReturnType<typeof useCreateOneCourseContentMutation>;
export type CreateOneCourseContentMutationResult = ApolloReactCommon.MutationResult<CreateOneCourseContentMutation>;
export type CreateOneCourseContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneCourseContentMutation,
  CreateOneCourseContentMutationVariables
>;
export const UpdateOneCourseContentDocument = gql`
  mutation updateOneCourseContent($where: CourseContentWhereUniqueInput!, $data: CourseContentUpdateInput!) {
    updateOneCourseContent(where: $where, data: $data) {
      ...CourseContentFragment
    }
  }
  ${CourseContentFragmentFragmentDoc}
`;

/**
 * __useUpdateOneCourseContentMutation__
 *
 * To run a mutation, you first call `useUpdateOneCourseContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneCourseContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneCourseContentMutation, { data, loading, error }] = useUpdateOneCourseContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneCourseContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneCourseContentMutation,
    UpdateOneCourseContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneCourseContentMutation, UpdateOneCourseContentMutationVariables>(
    UpdateOneCourseContentDocument,
    baseOptions,
  );
}
export type UpdateOneCourseContentMutationHookResult = ReturnType<typeof useUpdateOneCourseContentMutation>;
export type UpdateOneCourseContentMutationResult = ApolloReactCommon.MutationResult<UpdateOneCourseContentMutation>;
export type UpdateOneCourseContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneCourseContentMutation,
  UpdateOneCourseContentMutationVariables
>;
export const DeleteOneCourseContentDocument = gql`
  mutation deleteOneCourseContent($where: CourseContentWhereUniqueInput!) {
    deleteOneCourseContent(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneCourseContentMutation__
 *
 * To run a mutation, you first call `useDeleteOneCourseContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneCourseContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneCourseContentMutation, { data, loading, error }] = useDeleteOneCourseContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneCourseContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneCourseContentMutation,
    DeleteOneCourseContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneCourseContentMutation, DeleteOneCourseContentMutationVariables>(
    DeleteOneCourseContentDocument,
    baseOptions,
  );
}
export type DeleteOneCourseContentMutationHookResult = ReturnType<typeof useDeleteOneCourseContentMutation>;
export type DeleteOneCourseContentMutationResult = ApolloReactCommon.MutationResult<DeleteOneCourseContentMutation>;
export type DeleteOneCourseContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneCourseContentMutation,
  DeleteOneCourseContentMutationVariables
>;
export const DeleteManyCourseContentDocument = gql`
  mutation deleteManyCourseContent($where: CourseContentWhereInput) {
    deleteManyCourseContent(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyCourseContentMutation__
 *
 * To run a mutation, you first call `useDeleteManyCourseContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyCourseContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyCourseContentMutation, { data, loading, error }] = useDeleteManyCourseContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyCourseContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyCourseContentMutation,
    DeleteManyCourseContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyCourseContentMutation, DeleteManyCourseContentMutationVariables>(
    DeleteManyCourseContentDocument,
    baseOptions,
  );
}
export type DeleteManyCourseContentMutationHookResult = ReturnType<typeof useDeleteManyCourseContentMutation>;
export type DeleteManyCourseContentMutationResult = ApolloReactCommon.MutationResult<DeleteManyCourseContentMutation>;
export type DeleteManyCourseContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyCourseContentMutation,
  DeleteManyCourseContentMutationVariables
>;
export const UpdateManyCourseContentDocument = gql`
  mutation updateManyCourseContent($where: CourseContentWhereInput, $data: CourseContentUpdateManyMutationInput!) {
    updateManyCourseContent(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyCourseContentMutation__
 *
 * To run a mutation, you first call `useUpdateManyCourseContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyCourseContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyCourseContentMutation, { data, loading, error }] = useUpdateManyCourseContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyCourseContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyCourseContentMutation,
    UpdateManyCourseContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyCourseContentMutation, UpdateManyCourseContentMutationVariables>(
    UpdateManyCourseContentDocument,
    baseOptions,
  );
}
export type UpdateManyCourseContentMutationHookResult = ReturnType<typeof useUpdateManyCourseContentMutation>;
export type UpdateManyCourseContentMutationResult = ApolloReactCommon.MutationResult<UpdateManyCourseContentMutation>;
export type UpdateManyCourseContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyCourseContentMutation,
  UpdateManyCourseContentMutationVariables
>;
export const FindOneCourseContentCodeDocument = gql`
  query findOneCourseContentCode($where: CourseContentCodeWhereUniqueInput!) {
    findOneCourseContentCode(where: $where) {
      ...CourseContentCodeFragment
    }
  }
  ${CourseContentCodeFragmentFragmentDoc}
`;

/**
 * __useFindOneCourseContentCodeQuery__
 *
 * To run a query within a React component, call `useFindOneCourseContentCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneCourseContentCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneCourseContentCodeQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneCourseContentCodeQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneCourseContentCodeQuery,
    FindOneCourseContentCodeQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneCourseContentCodeQuery, FindOneCourseContentCodeQueryVariables>(
    FindOneCourseContentCodeDocument,
    baseOptions,
  );
}
export function useFindOneCourseContentCodeLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneCourseContentCodeQuery,
    FindOneCourseContentCodeQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneCourseContentCodeQuery, FindOneCourseContentCodeQueryVariables>(
    FindOneCourseContentCodeDocument,
    baseOptions,
  );
}
export type FindOneCourseContentCodeQueryHookResult = ReturnType<typeof useFindOneCourseContentCodeQuery>;
export type FindOneCourseContentCodeLazyQueryHookResult = ReturnType<typeof useFindOneCourseContentCodeLazyQuery>;
export type FindOneCourseContentCodeQueryResult = ApolloReactCommon.QueryResult<
  FindOneCourseContentCodeQuery,
  FindOneCourseContentCodeQueryVariables
>;
export const FindManyCourseContentCodeDocument = gql`
  query findManyCourseContentCode(
    $where: CourseContentCodeWhereInput
    $orderBy: CourseContentCodeOrderByInput
    $after: CourseContentCodeWhereUniqueInput
    $before: CourseContentCodeWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseContentCode(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...CourseContentCodeFragment
    }
  }
  ${CourseContentCodeFragmentFragmentDoc}
`;

/**
 * __useFindManyCourseContentCodeQuery__
 *
 * To run a query within a React component, call `useFindManyCourseContentCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseContentCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseContentCodeQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseContentCodeQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseContentCodeQuery,
    FindManyCourseContentCodeQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyCourseContentCodeQuery, FindManyCourseContentCodeQueryVariables>(
    FindManyCourseContentCodeDocument,
    baseOptions,
  );
}
export function useFindManyCourseContentCodeLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseContentCodeQuery,
    FindManyCourseContentCodeQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyCourseContentCodeQuery, FindManyCourseContentCodeQueryVariables>(
    FindManyCourseContentCodeDocument,
    baseOptions,
  );
}
export type FindManyCourseContentCodeQueryHookResult = ReturnType<typeof useFindManyCourseContentCodeQuery>;
export type FindManyCourseContentCodeLazyQueryHookResult = ReturnType<typeof useFindManyCourseContentCodeLazyQuery>;
export type FindManyCourseContentCodeQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseContentCodeQuery,
  FindManyCourseContentCodeQueryVariables
>;
export const FindManyCourseContentCodeCountDocument = gql`
  query findManyCourseContentCodeCount(
    $where: CourseContentCodeWhereInput
    $orderBy: CourseContentCodeOrderByInput
    $after: CourseContentCodeWhereUniqueInput
    $before: CourseContentCodeWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseContentCodeCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyCourseContentCodeCountQuery__
 *
 * To run a query within a React component, call `useFindManyCourseContentCodeCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseContentCodeCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseContentCodeCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseContentCodeCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseContentCodeCountQuery,
    FindManyCourseContentCodeCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyCourseContentCodeCountQuery, FindManyCourseContentCodeCountQueryVariables>(
    FindManyCourseContentCodeCountDocument,
    baseOptions,
  );
}
export function useFindManyCourseContentCodeCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseContentCodeCountQuery,
    FindManyCourseContentCodeCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyCourseContentCodeCountQuery,
    FindManyCourseContentCodeCountQueryVariables
  >(FindManyCourseContentCodeCountDocument, baseOptions);
}
export type FindManyCourseContentCodeCountQueryHookResult = ReturnType<typeof useFindManyCourseContentCodeCountQuery>;
export type FindManyCourseContentCodeCountLazyQueryHookResult = ReturnType<
  typeof useFindManyCourseContentCodeCountLazyQuery
>;
export type FindManyCourseContentCodeCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseContentCodeCountQuery,
  FindManyCourseContentCodeCountQueryVariables
>;
export const CreateOneCourseContentCodeDocument = gql`
  mutation createOneCourseContentCode($data: CourseContentCodeCreateInput!) {
    createOneCourseContentCode(data: $data) {
      ...CourseContentCodeFragment
    }
  }
  ${CourseContentCodeFragmentFragmentDoc}
`;

/**
 * __useCreateOneCourseContentCodeMutation__
 *
 * To run a mutation, you first call `useCreateOneCourseContentCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneCourseContentCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneCourseContentCodeMutation, { data, loading, error }] = useCreateOneCourseContentCodeMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneCourseContentCodeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneCourseContentCodeMutation,
    CreateOneCourseContentCodeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneCourseContentCodeMutation, CreateOneCourseContentCodeMutationVariables>(
    CreateOneCourseContentCodeDocument,
    baseOptions,
  );
}
export type CreateOneCourseContentCodeMutationHookResult = ReturnType<typeof useCreateOneCourseContentCodeMutation>;
export type CreateOneCourseContentCodeMutationResult = ApolloReactCommon.MutationResult<
  CreateOneCourseContentCodeMutation
>;
export type CreateOneCourseContentCodeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneCourseContentCodeMutation,
  CreateOneCourseContentCodeMutationVariables
>;
export const UpdateOneCourseContentCodeDocument = gql`
  mutation updateOneCourseContentCode(
    $where: CourseContentCodeWhereUniqueInput!
    $data: CourseContentCodeUpdateInput!
  ) {
    updateOneCourseContentCode(where: $where, data: $data) {
      ...CourseContentCodeFragment
    }
  }
  ${CourseContentCodeFragmentFragmentDoc}
`;

/**
 * __useUpdateOneCourseContentCodeMutation__
 *
 * To run a mutation, you first call `useUpdateOneCourseContentCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneCourseContentCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneCourseContentCodeMutation, { data, loading, error }] = useUpdateOneCourseContentCodeMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneCourseContentCodeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneCourseContentCodeMutation,
    UpdateOneCourseContentCodeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneCourseContentCodeMutation, UpdateOneCourseContentCodeMutationVariables>(
    UpdateOneCourseContentCodeDocument,
    baseOptions,
  );
}
export type UpdateOneCourseContentCodeMutationHookResult = ReturnType<typeof useUpdateOneCourseContentCodeMutation>;
export type UpdateOneCourseContentCodeMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneCourseContentCodeMutation
>;
export type UpdateOneCourseContentCodeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneCourseContentCodeMutation,
  UpdateOneCourseContentCodeMutationVariables
>;
export const DeleteOneCourseContentCodeDocument = gql`
  mutation deleteOneCourseContentCode($where: CourseContentCodeWhereUniqueInput!) {
    deleteOneCourseContentCode(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneCourseContentCodeMutation__
 *
 * To run a mutation, you first call `useDeleteOneCourseContentCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneCourseContentCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneCourseContentCodeMutation, { data, loading, error }] = useDeleteOneCourseContentCodeMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneCourseContentCodeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneCourseContentCodeMutation,
    DeleteOneCourseContentCodeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneCourseContentCodeMutation, DeleteOneCourseContentCodeMutationVariables>(
    DeleteOneCourseContentCodeDocument,
    baseOptions,
  );
}
export type DeleteOneCourseContentCodeMutationHookResult = ReturnType<typeof useDeleteOneCourseContentCodeMutation>;
export type DeleteOneCourseContentCodeMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneCourseContentCodeMutation
>;
export type DeleteOneCourseContentCodeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneCourseContentCodeMutation,
  DeleteOneCourseContentCodeMutationVariables
>;
export const DeleteManyCourseContentCodeDocument = gql`
  mutation deleteManyCourseContentCode($where: CourseContentCodeWhereInput) {
    deleteManyCourseContentCode(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyCourseContentCodeMutation__
 *
 * To run a mutation, you first call `useDeleteManyCourseContentCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyCourseContentCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyCourseContentCodeMutation, { data, loading, error }] = useDeleteManyCourseContentCodeMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyCourseContentCodeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyCourseContentCodeMutation,
    DeleteManyCourseContentCodeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyCourseContentCodeMutation,
    DeleteManyCourseContentCodeMutationVariables
  >(DeleteManyCourseContentCodeDocument, baseOptions);
}
export type DeleteManyCourseContentCodeMutationHookResult = ReturnType<typeof useDeleteManyCourseContentCodeMutation>;
export type DeleteManyCourseContentCodeMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyCourseContentCodeMutation
>;
export type DeleteManyCourseContentCodeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyCourseContentCodeMutation,
  DeleteManyCourseContentCodeMutationVariables
>;
export const UpdateManyCourseContentCodeDocument = gql`
  mutation updateManyCourseContentCode(
    $where: CourseContentCodeWhereInput
    $data: CourseContentCodeUpdateManyMutationInput!
  ) {
    updateManyCourseContentCode(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyCourseContentCodeMutation__
 *
 * To run a mutation, you first call `useUpdateManyCourseContentCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyCourseContentCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyCourseContentCodeMutation, { data, loading, error }] = useUpdateManyCourseContentCodeMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyCourseContentCodeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyCourseContentCodeMutation,
    UpdateManyCourseContentCodeMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyCourseContentCodeMutation,
    UpdateManyCourseContentCodeMutationVariables
  >(UpdateManyCourseContentCodeDocument, baseOptions);
}
export type UpdateManyCourseContentCodeMutationHookResult = ReturnType<typeof useUpdateManyCourseContentCodeMutation>;
export type UpdateManyCourseContentCodeMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyCourseContentCodeMutation
>;
export type UpdateManyCourseContentCodeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyCourseContentCodeMutation,
  UpdateManyCourseContentCodeMutationVariables
>;
export const FindOneCourseContentWeightCategoryDocument = gql`
  query findOneCourseContentWeightCategory($where: CourseContentWeightCategoryWhereUniqueInput!) {
    findOneCourseContentWeightCategory(where: $where) {
      ...CourseContentWeightCategoryFragment
    }
  }
  ${CourseContentWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useFindOneCourseContentWeightCategoryQuery__
 *
 * To run a query within a React component, call `useFindOneCourseContentWeightCategoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneCourseContentWeightCategoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneCourseContentWeightCategoryQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneCourseContentWeightCategoryQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneCourseContentWeightCategoryQuery,
    FindOneCourseContentWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindOneCourseContentWeightCategoryQuery,
    FindOneCourseContentWeightCategoryQueryVariables
  >(FindOneCourseContentWeightCategoryDocument, baseOptions);
}
export function useFindOneCourseContentWeightCategoryLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneCourseContentWeightCategoryQuery,
    FindOneCourseContentWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneCourseContentWeightCategoryQuery,
    FindOneCourseContentWeightCategoryQueryVariables
  >(FindOneCourseContentWeightCategoryDocument, baseOptions);
}
export type FindOneCourseContentWeightCategoryQueryHookResult = ReturnType<
  typeof useFindOneCourseContentWeightCategoryQuery
>;
export type FindOneCourseContentWeightCategoryLazyQueryHookResult = ReturnType<
  typeof useFindOneCourseContentWeightCategoryLazyQuery
>;
export type FindOneCourseContentWeightCategoryQueryResult = ApolloReactCommon.QueryResult<
  FindOneCourseContentWeightCategoryQuery,
  FindOneCourseContentWeightCategoryQueryVariables
>;
export const FindManyCourseContentWeightCategoryDocument = gql`
  query findManyCourseContentWeightCategory(
    $where: CourseContentWeightCategoryWhereInput
    $orderBy: CourseContentWeightCategoryOrderByInput
    $after: CourseContentWeightCategoryWhereUniqueInput
    $before: CourseContentWeightCategoryWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseContentWeightCategory(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...CourseContentWeightCategoryFragment
    }
  }
  ${CourseContentWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useFindManyCourseContentWeightCategoryQuery__
 *
 * To run a query within a React component, call `useFindManyCourseContentWeightCategoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseContentWeightCategoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseContentWeightCategoryQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseContentWeightCategoryQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseContentWeightCategoryQuery,
    FindManyCourseContentWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyCourseContentWeightCategoryQuery,
    FindManyCourseContentWeightCategoryQueryVariables
  >(FindManyCourseContentWeightCategoryDocument, baseOptions);
}
export function useFindManyCourseContentWeightCategoryLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseContentWeightCategoryQuery,
    FindManyCourseContentWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyCourseContentWeightCategoryQuery,
    FindManyCourseContentWeightCategoryQueryVariables
  >(FindManyCourseContentWeightCategoryDocument, baseOptions);
}
export type FindManyCourseContentWeightCategoryQueryHookResult = ReturnType<
  typeof useFindManyCourseContentWeightCategoryQuery
>;
export type FindManyCourseContentWeightCategoryLazyQueryHookResult = ReturnType<
  typeof useFindManyCourseContentWeightCategoryLazyQuery
>;
export type FindManyCourseContentWeightCategoryQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseContentWeightCategoryQuery,
  FindManyCourseContentWeightCategoryQueryVariables
>;
export const FindManyCourseContentWeightCategoryCountDocument = gql`
  query findManyCourseContentWeightCategoryCount(
    $where: CourseContentWeightCategoryWhereInput
    $orderBy: CourseContentWeightCategoryOrderByInput
    $after: CourseContentWeightCategoryWhereUniqueInput
    $before: CourseContentWeightCategoryWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseContentWeightCategoryCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyCourseContentWeightCategoryCountQuery__
 *
 * To run a query within a React component, call `useFindManyCourseContentWeightCategoryCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseContentWeightCategoryCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseContentWeightCategoryCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseContentWeightCategoryCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseContentWeightCategoryCountQuery,
    FindManyCourseContentWeightCategoryCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyCourseContentWeightCategoryCountQuery,
    FindManyCourseContentWeightCategoryCountQueryVariables
  >(FindManyCourseContentWeightCategoryCountDocument, baseOptions);
}
export function useFindManyCourseContentWeightCategoryCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseContentWeightCategoryCountQuery,
    FindManyCourseContentWeightCategoryCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyCourseContentWeightCategoryCountQuery,
    FindManyCourseContentWeightCategoryCountQueryVariables
  >(FindManyCourseContentWeightCategoryCountDocument, baseOptions);
}
export type FindManyCourseContentWeightCategoryCountQueryHookResult = ReturnType<
  typeof useFindManyCourseContentWeightCategoryCountQuery
>;
export type FindManyCourseContentWeightCategoryCountLazyQueryHookResult = ReturnType<
  typeof useFindManyCourseContentWeightCategoryCountLazyQuery
>;
export type FindManyCourseContentWeightCategoryCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseContentWeightCategoryCountQuery,
  FindManyCourseContentWeightCategoryCountQueryVariables
>;
export const CreateOneCourseContentWeightCategoryDocument = gql`
  mutation createOneCourseContentWeightCategory($data: CourseContentWeightCategoryCreateInput!) {
    createOneCourseContentWeightCategory(data: $data) {
      ...CourseContentWeightCategoryFragment
    }
  }
  ${CourseContentWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useCreateOneCourseContentWeightCategoryMutation__
 *
 * To run a mutation, you first call `useCreateOneCourseContentWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneCourseContentWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneCourseContentWeightCategoryMutation, { data, loading, error }] = useCreateOneCourseContentWeightCategoryMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneCourseContentWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneCourseContentWeightCategoryMutation,
    CreateOneCourseContentWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneCourseContentWeightCategoryMutation,
    CreateOneCourseContentWeightCategoryMutationVariables
  >(CreateOneCourseContentWeightCategoryDocument, baseOptions);
}
export type CreateOneCourseContentWeightCategoryMutationHookResult = ReturnType<
  typeof useCreateOneCourseContentWeightCategoryMutation
>;
export type CreateOneCourseContentWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  CreateOneCourseContentWeightCategoryMutation
>;
export type CreateOneCourseContentWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneCourseContentWeightCategoryMutation,
  CreateOneCourseContentWeightCategoryMutationVariables
>;
export const UpdateOneCourseContentWeightCategoryDocument = gql`
  mutation updateOneCourseContentWeightCategory(
    $where: CourseContentWeightCategoryWhereUniqueInput!
    $data: CourseContentWeightCategoryUpdateInput!
  ) {
    updateOneCourseContentWeightCategory(where: $where, data: $data) {
      ...CourseContentWeightCategoryFragment
    }
  }
  ${CourseContentWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useUpdateOneCourseContentWeightCategoryMutation__
 *
 * To run a mutation, you first call `useUpdateOneCourseContentWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneCourseContentWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneCourseContentWeightCategoryMutation, { data, loading, error }] = useUpdateOneCourseContentWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneCourseContentWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneCourseContentWeightCategoryMutation,
    UpdateOneCourseContentWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneCourseContentWeightCategoryMutation,
    UpdateOneCourseContentWeightCategoryMutationVariables
  >(UpdateOneCourseContentWeightCategoryDocument, baseOptions);
}
export type UpdateOneCourseContentWeightCategoryMutationHookResult = ReturnType<
  typeof useUpdateOneCourseContentWeightCategoryMutation
>;
export type UpdateOneCourseContentWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneCourseContentWeightCategoryMutation
>;
export type UpdateOneCourseContentWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneCourseContentWeightCategoryMutation,
  UpdateOneCourseContentWeightCategoryMutationVariables
>;
export const DeleteOneCourseContentWeightCategoryDocument = gql`
  mutation deleteOneCourseContentWeightCategory($where: CourseContentWeightCategoryWhereUniqueInput!) {
    deleteOneCourseContentWeightCategory(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneCourseContentWeightCategoryMutation__
 *
 * To run a mutation, you first call `useDeleteOneCourseContentWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneCourseContentWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneCourseContentWeightCategoryMutation, { data, loading, error }] = useDeleteOneCourseContentWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneCourseContentWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneCourseContentWeightCategoryMutation,
    DeleteOneCourseContentWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneCourseContentWeightCategoryMutation,
    DeleteOneCourseContentWeightCategoryMutationVariables
  >(DeleteOneCourseContentWeightCategoryDocument, baseOptions);
}
export type DeleteOneCourseContentWeightCategoryMutationHookResult = ReturnType<
  typeof useDeleteOneCourseContentWeightCategoryMutation
>;
export type DeleteOneCourseContentWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneCourseContentWeightCategoryMutation
>;
export type DeleteOneCourseContentWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneCourseContentWeightCategoryMutation,
  DeleteOneCourseContentWeightCategoryMutationVariables
>;
export const DeleteManyCourseContentWeightCategoryDocument = gql`
  mutation deleteManyCourseContentWeightCategory($where: CourseContentWeightCategoryWhereInput) {
    deleteManyCourseContentWeightCategory(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyCourseContentWeightCategoryMutation__
 *
 * To run a mutation, you first call `useDeleteManyCourseContentWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyCourseContentWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyCourseContentWeightCategoryMutation, { data, loading, error }] = useDeleteManyCourseContentWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyCourseContentWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyCourseContentWeightCategoryMutation,
    DeleteManyCourseContentWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyCourseContentWeightCategoryMutation,
    DeleteManyCourseContentWeightCategoryMutationVariables
  >(DeleteManyCourseContentWeightCategoryDocument, baseOptions);
}
export type DeleteManyCourseContentWeightCategoryMutationHookResult = ReturnType<
  typeof useDeleteManyCourseContentWeightCategoryMutation
>;
export type DeleteManyCourseContentWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyCourseContentWeightCategoryMutation
>;
export type DeleteManyCourseContentWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyCourseContentWeightCategoryMutation,
  DeleteManyCourseContentWeightCategoryMutationVariables
>;
export const UpdateManyCourseContentWeightCategoryDocument = gql`
  mutation updateManyCourseContentWeightCategory(
    $where: CourseContentWeightCategoryWhereInput
    $data: CourseContentWeightCategoryUpdateManyMutationInput!
  ) {
    updateManyCourseContentWeightCategory(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyCourseContentWeightCategoryMutation__
 *
 * To run a mutation, you first call `useUpdateManyCourseContentWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyCourseContentWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyCourseContentWeightCategoryMutation, { data, loading, error }] = useUpdateManyCourseContentWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyCourseContentWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyCourseContentWeightCategoryMutation,
    UpdateManyCourseContentWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyCourseContentWeightCategoryMutation,
    UpdateManyCourseContentWeightCategoryMutationVariables
  >(UpdateManyCourseContentWeightCategoryDocument, baseOptions);
}
export type UpdateManyCourseContentWeightCategoryMutationHookResult = ReturnType<
  typeof useUpdateManyCourseContentWeightCategoryMutation
>;
export type UpdateManyCourseContentWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyCourseContentWeightCategoryMutation
>;
export type UpdateManyCourseContentWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyCourseContentWeightCategoryMutation,
  UpdateManyCourseContentWeightCategoryMutationVariables
>;
export const FindOneCourseTakingDocument = gql`
  query findOneCourseTaking($where: CourseTakingWhereUniqueInput!) {
    findOneCourseTaking(where: $where) {
      ...CourseTakingFragment
    }
  }
  ${CourseTakingFragmentFragmentDoc}
`;

/**
 * __useFindOneCourseTakingQuery__
 *
 * To run a query within a React component, call `useFindOneCourseTakingQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneCourseTakingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneCourseTakingQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneCourseTakingQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneCourseTakingQuery, FindOneCourseTakingQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneCourseTakingQuery, FindOneCourseTakingQueryVariables>(
    FindOneCourseTakingDocument,
    baseOptions,
  );
}
export function useFindOneCourseTakingLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneCourseTakingQuery, FindOneCourseTakingQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneCourseTakingQuery, FindOneCourseTakingQueryVariables>(
    FindOneCourseTakingDocument,
    baseOptions,
  );
}
export type FindOneCourseTakingQueryHookResult = ReturnType<typeof useFindOneCourseTakingQuery>;
export type FindOneCourseTakingLazyQueryHookResult = ReturnType<typeof useFindOneCourseTakingLazyQuery>;
export type FindOneCourseTakingQueryResult = ApolloReactCommon.QueryResult<
  FindOneCourseTakingQuery,
  FindOneCourseTakingQueryVariables
>;
export const FindManyCourseTakingDocument = gql`
  query findManyCourseTaking(
    $where: CourseTakingWhereInput
    $orderBy: CourseTakingOrderByInput
    $after: CourseTakingWhereUniqueInput
    $before: CourseTakingWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseTaking(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...CourseTakingFragment
    }
  }
  ${CourseTakingFragmentFragmentDoc}
`;

/**
 * __useFindManyCourseTakingQuery__
 *
 * To run a query within a React component, call `useFindManyCourseTakingQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseTakingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseTakingQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseTakingQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyCourseTakingQuery, FindManyCourseTakingQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyCourseTakingQuery, FindManyCourseTakingQueryVariables>(
    FindManyCourseTakingDocument,
    baseOptions,
  );
}
export function useFindManyCourseTakingLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyCourseTakingQuery, FindManyCourseTakingQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyCourseTakingQuery, FindManyCourseTakingQueryVariables>(
    FindManyCourseTakingDocument,
    baseOptions,
  );
}
export type FindManyCourseTakingQueryHookResult = ReturnType<typeof useFindManyCourseTakingQuery>;
export type FindManyCourseTakingLazyQueryHookResult = ReturnType<typeof useFindManyCourseTakingLazyQuery>;
export type FindManyCourseTakingQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseTakingQuery,
  FindManyCourseTakingQueryVariables
>;
export const FindManyCourseTakingCountDocument = gql`
  query findManyCourseTakingCount(
    $where: CourseTakingWhereInput
    $orderBy: CourseTakingOrderByInput
    $after: CourseTakingWhereUniqueInput
    $before: CourseTakingWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseTakingCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyCourseTakingCountQuery__
 *
 * To run a query within a React component, call `useFindManyCourseTakingCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseTakingCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseTakingCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseTakingCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseTakingCountQuery,
    FindManyCourseTakingCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyCourseTakingCountQuery, FindManyCourseTakingCountQueryVariables>(
    FindManyCourseTakingCountDocument,
    baseOptions,
  );
}
export function useFindManyCourseTakingCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseTakingCountQuery,
    FindManyCourseTakingCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyCourseTakingCountQuery, FindManyCourseTakingCountQueryVariables>(
    FindManyCourseTakingCountDocument,
    baseOptions,
  );
}
export type FindManyCourseTakingCountQueryHookResult = ReturnType<typeof useFindManyCourseTakingCountQuery>;
export type FindManyCourseTakingCountLazyQueryHookResult = ReturnType<typeof useFindManyCourseTakingCountLazyQuery>;
export type FindManyCourseTakingCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseTakingCountQuery,
  FindManyCourseTakingCountQueryVariables
>;
export const CreateOneCourseTakingDocument = gql`
  mutation createOneCourseTaking($data: CourseTakingCreateInput!) {
    createOneCourseTaking(data: $data) {
      ...CourseTakingFragment
    }
  }
  ${CourseTakingFragmentFragmentDoc}
`;

/**
 * __useCreateOneCourseTakingMutation__
 *
 * To run a mutation, you first call `useCreateOneCourseTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneCourseTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneCourseTakingMutation, { data, loading, error }] = useCreateOneCourseTakingMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneCourseTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneCourseTakingMutation,
    CreateOneCourseTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneCourseTakingMutation, CreateOneCourseTakingMutationVariables>(
    CreateOneCourseTakingDocument,
    baseOptions,
  );
}
export type CreateOneCourseTakingMutationHookResult = ReturnType<typeof useCreateOneCourseTakingMutation>;
export type CreateOneCourseTakingMutationResult = ApolloReactCommon.MutationResult<CreateOneCourseTakingMutation>;
export type CreateOneCourseTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneCourseTakingMutation,
  CreateOneCourseTakingMutationVariables
>;
export const UpdateOneCourseTakingDocument = gql`
  mutation updateOneCourseTaking($where: CourseTakingWhereUniqueInput!, $data: CourseTakingUpdateInput!) {
    updateOneCourseTaking(where: $where, data: $data) {
      ...CourseTakingFragment
    }
  }
  ${CourseTakingFragmentFragmentDoc}
`;

/**
 * __useUpdateOneCourseTakingMutation__
 *
 * To run a mutation, you first call `useUpdateOneCourseTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneCourseTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneCourseTakingMutation, { data, loading, error }] = useUpdateOneCourseTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneCourseTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneCourseTakingMutation,
    UpdateOneCourseTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneCourseTakingMutation, UpdateOneCourseTakingMutationVariables>(
    UpdateOneCourseTakingDocument,
    baseOptions,
  );
}
export type UpdateOneCourseTakingMutationHookResult = ReturnType<typeof useUpdateOneCourseTakingMutation>;
export type UpdateOneCourseTakingMutationResult = ApolloReactCommon.MutationResult<UpdateOneCourseTakingMutation>;
export type UpdateOneCourseTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneCourseTakingMutation,
  UpdateOneCourseTakingMutationVariables
>;
export const DeleteOneCourseTakingDocument = gql`
  mutation deleteOneCourseTaking($where: CourseTakingWhereUniqueInput!) {
    deleteOneCourseTaking(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneCourseTakingMutation__
 *
 * To run a mutation, you first call `useDeleteOneCourseTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneCourseTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneCourseTakingMutation, { data, loading, error }] = useDeleteOneCourseTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneCourseTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneCourseTakingMutation,
    DeleteOneCourseTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneCourseTakingMutation, DeleteOneCourseTakingMutationVariables>(
    DeleteOneCourseTakingDocument,
    baseOptions,
  );
}
export type DeleteOneCourseTakingMutationHookResult = ReturnType<typeof useDeleteOneCourseTakingMutation>;
export type DeleteOneCourseTakingMutationResult = ApolloReactCommon.MutationResult<DeleteOneCourseTakingMutation>;
export type DeleteOneCourseTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneCourseTakingMutation,
  DeleteOneCourseTakingMutationVariables
>;
export const DeleteManyCourseTakingDocument = gql`
  mutation deleteManyCourseTaking($where: CourseTakingWhereInput) {
    deleteManyCourseTaking(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyCourseTakingMutation__
 *
 * To run a mutation, you first call `useDeleteManyCourseTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyCourseTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyCourseTakingMutation, { data, loading, error }] = useDeleteManyCourseTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyCourseTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyCourseTakingMutation,
    DeleteManyCourseTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyCourseTakingMutation, DeleteManyCourseTakingMutationVariables>(
    DeleteManyCourseTakingDocument,
    baseOptions,
  );
}
export type DeleteManyCourseTakingMutationHookResult = ReturnType<typeof useDeleteManyCourseTakingMutation>;
export type DeleteManyCourseTakingMutationResult = ApolloReactCommon.MutationResult<DeleteManyCourseTakingMutation>;
export type DeleteManyCourseTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyCourseTakingMutation,
  DeleteManyCourseTakingMutationVariables
>;
export const UpdateManyCourseTakingDocument = gql`
  mutation updateManyCourseTaking($where: CourseTakingWhereInput, $data: CourseTakingUpdateManyMutationInput!) {
    updateManyCourseTaking(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyCourseTakingMutation__
 *
 * To run a mutation, you first call `useUpdateManyCourseTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyCourseTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyCourseTakingMutation, { data, loading, error }] = useUpdateManyCourseTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyCourseTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyCourseTakingMutation,
    UpdateManyCourseTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyCourseTakingMutation, UpdateManyCourseTakingMutationVariables>(
    UpdateManyCourseTakingDocument,
    baseOptions,
  );
}
export type UpdateManyCourseTakingMutationHookResult = ReturnType<typeof useUpdateManyCourseTakingMutation>;
export type UpdateManyCourseTakingMutationResult = ApolloReactCommon.MutationResult<UpdateManyCourseTakingMutation>;
export type UpdateManyCourseTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyCourseTakingMutation,
  UpdateManyCourseTakingMutationVariables
>;
export const FindOneCourseTakingWeightCategoryDocument = gql`
  query findOneCourseTakingWeightCategory($where: CourseTakingWeightCategoryWhereUniqueInput!) {
    findOneCourseTakingWeightCategory(where: $where) {
      ...CourseTakingWeightCategoryFragment
    }
  }
  ${CourseTakingWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useFindOneCourseTakingWeightCategoryQuery__
 *
 * To run a query within a React component, call `useFindOneCourseTakingWeightCategoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneCourseTakingWeightCategoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneCourseTakingWeightCategoryQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneCourseTakingWeightCategoryQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneCourseTakingWeightCategoryQuery,
    FindOneCourseTakingWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindOneCourseTakingWeightCategoryQuery,
    FindOneCourseTakingWeightCategoryQueryVariables
  >(FindOneCourseTakingWeightCategoryDocument, baseOptions);
}
export function useFindOneCourseTakingWeightCategoryLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneCourseTakingWeightCategoryQuery,
    FindOneCourseTakingWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindOneCourseTakingWeightCategoryQuery,
    FindOneCourseTakingWeightCategoryQueryVariables
  >(FindOneCourseTakingWeightCategoryDocument, baseOptions);
}
export type FindOneCourseTakingWeightCategoryQueryHookResult = ReturnType<
  typeof useFindOneCourseTakingWeightCategoryQuery
>;
export type FindOneCourseTakingWeightCategoryLazyQueryHookResult = ReturnType<
  typeof useFindOneCourseTakingWeightCategoryLazyQuery
>;
export type FindOneCourseTakingWeightCategoryQueryResult = ApolloReactCommon.QueryResult<
  FindOneCourseTakingWeightCategoryQuery,
  FindOneCourseTakingWeightCategoryQueryVariables
>;
export const FindManyCourseTakingWeightCategoryDocument = gql`
  query findManyCourseTakingWeightCategory(
    $where: CourseTakingWeightCategoryWhereInput
    $orderBy: CourseTakingWeightCategoryOrderByInput
    $after: CourseTakingWeightCategoryWhereUniqueInput
    $before: CourseTakingWeightCategoryWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseTakingWeightCategory(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...CourseTakingWeightCategoryFragment
    }
  }
  ${CourseTakingWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useFindManyCourseTakingWeightCategoryQuery__
 *
 * To run a query within a React component, call `useFindManyCourseTakingWeightCategoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseTakingWeightCategoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseTakingWeightCategoryQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseTakingWeightCategoryQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseTakingWeightCategoryQuery,
    FindManyCourseTakingWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyCourseTakingWeightCategoryQuery,
    FindManyCourseTakingWeightCategoryQueryVariables
  >(FindManyCourseTakingWeightCategoryDocument, baseOptions);
}
export function useFindManyCourseTakingWeightCategoryLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseTakingWeightCategoryQuery,
    FindManyCourseTakingWeightCategoryQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyCourseTakingWeightCategoryQuery,
    FindManyCourseTakingWeightCategoryQueryVariables
  >(FindManyCourseTakingWeightCategoryDocument, baseOptions);
}
export type FindManyCourseTakingWeightCategoryQueryHookResult = ReturnType<
  typeof useFindManyCourseTakingWeightCategoryQuery
>;
export type FindManyCourseTakingWeightCategoryLazyQueryHookResult = ReturnType<
  typeof useFindManyCourseTakingWeightCategoryLazyQuery
>;
export type FindManyCourseTakingWeightCategoryQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseTakingWeightCategoryQuery,
  FindManyCourseTakingWeightCategoryQueryVariables
>;
export const FindManyCourseTakingWeightCategoryCountDocument = gql`
  query findManyCourseTakingWeightCategoryCount(
    $where: CourseTakingWeightCategoryWhereInput
    $orderBy: CourseTakingWeightCategoryOrderByInput
    $after: CourseTakingWeightCategoryWhereUniqueInput
    $before: CourseTakingWeightCategoryWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyCourseTakingWeightCategoryCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyCourseTakingWeightCategoryCountQuery__
 *
 * To run a query within a React component, call `useFindManyCourseTakingWeightCategoryCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyCourseTakingWeightCategoryCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyCourseTakingWeightCategoryCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyCourseTakingWeightCategoryCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyCourseTakingWeightCategoryCountQuery,
    FindManyCourseTakingWeightCategoryCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyCourseTakingWeightCategoryCountQuery,
    FindManyCourseTakingWeightCategoryCountQueryVariables
  >(FindManyCourseTakingWeightCategoryCountDocument, baseOptions);
}
export function useFindManyCourseTakingWeightCategoryCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyCourseTakingWeightCategoryCountQuery,
    FindManyCourseTakingWeightCategoryCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyCourseTakingWeightCategoryCountQuery,
    FindManyCourseTakingWeightCategoryCountQueryVariables
  >(FindManyCourseTakingWeightCategoryCountDocument, baseOptions);
}
export type FindManyCourseTakingWeightCategoryCountQueryHookResult = ReturnType<
  typeof useFindManyCourseTakingWeightCategoryCountQuery
>;
export type FindManyCourseTakingWeightCategoryCountLazyQueryHookResult = ReturnType<
  typeof useFindManyCourseTakingWeightCategoryCountLazyQuery
>;
export type FindManyCourseTakingWeightCategoryCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyCourseTakingWeightCategoryCountQuery,
  FindManyCourseTakingWeightCategoryCountQueryVariables
>;
export const CreateOneCourseTakingWeightCategoryDocument = gql`
  mutation createOneCourseTakingWeightCategory($data: CourseTakingWeightCategoryCreateInput!) {
    createOneCourseTakingWeightCategory(data: $data) {
      ...CourseTakingWeightCategoryFragment
    }
  }
  ${CourseTakingWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useCreateOneCourseTakingWeightCategoryMutation__
 *
 * To run a mutation, you first call `useCreateOneCourseTakingWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneCourseTakingWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneCourseTakingWeightCategoryMutation, { data, loading, error }] = useCreateOneCourseTakingWeightCategoryMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneCourseTakingWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneCourseTakingWeightCategoryMutation,
    CreateOneCourseTakingWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneCourseTakingWeightCategoryMutation,
    CreateOneCourseTakingWeightCategoryMutationVariables
  >(CreateOneCourseTakingWeightCategoryDocument, baseOptions);
}
export type CreateOneCourseTakingWeightCategoryMutationHookResult = ReturnType<
  typeof useCreateOneCourseTakingWeightCategoryMutation
>;
export type CreateOneCourseTakingWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  CreateOneCourseTakingWeightCategoryMutation
>;
export type CreateOneCourseTakingWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneCourseTakingWeightCategoryMutation,
  CreateOneCourseTakingWeightCategoryMutationVariables
>;
export const UpdateOneCourseTakingWeightCategoryDocument = gql`
  mutation updateOneCourseTakingWeightCategory(
    $where: CourseTakingWeightCategoryWhereUniqueInput!
    $data: CourseTakingWeightCategoryUpdateInput!
  ) {
    updateOneCourseTakingWeightCategory(where: $where, data: $data) {
      ...CourseTakingWeightCategoryFragment
    }
  }
  ${CourseTakingWeightCategoryFragmentFragmentDoc}
`;

/**
 * __useUpdateOneCourseTakingWeightCategoryMutation__
 *
 * To run a mutation, you first call `useUpdateOneCourseTakingWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneCourseTakingWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneCourseTakingWeightCategoryMutation, { data, loading, error }] = useUpdateOneCourseTakingWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneCourseTakingWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneCourseTakingWeightCategoryMutation,
    UpdateOneCourseTakingWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneCourseTakingWeightCategoryMutation,
    UpdateOneCourseTakingWeightCategoryMutationVariables
  >(UpdateOneCourseTakingWeightCategoryDocument, baseOptions);
}
export type UpdateOneCourseTakingWeightCategoryMutationHookResult = ReturnType<
  typeof useUpdateOneCourseTakingWeightCategoryMutation
>;
export type UpdateOneCourseTakingWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneCourseTakingWeightCategoryMutation
>;
export type UpdateOneCourseTakingWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneCourseTakingWeightCategoryMutation,
  UpdateOneCourseTakingWeightCategoryMutationVariables
>;
export const DeleteOneCourseTakingWeightCategoryDocument = gql`
  mutation deleteOneCourseTakingWeightCategory($where: CourseTakingWeightCategoryWhereUniqueInput!) {
    deleteOneCourseTakingWeightCategory(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneCourseTakingWeightCategoryMutation__
 *
 * To run a mutation, you first call `useDeleteOneCourseTakingWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneCourseTakingWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneCourseTakingWeightCategoryMutation, { data, loading, error }] = useDeleteOneCourseTakingWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneCourseTakingWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneCourseTakingWeightCategoryMutation,
    DeleteOneCourseTakingWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneCourseTakingWeightCategoryMutation,
    DeleteOneCourseTakingWeightCategoryMutationVariables
  >(DeleteOneCourseTakingWeightCategoryDocument, baseOptions);
}
export type DeleteOneCourseTakingWeightCategoryMutationHookResult = ReturnType<
  typeof useDeleteOneCourseTakingWeightCategoryMutation
>;
export type DeleteOneCourseTakingWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneCourseTakingWeightCategoryMutation
>;
export type DeleteOneCourseTakingWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneCourseTakingWeightCategoryMutation,
  DeleteOneCourseTakingWeightCategoryMutationVariables
>;
export const DeleteManyCourseTakingWeightCategoryDocument = gql`
  mutation deleteManyCourseTakingWeightCategory($where: CourseTakingWeightCategoryWhereInput) {
    deleteManyCourseTakingWeightCategory(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyCourseTakingWeightCategoryMutation__
 *
 * To run a mutation, you first call `useDeleteManyCourseTakingWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyCourseTakingWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyCourseTakingWeightCategoryMutation, { data, loading, error }] = useDeleteManyCourseTakingWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyCourseTakingWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyCourseTakingWeightCategoryMutation,
    DeleteManyCourseTakingWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyCourseTakingWeightCategoryMutation,
    DeleteManyCourseTakingWeightCategoryMutationVariables
  >(DeleteManyCourseTakingWeightCategoryDocument, baseOptions);
}
export type DeleteManyCourseTakingWeightCategoryMutationHookResult = ReturnType<
  typeof useDeleteManyCourseTakingWeightCategoryMutation
>;
export type DeleteManyCourseTakingWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyCourseTakingWeightCategoryMutation
>;
export type DeleteManyCourseTakingWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyCourseTakingWeightCategoryMutation,
  DeleteManyCourseTakingWeightCategoryMutationVariables
>;
export const UpdateManyCourseTakingWeightCategoryDocument = gql`
  mutation updateManyCourseTakingWeightCategory(
    $where: CourseTakingWeightCategoryWhereInput
    $data: CourseTakingWeightCategoryUpdateManyMutationInput!
  ) {
    updateManyCourseTakingWeightCategory(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyCourseTakingWeightCategoryMutation__
 *
 * To run a mutation, you first call `useUpdateManyCourseTakingWeightCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyCourseTakingWeightCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyCourseTakingWeightCategoryMutation, { data, loading, error }] = useUpdateManyCourseTakingWeightCategoryMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyCourseTakingWeightCategoryMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyCourseTakingWeightCategoryMutation,
    UpdateManyCourseTakingWeightCategoryMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyCourseTakingWeightCategoryMutation,
    UpdateManyCourseTakingWeightCategoryMutationVariables
  >(UpdateManyCourseTakingWeightCategoryDocument, baseOptions);
}
export type UpdateManyCourseTakingWeightCategoryMutationHookResult = ReturnType<
  typeof useUpdateManyCourseTakingWeightCategoryMutation
>;
export type UpdateManyCourseTakingWeightCategoryMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyCourseTakingWeightCategoryMutation
>;
export type UpdateManyCourseTakingWeightCategoryMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyCourseTakingWeightCategoryMutation,
  UpdateManyCourseTakingWeightCategoryMutationVariables
>;
export const FindOneEventDocument = gql`
  query findOneEvent($where: EventWhereUniqueInput!) {
    findOneEvent(where: $where) {
      ...EventFragment
    }
  }
  ${EventFragmentFragmentDoc}
`;

/**
 * __useFindOneEventQuery__
 *
 * To run a query within a React component, call `useFindOneEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneEventQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneEventQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneEventQuery, FindOneEventQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneEventQuery, FindOneEventQueryVariables>(FindOneEventDocument, baseOptions);
}
export function useFindOneEventLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneEventQuery, FindOneEventQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneEventQuery, FindOneEventQueryVariables>(
    FindOneEventDocument,
    baseOptions,
  );
}
export type FindOneEventQueryHookResult = ReturnType<typeof useFindOneEventQuery>;
export type FindOneEventLazyQueryHookResult = ReturnType<typeof useFindOneEventLazyQuery>;
export type FindOneEventQueryResult = ApolloReactCommon.QueryResult<FindOneEventQuery, FindOneEventQueryVariables>;
export const FindManyEventDocument = gql`
  query findManyEvent(
    $where: EventWhereInput
    $orderBy: EventOrderByInput
    $after: EventWhereUniqueInput
    $before: EventWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyEvent(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...EventFragment
    }
  }
  ${EventFragmentFragmentDoc}
`;

/**
 * __useFindManyEventQuery__
 *
 * To run a query within a React component, call `useFindManyEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyEventQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyEventQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyEventQuery, FindManyEventQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyEventQuery, FindManyEventQueryVariables>(FindManyEventDocument, baseOptions);
}
export function useFindManyEventLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyEventQuery, FindManyEventQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyEventQuery, FindManyEventQueryVariables>(
    FindManyEventDocument,
    baseOptions,
  );
}
export type FindManyEventQueryHookResult = ReturnType<typeof useFindManyEventQuery>;
export type FindManyEventLazyQueryHookResult = ReturnType<typeof useFindManyEventLazyQuery>;
export type FindManyEventQueryResult = ApolloReactCommon.QueryResult<FindManyEventQuery, FindManyEventQueryVariables>;
export const FindManyEventCountDocument = gql`
  query findManyEventCount(
    $where: EventWhereInput
    $orderBy: EventOrderByInput
    $after: EventWhereUniqueInput
    $before: EventWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyEventCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyEventCountQuery__
 *
 * To run a query within a React component, call `useFindManyEventCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyEventCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyEventCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyEventCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyEventCountQuery, FindManyEventCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyEventCountQuery, FindManyEventCountQueryVariables>(
    FindManyEventCountDocument,
    baseOptions,
  );
}
export function useFindManyEventCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyEventCountQuery, FindManyEventCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyEventCountQuery, FindManyEventCountQueryVariables>(
    FindManyEventCountDocument,
    baseOptions,
  );
}
export type FindManyEventCountQueryHookResult = ReturnType<typeof useFindManyEventCountQuery>;
export type FindManyEventCountLazyQueryHookResult = ReturnType<typeof useFindManyEventCountLazyQuery>;
export type FindManyEventCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyEventCountQuery,
  FindManyEventCountQueryVariables
>;
export const CreateOneEventDocument = gql`
  mutation createOneEvent($data: EventCreateInput!) {
    createOneEvent(data: $data) {
      ...EventFragment
    }
  }
  ${EventFragmentFragmentDoc}
`;

/**
 * __useCreateOneEventMutation__
 *
 * To run a mutation, you first call `useCreateOneEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneEventMutation, { data, loading, error }] = useCreateOneEventMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneEventMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneEventMutation, CreateOneEventMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneEventMutation, CreateOneEventMutationVariables>(
    CreateOneEventDocument,
    baseOptions,
  );
}
export type CreateOneEventMutationHookResult = ReturnType<typeof useCreateOneEventMutation>;
export type CreateOneEventMutationResult = ApolloReactCommon.MutationResult<CreateOneEventMutation>;
export type CreateOneEventMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneEventMutation,
  CreateOneEventMutationVariables
>;
export const UpdateOneEventDocument = gql`
  mutation updateOneEvent($where: EventWhereUniqueInput!, $data: EventUpdateInput!) {
    updateOneEvent(where: $where, data: $data) {
      ...EventFragment
    }
  }
  ${EventFragmentFragmentDoc}
`;

/**
 * __useUpdateOneEventMutation__
 *
 * To run a mutation, you first call `useUpdateOneEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneEventMutation, { data, loading, error }] = useUpdateOneEventMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneEventMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneEventMutation, UpdateOneEventMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneEventMutation, UpdateOneEventMutationVariables>(
    UpdateOneEventDocument,
    baseOptions,
  );
}
export type UpdateOneEventMutationHookResult = ReturnType<typeof useUpdateOneEventMutation>;
export type UpdateOneEventMutationResult = ApolloReactCommon.MutationResult<UpdateOneEventMutation>;
export type UpdateOneEventMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneEventMutation,
  UpdateOneEventMutationVariables
>;
export const DeleteManyEventDocument = gql`
  mutation deleteManyEvent($where: EventWhereInput) {
    deleteManyEvent(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyEventMutation__
 *
 * To run a mutation, you first call `useDeleteManyEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyEventMutation, { data, loading, error }] = useDeleteManyEventMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyEventMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyEventMutation, DeleteManyEventMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyEventMutation, DeleteManyEventMutationVariables>(
    DeleteManyEventDocument,
    baseOptions,
  );
}
export type DeleteManyEventMutationHookResult = ReturnType<typeof useDeleteManyEventMutation>;
export type DeleteManyEventMutationResult = ApolloReactCommon.MutationResult<DeleteManyEventMutation>;
export type DeleteManyEventMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyEventMutation,
  DeleteManyEventMutationVariables
>;
export const UpdateManyEventDocument = gql`
  mutation updateManyEvent($where: EventWhereInput, $data: EventUpdateManyMutationInput!) {
    updateManyEvent(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyEventMutation__
 *
 * To run a mutation, you first call `useUpdateManyEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyEventMutation, { data, loading, error }] = useUpdateManyEventMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyEventMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyEventMutation, UpdateManyEventMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyEventMutation, UpdateManyEventMutationVariables>(
    UpdateManyEventDocument,
    baseOptions,
  );
}
export type UpdateManyEventMutationHookResult = ReturnType<typeof useUpdateManyEventMutation>;
export type UpdateManyEventMutationResult = ApolloReactCommon.MutationResult<UpdateManyEventMutation>;
export type UpdateManyEventMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyEventMutation,
  UpdateManyEventMutationVariables
>;
export const FindOneEventChildrenDocument = gql`
  query findOneEventChildren($where: EventChildrenWhereUniqueInput!) {
    findOneEventChildren(where: $where) {
      ...EventChildrenFragment
    }
  }
  ${EventChildrenFragmentFragmentDoc}
`;

/**
 * __useFindOneEventChildrenQuery__
 *
 * To run a query within a React component, call `useFindOneEventChildrenQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneEventChildrenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneEventChildrenQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneEventChildrenQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneEventChildrenQuery, FindOneEventChildrenQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneEventChildrenQuery, FindOneEventChildrenQueryVariables>(
    FindOneEventChildrenDocument,
    baseOptions,
  );
}
export function useFindOneEventChildrenLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneEventChildrenQuery, FindOneEventChildrenQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneEventChildrenQuery, FindOneEventChildrenQueryVariables>(
    FindOneEventChildrenDocument,
    baseOptions,
  );
}
export type FindOneEventChildrenQueryHookResult = ReturnType<typeof useFindOneEventChildrenQuery>;
export type FindOneEventChildrenLazyQueryHookResult = ReturnType<typeof useFindOneEventChildrenLazyQuery>;
export type FindOneEventChildrenQueryResult = ApolloReactCommon.QueryResult<
  FindOneEventChildrenQuery,
  FindOneEventChildrenQueryVariables
>;
export const FindManyEventChildrenDocument = gql`
  query findManyEventChildren(
    $where: EventChildrenWhereInput
    $orderBy: EventChildrenOrderByInput
    $after: EventChildrenWhereUniqueInput
    $before: EventChildrenWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyEventChildren(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...EventChildrenFragment
    }
  }
  ${EventChildrenFragmentFragmentDoc}
`;

/**
 * __useFindManyEventChildrenQuery__
 *
 * To run a query within a React component, call `useFindManyEventChildrenQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyEventChildrenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyEventChildrenQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyEventChildrenQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyEventChildrenQuery, FindManyEventChildrenQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyEventChildrenQuery, FindManyEventChildrenQueryVariables>(
    FindManyEventChildrenDocument,
    baseOptions,
  );
}
export function useFindManyEventChildrenLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyEventChildrenQuery, FindManyEventChildrenQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyEventChildrenQuery, FindManyEventChildrenQueryVariables>(
    FindManyEventChildrenDocument,
    baseOptions,
  );
}
export type FindManyEventChildrenQueryHookResult = ReturnType<typeof useFindManyEventChildrenQuery>;
export type FindManyEventChildrenLazyQueryHookResult = ReturnType<typeof useFindManyEventChildrenLazyQuery>;
export type FindManyEventChildrenQueryResult = ApolloReactCommon.QueryResult<
  FindManyEventChildrenQuery,
  FindManyEventChildrenQueryVariables
>;
export const FindManyEventChildrenCountDocument = gql`
  query findManyEventChildrenCount(
    $where: EventChildrenWhereInput
    $orderBy: EventChildrenOrderByInput
    $after: EventChildrenWhereUniqueInput
    $before: EventChildrenWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyEventChildrenCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyEventChildrenCountQuery__
 *
 * To run a query within a React component, call `useFindManyEventChildrenCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyEventChildrenCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyEventChildrenCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyEventChildrenCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyEventChildrenCountQuery,
    FindManyEventChildrenCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyEventChildrenCountQuery, FindManyEventChildrenCountQueryVariables>(
    FindManyEventChildrenCountDocument,
    baseOptions,
  );
}
export function useFindManyEventChildrenCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyEventChildrenCountQuery,
    FindManyEventChildrenCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyEventChildrenCountQuery, FindManyEventChildrenCountQueryVariables>(
    FindManyEventChildrenCountDocument,
    baseOptions,
  );
}
export type FindManyEventChildrenCountQueryHookResult = ReturnType<typeof useFindManyEventChildrenCountQuery>;
export type FindManyEventChildrenCountLazyQueryHookResult = ReturnType<typeof useFindManyEventChildrenCountLazyQuery>;
export type FindManyEventChildrenCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyEventChildrenCountQuery,
  FindManyEventChildrenCountQueryVariables
>;
export const CreateOneEventChildrenDocument = gql`
  mutation createOneEventChildren($data: EventChildrenCreateInput!) {
    createOneEventChildren(data: $data) {
      ...EventChildrenFragment
    }
  }
  ${EventChildrenFragmentFragmentDoc}
`;

/**
 * __useCreateOneEventChildrenMutation__
 *
 * To run a mutation, you first call `useCreateOneEventChildrenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneEventChildrenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneEventChildrenMutation, { data, loading, error }] = useCreateOneEventChildrenMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneEventChildrenMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneEventChildrenMutation,
    CreateOneEventChildrenMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneEventChildrenMutation, CreateOneEventChildrenMutationVariables>(
    CreateOneEventChildrenDocument,
    baseOptions,
  );
}
export type CreateOneEventChildrenMutationHookResult = ReturnType<typeof useCreateOneEventChildrenMutation>;
export type CreateOneEventChildrenMutationResult = ApolloReactCommon.MutationResult<CreateOneEventChildrenMutation>;
export type CreateOneEventChildrenMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneEventChildrenMutation,
  CreateOneEventChildrenMutationVariables
>;
export const UpdateOneEventChildrenDocument = gql`
  mutation updateOneEventChildren($where: EventChildrenWhereUniqueInput!, $data: EventChildrenUpdateInput!) {
    updateOneEventChildren(where: $where, data: $data) {
      ...EventChildrenFragment
    }
  }
  ${EventChildrenFragmentFragmentDoc}
`;

/**
 * __useUpdateOneEventChildrenMutation__
 *
 * To run a mutation, you first call `useUpdateOneEventChildrenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneEventChildrenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneEventChildrenMutation, { data, loading, error }] = useUpdateOneEventChildrenMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneEventChildrenMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneEventChildrenMutation,
    UpdateOneEventChildrenMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneEventChildrenMutation, UpdateOneEventChildrenMutationVariables>(
    UpdateOneEventChildrenDocument,
    baseOptions,
  );
}
export type UpdateOneEventChildrenMutationHookResult = ReturnType<typeof useUpdateOneEventChildrenMutation>;
export type UpdateOneEventChildrenMutationResult = ApolloReactCommon.MutationResult<UpdateOneEventChildrenMutation>;
export type UpdateOneEventChildrenMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneEventChildrenMutation,
  UpdateOneEventChildrenMutationVariables
>;
export const DeleteOneEventChildrenDocument = gql`
  mutation deleteOneEventChildren($where: EventChildrenWhereUniqueInput!) {
    deleteOneEventChildren(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneEventChildrenMutation__
 *
 * To run a mutation, you first call `useDeleteOneEventChildrenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneEventChildrenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneEventChildrenMutation, { data, loading, error }] = useDeleteOneEventChildrenMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneEventChildrenMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneEventChildrenMutation,
    DeleteOneEventChildrenMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneEventChildrenMutation, DeleteOneEventChildrenMutationVariables>(
    DeleteOneEventChildrenDocument,
    baseOptions,
  );
}
export type DeleteOneEventChildrenMutationHookResult = ReturnType<typeof useDeleteOneEventChildrenMutation>;
export type DeleteOneEventChildrenMutationResult = ApolloReactCommon.MutationResult<DeleteOneEventChildrenMutation>;
export type DeleteOneEventChildrenMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneEventChildrenMutation,
  DeleteOneEventChildrenMutationVariables
>;
export const DeleteManyEventChildrenDocument = gql`
  mutation deleteManyEventChildren($where: EventChildrenWhereInput) {
    deleteManyEventChildren(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyEventChildrenMutation__
 *
 * To run a mutation, you first call `useDeleteManyEventChildrenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyEventChildrenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyEventChildrenMutation, { data, loading, error }] = useDeleteManyEventChildrenMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyEventChildrenMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyEventChildrenMutation,
    DeleteManyEventChildrenMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyEventChildrenMutation, DeleteManyEventChildrenMutationVariables>(
    DeleteManyEventChildrenDocument,
    baseOptions,
  );
}
export type DeleteManyEventChildrenMutationHookResult = ReturnType<typeof useDeleteManyEventChildrenMutation>;
export type DeleteManyEventChildrenMutationResult = ApolloReactCommon.MutationResult<DeleteManyEventChildrenMutation>;
export type DeleteManyEventChildrenMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyEventChildrenMutation,
  DeleteManyEventChildrenMutationVariables
>;
export const UpdateManyEventChildrenDocument = gql`
  mutation updateManyEventChildren($where: EventChildrenWhereInput, $data: EventChildrenUpdateManyMutationInput!) {
    updateManyEventChildren(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyEventChildrenMutation__
 *
 * To run a mutation, you first call `useUpdateManyEventChildrenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyEventChildrenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyEventChildrenMutation, { data, loading, error }] = useUpdateManyEventChildrenMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyEventChildrenMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyEventChildrenMutation,
    UpdateManyEventChildrenMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyEventChildrenMutation, UpdateManyEventChildrenMutationVariables>(
    UpdateManyEventChildrenDocument,
    baseOptions,
  );
}
export type UpdateManyEventChildrenMutationHookResult = ReturnType<typeof useUpdateManyEventChildrenMutation>;
export type UpdateManyEventChildrenMutationResult = ApolloReactCommon.MutationResult<UpdateManyEventChildrenMutation>;
export type UpdateManyEventChildrenMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyEventChildrenMutation,
  UpdateManyEventChildrenMutationVariables
>;
export const FindOneEventRecurringPatternDocument = gql`
  query findOneEventRecurringPattern($where: EventRecurringPatternWhereUniqueInput!) {
    findOneEventRecurringPattern(where: $where) {
      ...EventRecurringPatternFragment
    }
  }
  ${EventRecurringPatternFragmentFragmentDoc}
`;

/**
 * __useFindOneEventRecurringPatternQuery__
 *
 * To run a query within a React component, call `useFindOneEventRecurringPatternQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneEventRecurringPatternQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneEventRecurringPatternQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneEventRecurringPatternQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneEventRecurringPatternQuery,
    FindOneEventRecurringPatternQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneEventRecurringPatternQuery, FindOneEventRecurringPatternQueryVariables>(
    FindOneEventRecurringPatternDocument,
    baseOptions,
  );
}
export function useFindOneEventRecurringPatternLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneEventRecurringPatternQuery,
    FindOneEventRecurringPatternQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneEventRecurringPatternQuery, FindOneEventRecurringPatternQueryVariables>(
    FindOneEventRecurringPatternDocument,
    baseOptions,
  );
}
export type FindOneEventRecurringPatternQueryHookResult = ReturnType<typeof useFindOneEventRecurringPatternQuery>;
export type FindOneEventRecurringPatternLazyQueryHookResult = ReturnType<
  typeof useFindOneEventRecurringPatternLazyQuery
>;
export type FindOneEventRecurringPatternQueryResult = ApolloReactCommon.QueryResult<
  FindOneEventRecurringPatternQuery,
  FindOneEventRecurringPatternQueryVariables
>;
export const FindManyEventRecurringPatternDocument = gql`
  query findManyEventRecurringPattern(
    $where: EventRecurringPatternWhereInput
    $orderBy: EventRecurringPatternOrderByInput
    $after: EventRecurringPatternWhereUniqueInput
    $before: EventRecurringPatternWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyEventRecurringPattern(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...EventRecurringPatternFragment
    }
  }
  ${EventRecurringPatternFragmentFragmentDoc}
`;

/**
 * __useFindManyEventRecurringPatternQuery__
 *
 * To run a query within a React component, call `useFindManyEventRecurringPatternQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyEventRecurringPatternQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyEventRecurringPatternQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyEventRecurringPatternQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyEventRecurringPatternQuery,
    FindManyEventRecurringPatternQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyEventRecurringPatternQuery, FindManyEventRecurringPatternQueryVariables>(
    FindManyEventRecurringPatternDocument,
    baseOptions,
  );
}
export function useFindManyEventRecurringPatternLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyEventRecurringPatternQuery,
    FindManyEventRecurringPatternQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyEventRecurringPatternQuery, FindManyEventRecurringPatternQueryVariables>(
    FindManyEventRecurringPatternDocument,
    baseOptions,
  );
}
export type FindManyEventRecurringPatternQueryHookResult = ReturnType<typeof useFindManyEventRecurringPatternQuery>;
export type FindManyEventRecurringPatternLazyQueryHookResult = ReturnType<
  typeof useFindManyEventRecurringPatternLazyQuery
>;
export type FindManyEventRecurringPatternQueryResult = ApolloReactCommon.QueryResult<
  FindManyEventRecurringPatternQuery,
  FindManyEventRecurringPatternQueryVariables
>;
export const FindManyEventRecurringPatternCountDocument = gql`
  query findManyEventRecurringPatternCount(
    $where: EventRecurringPatternWhereInput
    $orderBy: EventRecurringPatternOrderByInput
    $after: EventRecurringPatternWhereUniqueInput
    $before: EventRecurringPatternWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyEventRecurringPatternCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyEventRecurringPatternCountQuery__
 *
 * To run a query within a React component, call `useFindManyEventRecurringPatternCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyEventRecurringPatternCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyEventRecurringPatternCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyEventRecurringPatternCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyEventRecurringPatternCountQuery,
    FindManyEventRecurringPatternCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyEventRecurringPatternCountQuery,
    FindManyEventRecurringPatternCountQueryVariables
  >(FindManyEventRecurringPatternCountDocument, baseOptions);
}
export function useFindManyEventRecurringPatternCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyEventRecurringPatternCountQuery,
    FindManyEventRecurringPatternCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyEventRecurringPatternCountQuery,
    FindManyEventRecurringPatternCountQueryVariables
  >(FindManyEventRecurringPatternCountDocument, baseOptions);
}
export type FindManyEventRecurringPatternCountQueryHookResult = ReturnType<
  typeof useFindManyEventRecurringPatternCountQuery
>;
export type FindManyEventRecurringPatternCountLazyQueryHookResult = ReturnType<
  typeof useFindManyEventRecurringPatternCountLazyQuery
>;
export type FindManyEventRecurringPatternCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyEventRecurringPatternCountQuery,
  FindManyEventRecurringPatternCountQueryVariables
>;
export const CreateOneEventRecurringPatternDocument = gql`
  mutation createOneEventRecurringPattern($data: EventRecurringPatternCreateInput!) {
    createOneEventRecurringPattern(data: $data) {
      ...EventRecurringPatternFragment
    }
  }
  ${EventRecurringPatternFragmentFragmentDoc}
`;

/**
 * __useCreateOneEventRecurringPatternMutation__
 *
 * To run a mutation, you first call `useCreateOneEventRecurringPatternMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneEventRecurringPatternMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneEventRecurringPatternMutation, { data, loading, error }] = useCreateOneEventRecurringPatternMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneEventRecurringPatternMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneEventRecurringPatternMutation,
    CreateOneEventRecurringPatternMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneEventRecurringPatternMutation,
    CreateOneEventRecurringPatternMutationVariables
  >(CreateOneEventRecurringPatternDocument, baseOptions);
}
export type CreateOneEventRecurringPatternMutationHookResult = ReturnType<
  typeof useCreateOneEventRecurringPatternMutation
>;
export type CreateOneEventRecurringPatternMutationResult = ApolloReactCommon.MutationResult<
  CreateOneEventRecurringPatternMutation
>;
export type CreateOneEventRecurringPatternMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneEventRecurringPatternMutation,
  CreateOneEventRecurringPatternMutationVariables
>;
export const UpdateOneEventRecurringPatternDocument = gql`
  mutation updateOneEventRecurringPattern(
    $where: EventRecurringPatternWhereUniqueInput!
    $data: EventRecurringPatternUpdateInput!
  ) {
    updateOneEventRecurringPattern(where: $where, data: $data) {
      ...EventRecurringPatternFragment
    }
  }
  ${EventRecurringPatternFragmentFragmentDoc}
`;

/**
 * __useUpdateOneEventRecurringPatternMutation__
 *
 * To run a mutation, you first call `useUpdateOneEventRecurringPatternMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneEventRecurringPatternMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneEventRecurringPatternMutation, { data, loading, error }] = useUpdateOneEventRecurringPatternMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneEventRecurringPatternMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneEventRecurringPatternMutation,
    UpdateOneEventRecurringPatternMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneEventRecurringPatternMutation,
    UpdateOneEventRecurringPatternMutationVariables
  >(UpdateOneEventRecurringPatternDocument, baseOptions);
}
export type UpdateOneEventRecurringPatternMutationHookResult = ReturnType<
  typeof useUpdateOneEventRecurringPatternMutation
>;
export type UpdateOneEventRecurringPatternMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneEventRecurringPatternMutation
>;
export type UpdateOneEventRecurringPatternMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneEventRecurringPatternMutation,
  UpdateOneEventRecurringPatternMutationVariables
>;
export const DeleteOneEventRecurringPatternDocument = gql`
  mutation deleteOneEventRecurringPattern($where: EventRecurringPatternWhereUniqueInput!) {
    deleteOneEventRecurringPattern(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneEventRecurringPatternMutation__
 *
 * To run a mutation, you first call `useDeleteOneEventRecurringPatternMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneEventRecurringPatternMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneEventRecurringPatternMutation, { data, loading, error }] = useDeleteOneEventRecurringPatternMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneEventRecurringPatternMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneEventRecurringPatternMutation,
    DeleteOneEventRecurringPatternMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneEventRecurringPatternMutation,
    DeleteOneEventRecurringPatternMutationVariables
  >(DeleteOneEventRecurringPatternDocument, baseOptions);
}
export type DeleteOneEventRecurringPatternMutationHookResult = ReturnType<
  typeof useDeleteOneEventRecurringPatternMutation
>;
export type DeleteOneEventRecurringPatternMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneEventRecurringPatternMutation
>;
export type DeleteOneEventRecurringPatternMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneEventRecurringPatternMutation,
  DeleteOneEventRecurringPatternMutationVariables
>;
export const DeleteManyEventRecurringPatternDocument = gql`
  mutation deleteManyEventRecurringPattern($where: EventRecurringPatternWhereInput) {
    deleteManyEventRecurringPattern(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyEventRecurringPatternMutation__
 *
 * To run a mutation, you first call `useDeleteManyEventRecurringPatternMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyEventRecurringPatternMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyEventRecurringPatternMutation, { data, loading, error }] = useDeleteManyEventRecurringPatternMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyEventRecurringPatternMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyEventRecurringPatternMutation,
    DeleteManyEventRecurringPatternMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyEventRecurringPatternMutation,
    DeleteManyEventRecurringPatternMutationVariables
  >(DeleteManyEventRecurringPatternDocument, baseOptions);
}
export type DeleteManyEventRecurringPatternMutationHookResult = ReturnType<
  typeof useDeleteManyEventRecurringPatternMutation
>;
export type DeleteManyEventRecurringPatternMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyEventRecurringPatternMutation
>;
export type DeleteManyEventRecurringPatternMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyEventRecurringPatternMutation,
  DeleteManyEventRecurringPatternMutationVariables
>;
export const UpdateManyEventRecurringPatternDocument = gql`
  mutation updateManyEventRecurringPattern(
    $where: EventRecurringPatternWhereInput
    $data: EventRecurringPatternUpdateManyMutationInput!
  ) {
    updateManyEventRecurringPattern(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyEventRecurringPatternMutation__
 *
 * To run a mutation, you first call `useUpdateManyEventRecurringPatternMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyEventRecurringPatternMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyEventRecurringPatternMutation, { data, loading, error }] = useUpdateManyEventRecurringPatternMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyEventRecurringPatternMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyEventRecurringPatternMutation,
    UpdateManyEventRecurringPatternMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyEventRecurringPatternMutation,
    UpdateManyEventRecurringPatternMutationVariables
  >(UpdateManyEventRecurringPatternDocument, baseOptions);
}
export type UpdateManyEventRecurringPatternMutationHookResult = ReturnType<
  typeof useUpdateManyEventRecurringPatternMutation
>;
export type UpdateManyEventRecurringPatternMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyEventRecurringPatternMutation
>;
export type UpdateManyEventRecurringPatternMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyEventRecurringPatternMutation,
  UpdateManyEventRecurringPatternMutationVariables
>;
export const FindOneFaqDocument = gql`
  query findOneFaq($where: FaqWhereUniqueInput!) {
    findOneFaq(where: $where) {
      ...FaqFragment
    }
  }
  ${FaqFragmentFragmentDoc}
`;

/**
 * __useFindOneFaqQuery__
 *
 * To run a query within a React component, call `useFindOneFaqQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneFaqQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneFaqQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneFaqQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneFaqQuery, FindOneFaqQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneFaqQuery, FindOneFaqQueryVariables>(FindOneFaqDocument, baseOptions);
}
export function useFindOneFaqLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneFaqQuery, FindOneFaqQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneFaqQuery, FindOneFaqQueryVariables>(FindOneFaqDocument, baseOptions);
}
export type FindOneFaqQueryHookResult = ReturnType<typeof useFindOneFaqQuery>;
export type FindOneFaqLazyQueryHookResult = ReturnType<typeof useFindOneFaqLazyQuery>;
export type FindOneFaqQueryResult = ApolloReactCommon.QueryResult<FindOneFaqQuery, FindOneFaqQueryVariables>;
export const FindManyFaqDocument = gql`
  query findManyFaq(
    $where: FaqWhereInput
    $orderBy: FaqOrderByInput
    $after: FaqWhereUniqueInput
    $before: FaqWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyFaq(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...FaqFragment
    }
  }
  ${FaqFragmentFragmentDoc}
`;

/**
 * __useFindManyFaqQuery__
 *
 * To run a query within a React component, call `useFindManyFaqQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyFaqQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyFaqQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyFaqQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyFaqQuery, FindManyFaqQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyFaqQuery, FindManyFaqQueryVariables>(FindManyFaqDocument, baseOptions);
}
export function useFindManyFaqLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyFaqQuery, FindManyFaqQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyFaqQuery, FindManyFaqQueryVariables>(FindManyFaqDocument, baseOptions);
}
export type FindManyFaqQueryHookResult = ReturnType<typeof useFindManyFaqQuery>;
export type FindManyFaqLazyQueryHookResult = ReturnType<typeof useFindManyFaqLazyQuery>;
export type FindManyFaqQueryResult = ApolloReactCommon.QueryResult<FindManyFaqQuery, FindManyFaqQueryVariables>;
export const FindManyFaqCountDocument = gql`
  query findManyFaqCount(
    $where: FaqWhereInput
    $orderBy: FaqOrderByInput
    $after: FaqWhereUniqueInput
    $before: FaqWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyFaqCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyFaqCountQuery__
 *
 * To run a query within a React component, call `useFindManyFaqCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyFaqCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyFaqCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyFaqCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyFaqCountQuery, FindManyFaqCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyFaqCountQuery, FindManyFaqCountQueryVariables>(
    FindManyFaqCountDocument,
    baseOptions,
  );
}
export function useFindManyFaqCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyFaqCountQuery, FindManyFaqCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyFaqCountQuery, FindManyFaqCountQueryVariables>(
    FindManyFaqCountDocument,
    baseOptions,
  );
}
export type FindManyFaqCountQueryHookResult = ReturnType<typeof useFindManyFaqCountQuery>;
export type FindManyFaqCountLazyQueryHookResult = ReturnType<typeof useFindManyFaqCountLazyQuery>;
export type FindManyFaqCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyFaqCountQuery,
  FindManyFaqCountQueryVariables
>;
export const CreateOneFaqDocument = gql`
  mutation createOneFaq($data: FaqCreateInput!) {
    createOneFaq(data: $data) {
      ...FaqFragment
    }
  }
  ${FaqFragmentFragmentDoc}
`;

/**
 * __useCreateOneFaqMutation__
 *
 * To run a mutation, you first call `useCreateOneFaqMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneFaqMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneFaqMutation, { data, loading, error }] = useCreateOneFaqMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneFaqMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneFaqMutation, CreateOneFaqMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneFaqMutation, CreateOneFaqMutationVariables>(
    CreateOneFaqDocument,
    baseOptions,
  );
}
export type CreateOneFaqMutationHookResult = ReturnType<typeof useCreateOneFaqMutation>;
export type CreateOneFaqMutationResult = ApolloReactCommon.MutationResult<CreateOneFaqMutation>;
export type CreateOneFaqMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneFaqMutation,
  CreateOneFaqMutationVariables
>;
export const UpdateOneFaqDocument = gql`
  mutation updateOneFaq($where: FaqWhereUniqueInput!, $data: FaqUpdateInput!) {
    updateOneFaq(where: $where, data: $data) {
      ...FaqFragment
    }
  }
  ${FaqFragmentFragmentDoc}
`;

/**
 * __useUpdateOneFaqMutation__
 *
 * To run a mutation, you first call `useUpdateOneFaqMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneFaqMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneFaqMutation, { data, loading, error }] = useUpdateOneFaqMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneFaqMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneFaqMutation, UpdateOneFaqMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneFaqMutation, UpdateOneFaqMutationVariables>(
    UpdateOneFaqDocument,
    baseOptions,
  );
}
export type UpdateOneFaqMutationHookResult = ReturnType<typeof useUpdateOneFaqMutation>;
export type UpdateOneFaqMutationResult = ApolloReactCommon.MutationResult<UpdateOneFaqMutation>;
export type UpdateOneFaqMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneFaqMutation,
  UpdateOneFaqMutationVariables
>;
export const DeleteOneFaqDocument = gql`
  mutation deleteOneFaq($where: FaqWhereUniqueInput!) {
    deleteOneFaq(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneFaqMutation__
 *
 * To run a mutation, you first call `useDeleteOneFaqMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneFaqMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneFaqMutation, { data, loading, error }] = useDeleteOneFaqMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneFaqMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneFaqMutation, DeleteOneFaqMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneFaqMutation, DeleteOneFaqMutationVariables>(
    DeleteOneFaqDocument,
    baseOptions,
  );
}
export type DeleteOneFaqMutationHookResult = ReturnType<typeof useDeleteOneFaqMutation>;
export type DeleteOneFaqMutationResult = ApolloReactCommon.MutationResult<DeleteOneFaqMutation>;
export type DeleteOneFaqMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneFaqMutation,
  DeleteOneFaqMutationVariables
>;
export const DeleteManyFaqDocument = gql`
  mutation deleteManyFaq($where: FaqWhereInput) {
    deleteManyFaq(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyFaqMutation__
 *
 * To run a mutation, you first call `useDeleteManyFaqMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyFaqMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyFaqMutation, { data, loading, error }] = useDeleteManyFaqMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyFaqMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyFaqMutation, DeleteManyFaqMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyFaqMutation, DeleteManyFaqMutationVariables>(
    DeleteManyFaqDocument,
    baseOptions,
  );
}
export type DeleteManyFaqMutationHookResult = ReturnType<typeof useDeleteManyFaqMutation>;
export type DeleteManyFaqMutationResult = ApolloReactCommon.MutationResult<DeleteManyFaqMutation>;
export type DeleteManyFaqMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyFaqMutation,
  DeleteManyFaqMutationVariables
>;
export const UpdateManyFaqDocument = gql`
  mutation updateManyFaq($where: FaqWhereInput, $data: FaqUpdateManyMutationInput!) {
    updateManyFaq(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyFaqMutation__
 *
 * To run a mutation, you first call `useUpdateManyFaqMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyFaqMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyFaqMutation, { data, loading, error }] = useUpdateManyFaqMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyFaqMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyFaqMutation, UpdateManyFaqMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyFaqMutation, UpdateManyFaqMutationVariables>(
    UpdateManyFaqDocument,
    baseOptions,
  );
}
export type UpdateManyFaqMutationHookResult = ReturnType<typeof useUpdateManyFaqMutation>;
export type UpdateManyFaqMutationResult = ApolloReactCommon.MutationResult<UpdateManyFaqMutation>;
export type UpdateManyFaqMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyFaqMutation,
  UpdateManyFaqMutationVariables
>;
export const FindOneFaqTagDocument = gql`
  query findOneFaqTag($where: FaqTagWhereUniqueInput!) {
    findOneFaqTag(where: $where) {
      ...FaqTagFragment
    }
  }
  ${FaqTagFragmentFragmentDoc}
`;

/**
 * __useFindOneFaqTagQuery__
 *
 * To run a query within a React component, call `useFindOneFaqTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneFaqTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneFaqTagQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneFaqTagQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneFaqTagQuery, FindOneFaqTagQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneFaqTagQuery, FindOneFaqTagQueryVariables>(FindOneFaqTagDocument, baseOptions);
}
export function useFindOneFaqTagLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneFaqTagQuery, FindOneFaqTagQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneFaqTagQuery, FindOneFaqTagQueryVariables>(
    FindOneFaqTagDocument,
    baseOptions,
  );
}
export type FindOneFaqTagQueryHookResult = ReturnType<typeof useFindOneFaqTagQuery>;
export type FindOneFaqTagLazyQueryHookResult = ReturnType<typeof useFindOneFaqTagLazyQuery>;
export type FindOneFaqTagQueryResult = ApolloReactCommon.QueryResult<FindOneFaqTagQuery, FindOneFaqTagQueryVariables>;
export const FindManyFaqTagDocument = gql`
  query findManyFaqTag(
    $where: FaqTagWhereInput
    $orderBy: FaqTagOrderByInput
    $after: FaqTagWhereUniqueInput
    $before: FaqTagWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyFaqTag(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...FaqTagFragment
    }
  }
  ${FaqTagFragmentFragmentDoc}
`;

/**
 * __useFindManyFaqTagQuery__
 *
 * To run a query within a React component, call `useFindManyFaqTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyFaqTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyFaqTagQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyFaqTagQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyFaqTagQuery, FindManyFaqTagQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyFaqTagQuery, FindManyFaqTagQueryVariables>(
    FindManyFaqTagDocument,
    baseOptions,
  );
}
export function useFindManyFaqTagLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyFaqTagQuery, FindManyFaqTagQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyFaqTagQuery, FindManyFaqTagQueryVariables>(
    FindManyFaqTagDocument,
    baseOptions,
  );
}
export type FindManyFaqTagQueryHookResult = ReturnType<typeof useFindManyFaqTagQuery>;
export type FindManyFaqTagLazyQueryHookResult = ReturnType<typeof useFindManyFaqTagLazyQuery>;
export type FindManyFaqTagQueryResult = ApolloReactCommon.QueryResult<
  FindManyFaqTagQuery,
  FindManyFaqTagQueryVariables
>;
export const FindManyFaqTagCountDocument = gql`
  query findManyFaqTagCount(
    $where: FaqTagWhereInput
    $orderBy: FaqTagOrderByInput
    $after: FaqTagWhereUniqueInput
    $before: FaqTagWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyFaqTagCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyFaqTagCountQuery__
 *
 * To run a query within a React component, call `useFindManyFaqTagCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyFaqTagCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyFaqTagCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyFaqTagCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyFaqTagCountQuery, FindManyFaqTagCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyFaqTagCountQuery, FindManyFaqTagCountQueryVariables>(
    FindManyFaqTagCountDocument,
    baseOptions,
  );
}
export function useFindManyFaqTagCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyFaqTagCountQuery, FindManyFaqTagCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyFaqTagCountQuery, FindManyFaqTagCountQueryVariables>(
    FindManyFaqTagCountDocument,
    baseOptions,
  );
}
export type FindManyFaqTagCountQueryHookResult = ReturnType<typeof useFindManyFaqTagCountQuery>;
export type FindManyFaqTagCountLazyQueryHookResult = ReturnType<typeof useFindManyFaqTagCountLazyQuery>;
export type FindManyFaqTagCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyFaqTagCountQuery,
  FindManyFaqTagCountQueryVariables
>;
export const CreateOneFaqTagDocument = gql`
  mutation createOneFaqTag($data: FaqTagCreateInput!) {
    createOneFaqTag(data: $data) {
      ...FaqTagFragment
    }
  }
  ${FaqTagFragmentFragmentDoc}
`;

/**
 * __useCreateOneFaqTagMutation__
 *
 * To run a mutation, you first call `useCreateOneFaqTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneFaqTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneFaqTagMutation, { data, loading, error }] = useCreateOneFaqTagMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneFaqTagMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneFaqTagMutation, CreateOneFaqTagMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneFaqTagMutation, CreateOneFaqTagMutationVariables>(
    CreateOneFaqTagDocument,
    baseOptions,
  );
}
export type CreateOneFaqTagMutationHookResult = ReturnType<typeof useCreateOneFaqTagMutation>;
export type CreateOneFaqTagMutationResult = ApolloReactCommon.MutationResult<CreateOneFaqTagMutation>;
export type CreateOneFaqTagMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneFaqTagMutation,
  CreateOneFaqTagMutationVariables
>;
export const UpdateOneFaqTagDocument = gql`
  mutation updateOneFaqTag($where: FaqTagWhereUniqueInput!, $data: FaqTagUpdateInput!) {
    updateOneFaqTag(where: $where, data: $data) {
      ...FaqTagFragment
    }
  }
  ${FaqTagFragmentFragmentDoc}
`;

/**
 * __useUpdateOneFaqTagMutation__
 *
 * To run a mutation, you first call `useUpdateOneFaqTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneFaqTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneFaqTagMutation, { data, loading, error }] = useUpdateOneFaqTagMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneFaqTagMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneFaqTagMutation, UpdateOneFaqTagMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneFaqTagMutation, UpdateOneFaqTagMutationVariables>(
    UpdateOneFaqTagDocument,
    baseOptions,
  );
}
export type UpdateOneFaqTagMutationHookResult = ReturnType<typeof useUpdateOneFaqTagMutation>;
export type UpdateOneFaqTagMutationResult = ApolloReactCommon.MutationResult<UpdateOneFaqTagMutation>;
export type UpdateOneFaqTagMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneFaqTagMutation,
  UpdateOneFaqTagMutationVariables
>;
export const DeleteOneFaqTagDocument = gql`
  mutation deleteOneFaqTag($where: FaqTagWhereUniqueInput!) {
    deleteOneFaqTag(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneFaqTagMutation__
 *
 * To run a mutation, you first call `useDeleteOneFaqTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneFaqTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneFaqTagMutation, { data, loading, error }] = useDeleteOneFaqTagMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneFaqTagMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneFaqTagMutation, DeleteOneFaqTagMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneFaqTagMutation, DeleteOneFaqTagMutationVariables>(
    DeleteOneFaqTagDocument,
    baseOptions,
  );
}
export type DeleteOneFaqTagMutationHookResult = ReturnType<typeof useDeleteOneFaqTagMutation>;
export type DeleteOneFaqTagMutationResult = ApolloReactCommon.MutationResult<DeleteOneFaqTagMutation>;
export type DeleteOneFaqTagMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneFaqTagMutation,
  DeleteOneFaqTagMutationVariables
>;
export const DeleteManyFaqTagDocument = gql`
  mutation deleteManyFaqTag($where: FaqTagWhereInput) {
    deleteManyFaqTag(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyFaqTagMutation__
 *
 * To run a mutation, you first call `useDeleteManyFaqTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyFaqTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyFaqTagMutation, { data, loading, error }] = useDeleteManyFaqTagMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyFaqTagMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyFaqTagMutation, DeleteManyFaqTagMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyFaqTagMutation, DeleteManyFaqTagMutationVariables>(
    DeleteManyFaqTagDocument,
    baseOptions,
  );
}
export type DeleteManyFaqTagMutationHookResult = ReturnType<typeof useDeleteManyFaqTagMutation>;
export type DeleteManyFaqTagMutationResult = ApolloReactCommon.MutationResult<DeleteManyFaqTagMutation>;
export type DeleteManyFaqTagMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyFaqTagMutation,
  DeleteManyFaqTagMutationVariables
>;
export const UpdateManyFaqTagDocument = gql`
  mutation updateManyFaqTag($where: FaqTagWhereInput, $data: FaqTagUpdateManyMutationInput!) {
    updateManyFaqTag(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyFaqTagMutation__
 *
 * To run a mutation, you first call `useUpdateManyFaqTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyFaqTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyFaqTagMutation, { data, loading, error }] = useUpdateManyFaqTagMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyFaqTagMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyFaqTagMutation, UpdateManyFaqTagMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyFaqTagMutation, UpdateManyFaqTagMutationVariables>(
    UpdateManyFaqTagDocument,
    baseOptions,
  );
}
export type UpdateManyFaqTagMutationHookResult = ReturnType<typeof useUpdateManyFaqTagMutation>;
export type UpdateManyFaqTagMutationResult = ApolloReactCommon.MutationResult<UpdateManyFaqTagMutation>;
export type UpdateManyFaqTagMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyFaqTagMutation,
  UpdateManyFaqTagMutationVariables
>;
export const FindOneGradeDocument = gql`
  query findOneGrade($where: GradeWhereUniqueInput!) {
    findOneGrade(where: $where) {
      ...GradeFragment
    }
  }
  ${GradeFragmentFragmentDoc}
`;

/**
 * __useFindOneGradeQuery__
 *
 * To run a query within a React component, call `useFindOneGradeQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneGradeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneGradeQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneGradeQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneGradeQuery, FindOneGradeQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneGradeQuery, FindOneGradeQueryVariables>(FindOneGradeDocument, baseOptions);
}
export function useFindOneGradeLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneGradeQuery, FindOneGradeQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneGradeQuery, FindOneGradeQueryVariables>(
    FindOneGradeDocument,
    baseOptions,
  );
}
export type FindOneGradeQueryHookResult = ReturnType<typeof useFindOneGradeQuery>;
export type FindOneGradeLazyQueryHookResult = ReturnType<typeof useFindOneGradeLazyQuery>;
export type FindOneGradeQueryResult = ApolloReactCommon.QueryResult<FindOneGradeQuery, FindOneGradeQueryVariables>;
export const FindManyGradeDocument = gql`
  query findManyGrade(
    $where: GradeWhereInput
    $orderBy: GradeOrderByInput
    $after: GradeWhereUniqueInput
    $before: GradeWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyGrade(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...GradeFragment
    }
  }
  ${GradeFragmentFragmentDoc}
`;

/**
 * __useFindManyGradeQuery__
 *
 * To run a query within a React component, call `useFindManyGradeQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyGradeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyGradeQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyGradeQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyGradeQuery, FindManyGradeQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyGradeQuery, FindManyGradeQueryVariables>(FindManyGradeDocument, baseOptions);
}
export function useFindManyGradeLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyGradeQuery, FindManyGradeQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyGradeQuery, FindManyGradeQueryVariables>(
    FindManyGradeDocument,
    baseOptions,
  );
}
export type FindManyGradeQueryHookResult = ReturnType<typeof useFindManyGradeQuery>;
export type FindManyGradeLazyQueryHookResult = ReturnType<typeof useFindManyGradeLazyQuery>;
export type FindManyGradeQueryResult = ApolloReactCommon.QueryResult<FindManyGradeQuery, FindManyGradeQueryVariables>;
export const FindManyGradeCountDocument = gql`
  query findManyGradeCount(
    $where: GradeWhereInput
    $orderBy: GradeOrderByInput
    $after: GradeWhereUniqueInput
    $before: GradeWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyGradeCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyGradeCountQuery__
 *
 * To run a query within a React component, call `useFindManyGradeCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyGradeCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyGradeCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyGradeCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyGradeCountQuery, FindManyGradeCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyGradeCountQuery, FindManyGradeCountQueryVariables>(
    FindManyGradeCountDocument,
    baseOptions,
  );
}
export function useFindManyGradeCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyGradeCountQuery, FindManyGradeCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyGradeCountQuery, FindManyGradeCountQueryVariables>(
    FindManyGradeCountDocument,
    baseOptions,
  );
}
export type FindManyGradeCountQueryHookResult = ReturnType<typeof useFindManyGradeCountQuery>;
export type FindManyGradeCountLazyQueryHookResult = ReturnType<typeof useFindManyGradeCountLazyQuery>;
export type FindManyGradeCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyGradeCountQuery,
  FindManyGradeCountQueryVariables
>;
export const CreateOneGradeDocument = gql`
  mutation createOneGrade($data: GradeCreateInput!) {
    createOneGrade(data: $data) {
      ...GradeFragment
    }
  }
  ${GradeFragmentFragmentDoc}
`;

/**
 * __useCreateOneGradeMutation__
 *
 * To run a mutation, you first call `useCreateOneGradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneGradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneGradeMutation, { data, loading, error }] = useCreateOneGradeMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneGradeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneGradeMutation, CreateOneGradeMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneGradeMutation, CreateOneGradeMutationVariables>(
    CreateOneGradeDocument,
    baseOptions,
  );
}
export type CreateOneGradeMutationHookResult = ReturnType<typeof useCreateOneGradeMutation>;
export type CreateOneGradeMutationResult = ApolloReactCommon.MutationResult<CreateOneGradeMutation>;
export type CreateOneGradeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneGradeMutation,
  CreateOneGradeMutationVariables
>;
export const UpdateOneGradeDocument = gql`
  mutation updateOneGrade($where: GradeWhereUniqueInput!, $data: GradeUpdateInput!) {
    updateOneGrade(where: $where, data: $data) {
      ...GradeFragment
    }
  }
  ${GradeFragmentFragmentDoc}
`;

/**
 * __useUpdateOneGradeMutation__
 *
 * To run a mutation, you first call `useUpdateOneGradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneGradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneGradeMutation, { data, loading, error }] = useUpdateOneGradeMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneGradeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneGradeMutation, UpdateOneGradeMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneGradeMutation, UpdateOneGradeMutationVariables>(
    UpdateOneGradeDocument,
    baseOptions,
  );
}
export type UpdateOneGradeMutationHookResult = ReturnType<typeof useUpdateOneGradeMutation>;
export type UpdateOneGradeMutationResult = ApolloReactCommon.MutationResult<UpdateOneGradeMutation>;
export type UpdateOneGradeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneGradeMutation,
  UpdateOneGradeMutationVariables
>;
export const DeleteOneGradeDocument = gql`
  mutation deleteOneGrade($where: GradeWhereUniqueInput!) {
    deleteOneGrade(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneGradeMutation__
 *
 * To run a mutation, you first call `useDeleteOneGradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneGradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneGradeMutation, { data, loading, error }] = useDeleteOneGradeMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneGradeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneGradeMutation, DeleteOneGradeMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneGradeMutation, DeleteOneGradeMutationVariables>(
    DeleteOneGradeDocument,
    baseOptions,
  );
}
export type DeleteOneGradeMutationHookResult = ReturnType<typeof useDeleteOneGradeMutation>;
export type DeleteOneGradeMutationResult = ApolloReactCommon.MutationResult<DeleteOneGradeMutation>;
export type DeleteOneGradeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneGradeMutation,
  DeleteOneGradeMutationVariables
>;
export const DeleteManyGradeDocument = gql`
  mutation deleteManyGrade($where: GradeWhereInput) {
    deleteManyGrade(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyGradeMutation__
 *
 * To run a mutation, you first call `useDeleteManyGradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyGradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyGradeMutation, { data, loading, error }] = useDeleteManyGradeMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyGradeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyGradeMutation, DeleteManyGradeMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyGradeMutation, DeleteManyGradeMutationVariables>(
    DeleteManyGradeDocument,
    baseOptions,
  );
}
export type DeleteManyGradeMutationHookResult = ReturnType<typeof useDeleteManyGradeMutation>;
export type DeleteManyGradeMutationResult = ApolloReactCommon.MutationResult<DeleteManyGradeMutation>;
export type DeleteManyGradeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyGradeMutation,
  DeleteManyGradeMutationVariables
>;
export const UpdateManyGradeDocument = gql`
  mutation updateManyGrade($where: GradeWhereInput, $data: GradeUpdateManyMutationInput!) {
    updateManyGrade(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyGradeMutation__
 *
 * To run a mutation, you first call `useUpdateManyGradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyGradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyGradeMutation, { data, loading, error }] = useUpdateManyGradeMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyGradeMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyGradeMutation, UpdateManyGradeMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyGradeMutation, UpdateManyGradeMutationVariables>(
    UpdateManyGradeDocument,
    baseOptions,
  );
}
export type UpdateManyGradeMutationHookResult = ReturnType<typeof useUpdateManyGradeMutation>;
export type UpdateManyGradeMutationResult = ApolloReactCommon.MutationResult<UpdateManyGradeMutation>;
export type UpdateManyGradeMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyGradeMutation,
  UpdateManyGradeMutationVariables
>;
export const FindOneHubAccountDocument = gql`
  query findOneHubAccount($where: HubAccountWhereUniqueInput!) {
    findOneHubAccount(where: $where) {
      ...HubAccountFragment
    }
  }
  ${HubAccountFragmentFragmentDoc}
`;

/**
 * __useFindOneHubAccountQuery__
 *
 * To run a query within a React component, call `useFindOneHubAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneHubAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneHubAccountQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneHubAccountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneHubAccountQuery, FindOneHubAccountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneHubAccountQuery, FindOneHubAccountQueryVariables>(
    FindOneHubAccountDocument,
    baseOptions,
  );
}
export function useFindOneHubAccountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneHubAccountQuery, FindOneHubAccountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneHubAccountQuery, FindOneHubAccountQueryVariables>(
    FindOneHubAccountDocument,
    baseOptions,
  );
}
export type FindOneHubAccountQueryHookResult = ReturnType<typeof useFindOneHubAccountQuery>;
export type FindOneHubAccountLazyQueryHookResult = ReturnType<typeof useFindOneHubAccountLazyQuery>;
export type FindOneHubAccountQueryResult = ApolloReactCommon.QueryResult<
  FindOneHubAccountQuery,
  FindOneHubAccountQueryVariables
>;
export const FindManyHubAccountDocument = gql`
  query findManyHubAccount(
    $where: HubAccountWhereInput
    $orderBy: HubAccountOrderByInput
    $after: HubAccountWhereUniqueInput
    $before: HubAccountWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyHubAccount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...HubAccountFragment
    }
  }
  ${HubAccountFragmentFragmentDoc}
`;

/**
 * __useFindManyHubAccountQuery__
 *
 * To run a query within a React component, call `useFindManyHubAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyHubAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyHubAccountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyHubAccountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyHubAccountQuery, FindManyHubAccountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyHubAccountQuery, FindManyHubAccountQueryVariables>(
    FindManyHubAccountDocument,
    baseOptions,
  );
}
export function useFindManyHubAccountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyHubAccountQuery, FindManyHubAccountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyHubAccountQuery, FindManyHubAccountQueryVariables>(
    FindManyHubAccountDocument,
    baseOptions,
  );
}
export type FindManyHubAccountQueryHookResult = ReturnType<typeof useFindManyHubAccountQuery>;
export type FindManyHubAccountLazyQueryHookResult = ReturnType<typeof useFindManyHubAccountLazyQuery>;
export type FindManyHubAccountQueryResult = ApolloReactCommon.QueryResult<
  FindManyHubAccountQuery,
  FindManyHubAccountQueryVariables
>;
export const FindManyHubAccountCountDocument = gql`
  query findManyHubAccountCount(
    $where: HubAccountWhereInput
    $orderBy: HubAccountOrderByInput
    $after: HubAccountWhereUniqueInput
    $before: HubAccountWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyHubAccountCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyHubAccountCountQuery__
 *
 * To run a query within a React component, call `useFindManyHubAccountCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyHubAccountCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyHubAccountCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyHubAccountCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyHubAccountCountQuery, FindManyHubAccountCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyHubAccountCountQuery, FindManyHubAccountCountQueryVariables>(
    FindManyHubAccountCountDocument,
    baseOptions,
  );
}
export function useFindManyHubAccountCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyHubAccountCountQuery,
    FindManyHubAccountCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyHubAccountCountQuery, FindManyHubAccountCountQueryVariables>(
    FindManyHubAccountCountDocument,
    baseOptions,
  );
}
export type FindManyHubAccountCountQueryHookResult = ReturnType<typeof useFindManyHubAccountCountQuery>;
export type FindManyHubAccountCountLazyQueryHookResult = ReturnType<typeof useFindManyHubAccountCountLazyQuery>;
export type FindManyHubAccountCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyHubAccountCountQuery,
  FindManyHubAccountCountQueryVariables
>;
export const CreateOneHubAccountDocument = gql`
  mutation createOneHubAccount($data: HubAccountCreateInput!) {
    createOneHubAccount(data: $data) {
      ...HubAccountFragment
    }
  }
  ${HubAccountFragmentFragmentDoc}
`;

/**
 * __useCreateOneHubAccountMutation__
 *
 * To run a mutation, you first call `useCreateOneHubAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneHubAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneHubAccountMutation, { data, loading, error }] = useCreateOneHubAccountMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneHubAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneHubAccountMutation, CreateOneHubAccountMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneHubAccountMutation, CreateOneHubAccountMutationVariables>(
    CreateOneHubAccountDocument,
    baseOptions,
  );
}
export type CreateOneHubAccountMutationHookResult = ReturnType<typeof useCreateOneHubAccountMutation>;
export type CreateOneHubAccountMutationResult = ApolloReactCommon.MutationResult<CreateOneHubAccountMutation>;
export type CreateOneHubAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneHubAccountMutation,
  CreateOneHubAccountMutationVariables
>;
export const UpdateOneHubAccountDocument = gql`
  mutation updateOneHubAccount($where: HubAccountWhereUniqueInput!, $data: HubAccountUpdateInput!) {
    updateOneHubAccount(where: $where, data: $data) {
      ...HubAccountFragment
    }
  }
  ${HubAccountFragmentFragmentDoc}
`;

/**
 * __useUpdateOneHubAccountMutation__
 *
 * To run a mutation, you first call `useUpdateOneHubAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneHubAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneHubAccountMutation, { data, loading, error }] = useUpdateOneHubAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneHubAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneHubAccountMutation, UpdateOneHubAccountMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneHubAccountMutation, UpdateOneHubAccountMutationVariables>(
    UpdateOneHubAccountDocument,
    baseOptions,
  );
}
export type UpdateOneHubAccountMutationHookResult = ReturnType<typeof useUpdateOneHubAccountMutation>;
export type UpdateOneHubAccountMutationResult = ApolloReactCommon.MutationResult<UpdateOneHubAccountMutation>;
export type UpdateOneHubAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneHubAccountMutation,
  UpdateOneHubAccountMutationVariables
>;
export const DeleteOneHubAccountDocument = gql`
  mutation deleteOneHubAccount($where: HubAccountWhereUniqueInput!) {
    deleteOneHubAccount(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneHubAccountMutation__
 *
 * To run a mutation, you first call `useDeleteOneHubAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneHubAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneHubAccountMutation, { data, loading, error }] = useDeleteOneHubAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneHubAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneHubAccountMutation, DeleteOneHubAccountMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneHubAccountMutation, DeleteOneHubAccountMutationVariables>(
    DeleteOneHubAccountDocument,
    baseOptions,
  );
}
export type DeleteOneHubAccountMutationHookResult = ReturnType<typeof useDeleteOneHubAccountMutation>;
export type DeleteOneHubAccountMutationResult = ApolloReactCommon.MutationResult<DeleteOneHubAccountMutation>;
export type DeleteOneHubAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneHubAccountMutation,
  DeleteOneHubAccountMutationVariables
>;
export const DeleteManyHubAccountDocument = gql`
  mutation deleteManyHubAccount($where: HubAccountWhereInput) {
    deleteManyHubAccount(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyHubAccountMutation__
 *
 * To run a mutation, you first call `useDeleteManyHubAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyHubAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyHubAccountMutation, { data, loading, error }] = useDeleteManyHubAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyHubAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyHubAccountMutation,
    DeleteManyHubAccountMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyHubAccountMutation, DeleteManyHubAccountMutationVariables>(
    DeleteManyHubAccountDocument,
    baseOptions,
  );
}
export type DeleteManyHubAccountMutationHookResult = ReturnType<typeof useDeleteManyHubAccountMutation>;
export type DeleteManyHubAccountMutationResult = ApolloReactCommon.MutationResult<DeleteManyHubAccountMutation>;
export type DeleteManyHubAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyHubAccountMutation,
  DeleteManyHubAccountMutationVariables
>;
export const UpdateManyHubAccountDocument = gql`
  mutation updateManyHubAccount($where: HubAccountWhereInput, $data: HubAccountUpdateManyMutationInput!) {
    updateManyHubAccount(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyHubAccountMutation__
 *
 * To run a mutation, you first call `useUpdateManyHubAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyHubAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyHubAccountMutation, { data, loading, error }] = useUpdateManyHubAccountMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyHubAccountMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyHubAccountMutation,
    UpdateManyHubAccountMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyHubAccountMutation, UpdateManyHubAccountMutationVariables>(
    UpdateManyHubAccountDocument,
    baseOptions,
  );
}
export type UpdateManyHubAccountMutationHookResult = ReturnType<typeof useUpdateManyHubAccountMutation>;
export type UpdateManyHubAccountMutationResult = ApolloReactCommon.MutationResult<UpdateManyHubAccountMutation>;
export type UpdateManyHubAccountMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyHubAccountMutation,
  UpdateManyHubAccountMutationVariables
>;
export const FindOneHubEntitlementDocument = gql`
  query findOneHubEntitlement($where: HubEntitlementWhereUniqueInput!) {
    findOneHubEntitlement(where: $where) {
      ...HubEntitlementFragment
    }
  }
  ${HubEntitlementFragmentFragmentDoc}
`;

/**
 * __useFindOneHubEntitlementQuery__
 *
 * To run a query within a React component, call `useFindOneHubEntitlementQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneHubEntitlementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneHubEntitlementQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneHubEntitlementQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneHubEntitlementQuery, FindOneHubEntitlementQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneHubEntitlementQuery, FindOneHubEntitlementQueryVariables>(
    FindOneHubEntitlementDocument,
    baseOptions,
  );
}
export function useFindOneHubEntitlementLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneHubEntitlementQuery, FindOneHubEntitlementQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneHubEntitlementQuery, FindOneHubEntitlementQueryVariables>(
    FindOneHubEntitlementDocument,
    baseOptions,
  );
}
export type FindOneHubEntitlementQueryHookResult = ReturnType<typeof useFindOneHubEntitlementQuery>;
export type FindOneHubEntitlementLazyQueryHookResult = ReturnType<typeof useFindOneHubEntitlementLazyQuery>;
export type FindOneHubEntitlementQueryResult = ApolloReactCommon.QueryResult<
  FindOneHubEntitlementQuery,
  FindOneHubEntitlementQueryVariables
>;
export const FindManyHubEntitlementDocument = gql`
  query findManyHubEntitlement(
    $where: HubEntitlementWhereInput
    $orderBy: HubEntitlementOrderByInput
    $after: HubEntitlementWhereUniqueInput
    $before: HubEntitlementWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyHubEntitlement(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...HubEntitlementFragment
    }
  }
  ${HubEntitlementFragmentFragmentDoc}
`;

/**
 * __useFindManyHubEntitlementQuery__
 *
 * To run a query within a React component, call `useFindManyHubEntitlementQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyHubEntitlementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyHubEntitlementQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyHubEntitlementQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyHubEntitlementQuery, FindManyHubEntitlementQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyHubEntitlementQuery, FindManyHubEntitlementQueryVariables>(
    FindManyHubEntitlementDocument,
    baseOptions,
  );
}
export function useFindManyHubEntitlementLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyHubEntitlementQuery,
    FindManyHubEntitlementQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyHubEntitlementQuery, FindManyHubEntitlementQueryVariables>(
    FindManyHubEntitlementDocument,
    baseOptions,
  );
}
export type FindManyHubEntitlementQueryHookResult = ReturnType<typeof useFindManyHubEntitlementQuery>;
export type FindManyHubEntitlementLazyQueryHookResult = ReturnType<typeof useFindManyHubEntitlementLazyQuery>;
export type FindManyHubEntitlementQueryResult = ApolloReactCommon.QueryResult<
  FindManyHubEntitlementQuery,
  FindManyHubEntitlementQueryVariables
>;
export const FindManyHubEntitlementCountDocument = gql`
  query findManyHubEntitlementCount(
    $where: HubEntitlementWhereInput
    $orderBy: HubEntitlementOrderByInput
    $after: HubEntitlementWhereUniqueInput
    $before: HubEntitlementWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyHubEntitlementCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyHubEntitlementCountQuery__
 *
 * To run a query within a React component, call `useFindManyHubEntitlementCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyHubEntitlementCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyHubEntitlementCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyHubEntitlementCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyHubEntitlementCountQuery,
    FindManyHubEntitlementCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyHubEntitlementCountQuery, FindManyHubEntitlementCountQueryVariables>(
    FindManyHubEntitlementCountDocument,
    baseOptions,
  );
}
export function useFindManyHubEntitlementCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyHubEntitlementCountQuery,
    FindManyHubEntitlementCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyHubEntitlementCountQuery, FindManyHubEntitlementCountQueryVariables>(
    FindManyHubEntitlementCountDocument,
    baseOptions,
  );
}
export type FindManyHubEntitlementCountQueryHookResult = ReturnType<typeof useFindManyHubEntitlementCountQuery>;
export type FindManyHubEntitlementCountLazyQueryHookResult = ReturnType<typeof useFindManyHubEntitlementCountLazyQuery>;
export type FindManyHubEntitlementCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyHubEntitlementCountQuery,
  FindManyHubEntitlementCountQueryVariables
>;
export const CreateOneHubEntitlementDocument = gql`
  mutation createOneHubEntitlement($data: HubEntitlementCreateInput!) {
    createOneHubEntitlement(data: $data) {
      ...HubEntitlementFragment
    }
  }
  ${HubEntitlementFragmentFragmentDoc}
`;

/**
 * __useCreateOneHubEntitlementMutation__
 *
 * To run a mutation, you first call `useCreateOneHubEntitlementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneHubEntitlementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneHubEntitlementMutation, { data, loading, error }] = useCreateOneHubEntitlementMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneHubEntitlementMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneHubEntitlementMutation,
    CreateOneHubEntitlementMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneHubEntitlementMutation, CreateOneHubEntitlementMutationVariables>(
    CreateOneHubEntitlementDocument,
    baseOptions,
  );
}
export type CreateOneHubEntitlementMutationHookResult = ReturnType<typeof useCreateOneHubEntitlementMutation>;
export type CreateOneHubEntitlementMutationResult = ApolloReactCommon.MutationResult<CreateOneHubEntitlementMutation>;
export type CreateOneHubEntitlementMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneHubEntitlementMutation,
  CreateOneHubEntitlementMutationVariables
>;
export const UpdateOneHubEntitlementDocument = gql`
  mutation updateOneHubEntitlement($where: HubEntitlementWhereUniqueInput!, $data: HubEntitlementUpdateInput!) {
    updateOneHubEntitlement(where: $where, data: $data) {
      ...HubEntitlementFragment
    }
  }
  ${HubEntitlementFragmentFragmentDoc}
`;

/**
 * __useUpdateOneHubEntitlementMutation__
 *
 * To run a mutation, you first call `useUpdateOneHubEntitlementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneHubEntitlementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneHubEntitlementMutation, { data, loading, error }] = useUpdateOneHubEntitlementMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneHubEntitlementMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneHubEntitlementMutation,
    UpdateOneHubEntitlementMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneHubEntitlementMutation, UpdateOneHubEntitlementMutationVariables>(
    UpdateOneHubEntitlementDocument,
    baseOptions,
  );
}
export type UpdateOneHubEntitlementMutationHookResult = ReturnType<typeof useUpdateOneHubEntitlementMutation>;
export type UpdateOneHubEntitlementMutationResult = ApolloReactCommon.MutationResult<UpdateOneHubEntitlementMutation>;
export type UpdateOneHubEntitlementMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneHubEntitlementMutation,
  UpdateOneHubEntitlementMutationVariables
>;
export const DeleteOneHubEntitlementDocument = gql`
  mutation deleteOneHubEntitlement($where: HubEntitlementWhereUniqueInput!) {
    deleteOneHubEntitlement(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneHubEntitlementMutation__
 *
 * To run a mutation, you first call `useDeleteOneHubEntitlementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneHubEntitlementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneHubEntitlementMutation, { data, loading, error }] = useDeleteOneHubEntitlementMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneHubEntitlementMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneHubEntitlementMutation,
    DeleteOneHubEntitlementMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneHubEntitlementMutation, DeleteOneHubEntitlementMutationVariables>(
    DeleteOneHubEntitlementDocument,
    baseOptions,
  );
}
export type DeleteOneHubEntitlementMutationHookResult = ReturnType<typeof useDeleteOneHubEntitlementMutation>;
export type DeleteOneHubEntitlementMutationResult = ApolloReactCommon.MutationResult<DeleteOneHubEntitlementMutation>;
export type DeleteOneHubEntitlementMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneHubEntitlementMutation,
  DeleteOneHubEntitlementMutationVariables
>;
export const DeleteManyHubEntitlementDocument = gql`
  mutation deleteManyHubEntitlement($where: HubEntitlementWhereInput) {
    deleteManyHubEntitlement(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyHubEntitlementMutation__
 *
 * To run a mutation, you first call `useDeleteManyHubEntitlementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyHubEntitlementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyHubEntitlementMutation, { data, loading, error }] = useDeleteManyHubEntitlementMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyHubEntitlementMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyHubEntitlementMutation,
    DeleteManyHubEntitlementMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyHubEntitlementMutation, DeleteManyHubEntitlementMutationVariables>(
    DeleteManyHubEntitlementDocument,
    baseOptions,
  );
}
export type DeleteManyHubEntitlementMutationHookResult = ReturnType<typeof useDeleteManyHubEntitlementMutation>;
export type DeleteManyHubEntitlementMutationResult = ApolloReactCommon.MutationResult<DeleteManyHubEntitlementMutation>;
export type DeleteManyHubEntitlementMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyHubEntitlementMutation,
  DeleteManyHubEntitlementMutationVariables
>;
export const UpdateManyHubEntitlementDocument = gql`
  mutation updateManyHubEntitlement($where: HubEntitlementWhereInput, $data: HubEntitlementUpdateManyMutationInput!) {
    updateManyHubEntitlement(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyHubEntitlementMutation__
 *
 * To run a mutation, you first call `useUpdateManyHubEntitlementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyHubEntitlementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyHubEntitlementMutation, { data, loading, error }] = useUpdateManyHubEntitlementMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyHubEntitlementMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyHubEntitlementMutation,
    UpdateManyHubEntitlementMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyHubEntitlementMutation, UpdateManyHubEntitlementMutationVariables>(
    UpdateManyHubEntitlementDocument,
    baseOptions,
  );
}
export type UpdateManyHubEntitlementMutationHookResult = ReturnType<typeof useUpdateManyHubEntitlementMutation>;
export type UpdateManyHubEntitlementMutationResult = ApolloReactCommon.MutationResult<UpdateManyHubEntitlementMutation>;
export type UpdateManyHubEntitlementMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyHubEntitlementMutation,
  UpdateManyHubEntitlementMutationVariables
>;
export const FindOneLessonContentDocument = gql`
  query findOneLessonContent($where: LessonContentWhereUniqueInput!) {
    findOneLessonContent(where: $where) {
      ...LessonContentFragment
    }
  }
  ${LessonContentFragmentFragmentDoc}
`;

/**
 * __useFindOneLessonContentQuery__
 *
 * To run a query within a React component, call `useFindOneLessonContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneLessonContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneLessonContentQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneLessonContentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneLessonContentQuery, FindOneLessonContentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneLessonContentQuery, FindOneLessonContentQueryVariables>(
    FindOneLessonContentDocument,
    baseOptions,
  );
}
export function useFindOneLessonContentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneLessonContentQuery, FindOneLessonContentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneLessonContentQuery, FindOneLessonContentQueryVariables>(
    FindOneLessonContentDocument,
    baseOptions,
  );
}
export type FindOneLessonContentQueryHookResult = ReturnType<typeof useFindOneLessonContentQuery>;
export type FindOneLessonContentLazyQueryHookResult = ReturnType<typeof useFindOneLessonContentLazyQuery>;
export type FindOneLessonContentQueryResult = ApolloReactCommon.QueryResult<
  FindOneLessonContentQuery,
  FindOneLessonContentQueryVariables
>;
export const FindManyLessonContentDocument = gql`
  query findManyLessonContent(
    $where: LessonContentWhereInput
    $orderBy: LessonContentOrderByInput
    $after: LessonContentWhereUniqueInput
    $before: LessonContentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyLessonContent(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...LessonContentFragment
    }
  }
  ${LessonContentFragmentFragmentDoc}
`;

/**
 * __useFindManyLessonContentQuery__
 *
 * To run a query within a React component, call `useFindManyLessonContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyLessonContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyLessonContentQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyLessonContentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyLessonContentQuery, FindManyLessonContentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyLessonContentQuery, FindManyLessonContentQueryVariables>(
    FindManyLessonContentDocument,
    baseOptions,
  );
}
export function useFindManyLessonContentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyLessonContentQuery, FindManyLessonContentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyLessonContentQuery, FindManyLessonContentQueryVariables>(
    FindManyLessonContentDocument,
    baseOptions,
  );
}
export type FindManyLessonContentQueryHookResult = ReturnType<typeof useFindManyLessonContentQuery>;
export type FindManyLessonContentLazyQueryHookResult = ReturnType<typeof useFindManyLessonContentLazyQuery>;
export type FindManyLessonContentQueryResult = ApolloReactCommon.QueryResult<
  FindManyLessonContentQuery,
  FindManyLessonContentQueryVariables
>;
export const FindManyLessonContentCountDocument = gql`
  query findManyLessonContentCount(
    $where: LessonContentWhereInput
    $orderBy: LessonContentOrderByInput
    $after: LessonContentWhereUniqueInput
    $before: LessonContentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyLessonContentCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyLessonContentCountQuery__
 *
 * To run a query within a React component, call `useFindManyLessonContentCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyLessonContentCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyLessonContentCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyLessonContentCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyLessonContentCountQuery,
    FindManyLessonContentCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyLessonContentCountQuery, FindManyLessonContentCountQueryVariables>(
    FindManyLessonContentCountDocument,
    baseOptions,
  );
}
export function useFindManyLessonContentCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyLessonContentCountQuery,
    FindManyLessonContentCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyLessonContentCountQuery, FindManyLessonContentCountQueryVariables>(
    FindManyLessonContentCountDocument,
    baseOptions,
  );
}
export type FindManyLessonContentCountQueryHookResult = ReturnType<typeof useFindManyLessonContentCountQuery>;
export type FindManyLessonContentCountLazyQueryHookResult = ReturnType<typeof useFindManyLessonContentCountLazyQuery>;
export type FindManyLessonContentCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyLessonContentCountQuery,
  FindManyLessonContentCountQueryVariables
>;
export const CreateOneLessonContentDocument = gql`
  mutation createOneLessonContent($data: LessonContentCreateInput!) {
    createOneLessonContent(data: $data) {
      ...LessonContentFragment
    }
  }
  ${LessonContentFragmentFragmentDoc}
`;

/**
 * __useCreateOneLessonContentMutation__
 *
 * To run a mutation, you first call `useCreateOneLessonContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneLessonContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneLessonContentMutation, { data, loading, error }] = useCreateOneLessonContentMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneLessonContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneLessonContentMutation,
    CreateOneLessonContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneLessonContentMutation, CreateOneLessonContentMutationVariables>(
    CreateOneLessonContentDocument,
    baseOptions,
  );
}
export type CreateOneLessonContentMutationHookResult = ReturnType<typeof useCreateOneLessonContentMutation>;
export type CreateOneLessonContentMutationResult = ApolloReactCommon.MutationResult<CreateOneLessonContentMutation>;
export type CreateOneLessonContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneLessonContentMutation,
  CreateOneLessonContentMutationVariables
>;
export const UpdateOneLessonContentDocument = gql`
  mutation updateOneLessonContent($where: LessonContentWhereUniqueInput!, $data: LessonContentUpdateInput!) {
    updateOneLessonContent(where: $where, data: $data) {
      ...LessonContentFragment
    }
  }
  ${LessonContentFragmentFragmentDoc}
`;

/**
 * __useUpdateOneLessonContentMutation__
 *
 * To run a mutation, you first call `useUpdateOneLessonContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneLessonContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneLessonContentMutation, { data, loading, error }] = useUpdateOneLessonContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneLessonContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneLessonContentMutation,
    UpdateOneLessonContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneLessonContentMutation, UpdateOneLessonContentMutationVariables>(
    UpdateOneLessonContentDocument,
    baseOptions,
  );
}
export type UpdateOneLessonContentMutationHookResult = ReturnType<typeof useUpdateOneLessonContentMutation>;
export type UpdateOneLessonContentMutationResult = ApolloReactCommon.MutationResult<UpdateOneLessonContentMutation>;
export type UpdateOneLessonContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneLessonContentMutation,
  UpdateOneLessonContentMutationVariables
>;
export const DeleteOneLessonContentDocument = gql`
  mutation deleteOneLessonContent($where: LessonContentWhereUniqueInput!) {
    deleteOneLessonContent(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneLessonContentMutation__
 *
 * To run a mutation, you first call `useDeleteOneLessonContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneLessonContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneLessonContentMutation, { data, loading, error }] = useDeleteOneLessonContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneLessonContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneLessonContentMutation,
    DeleteOneLessonContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneLessonContentMutation, DeleteOneLessonContentMutationVariables>(
    DeleteOneLessonContentDocument,
    baseOptions,
  );
}
export type DeleteOneLessonContentMutationHookResult = ReturnType<typeof useDeleteOneLessonContentMutation>;
export type DeleteOneLessonContentMutationResult = ApolloReactCommon.MutationResult<DeleteOneLessonContentMutation>;
export type DeleteOneLessonContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneLessonContentMutation,
  DeleteOneLessonContentMutationVariables
>;
export const DeleteManyLessonContentDocument = gql`
  mutation deleteManyLessonContent($where: LessonContentWhereInput) {
    deleteManyLessonContent(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyLessonContentMutation__
 *
 * To run a mutation, you first call `useDeleteManyLessonContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyLessonContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyLessonContentMutation, { data, loading, error }] = useDeleteManyLessonContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyLessonContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyLessonContentMutation,
    DeleteManyLessonContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyLessonContentMutation, DeleteManyLessonContentMutationVariables>(
    DeleteManyLessonContentDocument,
    baseOptions,
  );
}
export type DeleteManyLessonContentMutationHookResult = ReturnType<typeof useDeleteManyLessonContentMutation>;
export type DeleteManyLessonContentMutationResult = ApolloReactCommon.MutationResult<DeleteManyLessonContentMutation>;
export type DeleteManyLessonContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyLessonContentMutation,
  DeleteManyLessonContentMutationVariables
>;
export const UpdateManyLessonContentDocument = gql`
  mutation updateManyLessonContent($where: LessonContentWhereInput, $data: LessonContentUpdateManyMutationInput!) {
    updateManyLessonContent(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyLessonContentMutation__
 *
 * To run a mutation, you first call `useUpdateManyLessonContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyLessonContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyLessonContentMutation, { data, loading, error }] = useUpdateManyLessonContentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyLessonContentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyLessonContentMutation,
    UpdateManyLessonContentMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyLessonContentMutation, UpdateManyLessonContentMutationVariables>(
    UpdateManyLessonContentDocument,
    baseOptions,
  );
}
export type UpdateManyLessonContentMutationHookResult = ReturnType<typeof useUpdateManyLessonContentMutation>;
export type UpdateManyLessonContentMutationResult = ApolloReactCommon.MutationResult<UpdateManyLessonContentMutation>;
export type UpdateManyLessonContentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyLessonContentMutation,
  UpdateManyLessonContentMutationVariables
>;
export const FindOneLessonContentResourceDocument = gql`
  query findOneLessonContentResource($where: LessonContentResourceWhereUniqueInput!) {
    findOneLessonContentResource(where: $where) {
      ...LessonContentResourceFragment
    }
  }
  ${LessonContentResourceFragmentFragmentDoc}
`;

/**
 * __useFindOneLessonContentResourceQuery__
 *
 * To run a query within a React component, call `useFindOneLessonContentResourceQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneLessonContentResourceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneLessonContentResourceQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneLessonContentResourceQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneLessonContentResourceQuery,
    FindOneLessonContentResourceQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneLessonContentResourceQuery, FindOneLessonContentResourceQueryVariables>(
    FindOneLessonContentResourceDocument,
    baseOptions,
  );
}
export function useFindOneLessonContentResourceLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneLessonContentResourceQuery,
    FindOneLessonContentResourceQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneLessonContentResourceQuery, FindOneLessonContentResourceQueryVariables>(
    FindOneLessonContentResourceDocument,
    baseOptions,
  );
}
export type FindOneLessonContentResourceQueryHookResult = ReturnType<typeof useFindOneLessonContentResourceQuery>;
export type FindOneLessonContentResourceLazyQueryHookResult = ReturnType<
  typeof useFindOneLessonContentResourceLazyQuery
>;
export type FindOneLessonContentResourceQueryResult = ApolloReactCommon.QueryResult<
  FindOneLessonContentResourceQuery,
  FindOneLessonContentResourceQueryVariables
>;
export const FindManyLessonContentResourceDocument = gql`
  query findManyLessonContentResource(
    $where: LessonContentResourceWhereInput
    $orderBy: LessonContentResourceOrderByInput
    $after: LessonContentResourceWhereUniqueInput
    $before: LessonContentResourceWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyLessonContentResource(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...LessonContentResourceFragment
    }
  }
  ${LessonContentResourceFragmentFragmentDoc}
`;

/**
 * __useFindManyLessonContentResourceQuery__
 *
 * To run a query within a React component, call `useFindManyLessonContentResourceQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyLessonContentResourceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyLessonContentResourceQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyLessonContentResourceQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyLessonContentResourceQuery,
    FindManyLessonContentResourceQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyLessonContentResourceQuery, FindManyLessonContentResourceQueryVariables>(
    FindManyLessonContentResourceDocument,
    baseOptions,
  );
}
export function useFindManyLessonContentResourceLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyLessonContentResourceQuery,
    FindManyLessonContentResourceQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyLessonContentResourceQuery, FindManyLessonContentResourceQueryVariables>(
    FindManyLessonContentResourceDocument,
    baseOptions,
  );
}
export type FindManyLessonContentResourceQueryHookResult = ReturnType<typeof useFindManyLessonContentResourceQuery>;
export type FindManyLessonContentResourceLazyQueryHookResult = ReturnType<
  typeof useFindManyLessonContentResourceLazyQuery
>;
export type FindManyLessonContentResourceQueryResult = ApolloReactCommon.QueryResult<
  FindManyLessonContentResourceQuery,
  FindManyLessonContentResourceQueryVariables
>;
export const FindManyLessonContentResourceCountDocument = gql`
  query findManyLessonContentResourceCount(
    $where: LessonContentResourceWhereInput
    $orderBy: LessonContentResourceOrderByInput
    $after: LessonContentResourceWhereUniqueInput
    $before: LessonContentResourceWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyLessonContentResourceCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyLessonContentResourceCountQuery__
 *
 * To run a query within a React component, call `useFindManyLessonContentResourceCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyLessonContentResourceCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyLessonContentResourceCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyLessonContentResourceCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyLessonContentResourceCountQuery,
    FindManyLessonContentResourceCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyLessonContentResourceCountQuery,
    FindManyLessonContentResourceCountQueryVariables
  >(FindManyLessonContentResourceCountDocument, baseOptions);
}
export function useFindManyLessonContentResourceCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyLessonContentResourceCountQuery,
    FindManyLessonContentResourceCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyLessonContentResourceCountQuery,
    FindManyLessonContentResourceCountQueryVariables
  >(FindManyLessonContentResourceCountDocument, baseOptions);
}
export type FindManyLessonContentResourceCountQueryHookResult = ReturnType<
  typeof useFindManyLessonContentResourceCountQuery
>;
export type FindManyLessonContentResourceCountLazyQueryHookResult = ReturnType<
  typeof useFindManyLessonContentResourceCountLazyQuery
>;
export type FindManyLessonContentResourceCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyLessonContentResourceCountQuery,
  FindManyLessonContentResourceCountQueryVariables
>;
export const CreateOneLessonContentResourceDocument = gql`
  mutation createOneLessonContentResource($data: LessonContentResourceCreateInput!) {
    createOneLessonContentResource(data: $data) {
      ...LessonContentResourceFragment
    }
  }
  ${LessonContentResourceFragmentFragmentDoc}
`;

/**
 * __useCreateOneLessonContentResourceMutation__
 *
 * To run a mutation, you first call `useCreateOneLessonContentResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneLessonContentResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneLessonContentResourceMutation, { data, loading, error }] = useCreateOneLessonContentResourceMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneLessonContentResourceMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneLessonContentResourceMutation,
    CreateOneLessonContentResourceMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneLessonContentResourceMutation,
    CreateOneLessonContentResourceMutationVariables
  >(CreateOneLessonContentResourceDocument, baseOptions);
}
export type CreateOneLessonContentResourceMutationHookResult = ReturnType<
  typeof useCreateOneLessonContentResourceMutation
>;
export type CreateOneLessonContentResourceMutationResult = ApolloReactCommon.MutationResult<
  CreateOneLessonContentResourceMutation
>;
export type CreateOneLessonContentResourceMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneLessonContentResourceMutation,
  CreateOneLessonContentResourceMutationVariables
>;
export const UpdateOneLessonContentResourceDocument = gql`
  mutation updateOneLessonContentResource(
    $where: LessonContentResourceWhereUniqueInput!
    $data: LessonContentResourceUpdateInput!
  ) {
    updateOneLessonContentResource(where: $where, data: $data) {
      ...LessonContentResourceFragment
    }
  }
  ${LessonContentResourceFragmentFragmentDoc}
`;

/**
 * __useUpdateOneLessonContentResourceMutation__
 *
 * To run a mutation, you first call `useUpdateOneLessonContentResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneLessonContentResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneLessonContentResourceMutation, { data, loading, error }] = useUpdateOneLessonContentResourceMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneLessonContentResourceMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneLessonContentResourceMutation,
    UpdateOneLessonContentResourceMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneLessonContentResourceMutation,
    UpdateOneLessonContentResourceMutationVariables
  >(UpdateOneLessonContentResourceDocument, baseOptions);
}
export type UpdateOneLessonContentResourceMutationHookResult = ReturnType<
  typeof useUpdateOneLessonContentResourceMutation
>;
export type UpdateOneLessonContentResourceMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneLessonContentResourceMutation
>;
export type UpdateOneLessonContentResourceMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneLessonContentResourceMutation,
  UpdateOneLessonContentResourceMutationVariables
>;
export const DeleteOneLessonContentResourceDocument = gql`
  mutation deleteOneLessonContentResource($where: LessonContentResourceWhereUniqueInput!) {
    deleteOneLessonContentResource(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneLessonContentResourceMutation__
 *
 * To run a mutation, you first call `useDeleteOneLessonContentResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneLessonContentResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneLessonContentResourceMutation, { data, loading, error }] = useDeleteOneLessonContentResourceMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneLessonContentResourceMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneLessonContentResourceMutation,
    DeleteOneLessonContentResourceMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneLessonContentResourceMutation,
    DeleteOneLessonContentResourceMutationVariables
  >(DeleteOneLessonContentResourceDocument, baseOptions);
}
export type DeleteOneLessonContentResourceMutationHookResult = ReturnType<
  typeof useDeleteOneLessonContentResourceMutation
>;
export type DeleteOneLessonContentResourceMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneLessonContentResourceMutation
>;
export type DeleteOneLessonContentResourceMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneLessonContentResourceMutation,
  DeleteOneLessonContentResourceMutationVariables
>;
export const DeleteManyLessonContentResourceDocument = gql`
  mutation deleteManyLessonContentResource($where: LessonContentResourceWhereInput) {
    deleteManyLessonContentResource(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyLessonContentResourceMutation__
 *
 * To run a mutation, you first call `useDeleteManyLessonContentResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyLessonContentResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyLessonContentResourceMutation, { data, loading, error }] = useDeleteManyLessonContentResourceMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyLessonContentResourceMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyLessonContentResourceMutation,
    DeleteManyLessonContentResourceMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyLessonContentResourceMutation,
    DeleteManyLessonContentResourceMutationVariables
  >(DeleteManyLessonContentResourceDocument, baseOptions);
}
export type DeleteManyLessonContentResourceMutationHookResult = ReturnType<
  typeof useDeleteManyLessonContentResourceMutation
>;
export type DeleteManyLessonContentResourceMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyLessonContentResourceMutation
>;
export type DeleteManyLessonContentResourceMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyLessonContentResourceMutation,
  DeleteManyLessonContentResourceMutationVariables
>;
export const UpdateManyLessonContentResourceDocument = gql`
  mutation updateManyLessonContentResource(
    $where: LessonContentResourceWhereInput
    $data: LessonContentResourceUpdateManyMutationInput!
  ) {
    updateManyLessonContentResource(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyLessonContentResourceMutation__
 *
 * To run a mutation, you first call `useUpdateManyLessonContentResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyLessonContentResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyLessonContentResourceMutation, { data, loading, error }] = useUpdateManyLessonContentResourceMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyLessonContentResourceMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyLessonContentResourceMutation,
    UpdateManyLessonContentResourceMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyLessonContentResourceMutation,
    UpdateManyLessonContentResourceMutationVariables
  >(UpdateManyLessonContentResourceDocument, baseOptions);
}
export type UpdateManyLessonContentResourceMutationHookResult = ReturnType<
  typeof useUpdateManyLessonContentResourceMutation
>;
export type UpdateManyLessonContentResourceMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyLessonContentResourceMutation
>;
export type UpdateManyLessonContentResourceMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyLessonContentResourceMutation,
  UpdateManyLessonContentResourceMutationVariables
>;
export const FindOneLessonTakingDocument = gql`
  query findOneLessonTaking($where: LessonTakingWhereUniqueInput!) {
    findOneLessonTaking(where: $where) {
      ...LessonTakingFragment
    }
  }
  ${LessonTakingFragmentFragmentDoc}
`;

/**
 * __useFindOneLessonTakingQuery__
 *
 * To run a query within a React component, call `useFindOneLessonTakingQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneLessonTakingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneLessonTakingQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneLessonTakingQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneLessonTakingQuery, FindOneLessonTakingQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneLessonTakingQuery, FindOneLessonTakingQueryVariables>(
    FindOneLessonTakingDocument,
    baseOptions,
  );
}
export function useFindOneLessonTakingLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneLessonTakingQuery, FindOneLessonTakingQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneLessonTakingQuery, FindOneLessonTakingQueryVariables>(
    FindOneLessonTakingDocument,
    baseOptions,
  );
}
export type FindOneLessonTakingQueryHookResult = ReturnType<typeof useFindOneLessonTakingQuery>;
export type FindOneLessonTakingLazyQueryHookResult = ReturnType<typeof useFindOneLessonTakingLazyQuery>;
export type FindOneLessonTakingQueryResult = ApolloReactCommon.QueryResult<
  FindOneLessonTakingQuery,
  FindOneLessonTakingQueryVariables
>;
export const FindManyLessonTakingDocument = gql`
  query findManyLessonTaking(
    $where: LessonTakingWhereInput
    $orderBy: LessonTakingOrderByInput
    $after: LessonTakingWhereUniqueInput
    $before: LessonTakingWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyLessonTaking(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...LessonTakingFragment
    }
  }
  ${LessonTakingFragmentFragmentDoc}
`;

/**
 * __useFindManyLessonTakingQuery__
 *
 * To run a query within a React component, call `useFindManyLessonTakingQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyLessonTakingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyLessonTakingQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyLessonTakingQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyLessonTakingQuery, FindManyLessonTakingQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyLessonTakingQuery, FindManyLessonTakingQueryVariables>(
    FindManyLessonTakingDocument,
    baseOptions,
  );
}
export function useFindManyLessonTakingLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyLessonTakingQuery, FindManyLessonTakingQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyLessonTakingQuery, FindManyLessonTakingQueryVariables>(
    FindManyLessonTakingDocument,
    baseOptions,
  );
}
export type FindManyLessonTakingQueryHookResult = ReturnType<typeof useFindManyLessonTakingQuery>;
export type FindManyLessonTakingLazyQueryHookResult = ReturnType<typeof useFindManyLessonTakingLazyQuery>;
export type FindManyLessonTakingQueryResult = ApolloReactCommon.QueryResult<
  FindManyLessonTakingQuery,
  FindManyLessonTakingQueryVariables
>;
export const FindManyLessonTakingCountDocument = gql`
  query findManyLessonTakingCount(
    $where: LessonTakingWhereInput
    $orderBy: LessonTakingOrderByInput
    $after: LessonTakingWhereUniqueInput
    $before: LessonTakingWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyLessonTakingCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyLessonTakingCountQuery__
 *
 * To run a query within a React component, call `useFindManyLessonTakingCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyLessonTakingCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyLessonTakingCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyLessonTakingCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyLessonTakingCountQuery,
    FindManyLessonTakingCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyLessonTakingCountQuery, FindManyLessonTakingCountQueryVariables>(
    FindManyLessonTakingCountDocument,
    baseOptions,
  );
}
export function useFindManyLessonTakingCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyLessonTakingCountQuery,
    FindManyLessonTakingCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyLessonTakingCountQuery, FindManyLessonTakingCountQueryVariables>(
    FindManyLessonTakingCountDocument,
    baseOptions,
  );
}
export type FindManyLessonTakingCountQueryHookResult = ReturnType<typeof useFindManyLessonTakingCountQuery>;
export type FindManyLessonTakingCountLazyQueryHookResult = ReturnType<typeof useFindManyLessonTakingCountLazyQuery>;
export type FindManyLessonTakingCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyLessonTakingCountQuery,
  FindManyLessonTakingCountQueryVariables
>;
export const CreateOneLessonTakingDocument = gql`
  mutation createOneLessonTaking($data: LessonTakingCreateInput!) {
    createOneLessonTaking(data: $data) {
      ...LessonTakingFragment
    }
  }
  ${LessonTakingFragmentFragmentDoc}
`;

/**
 * __useCreateOneLessonTakingMutation__
 *
 * To run a mutation, you first call `useCreateOneLessonTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneLessonTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneLessonTakingMutation, { data, loading, error }] = useCreateOneLessonTakingMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneLessonTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneLessonTakingMutation,
    CreateOneLessonTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<CreateOneLessonTakingMutation, CreateOneLessonTakingMutationVariables>(
    CreateOneLessonTakingDocument,
    baseOptions,
  );
}
export type CreateOneLessonTakingMutationHookResult = ReturnType<typeof useCreateOneLessonTakingMutation>;
export type CreateOneLessonTakingMutationResult = ApolloReactCommon.MutationResult<CreateOneLessonTakingMutation>;
export type CreateOneLessonTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneLessonTakingMutation,
  CreateOneLessonTakingMutationVariables
>;
export const UpdateOneLessonTakingDocument = gql`
  mutation updateOneLessonTaking($where: LessonTakingWhereUniqueInput!, $data: LessonTakingUpdateInput!) {
    updateOneLessonTaking(where: $where, data: $data) {
      ...LessonTakingFragment
    }
  }
  ${LessonTakingFragmentFragmentDoc}
`;

/**
 * __useUpdateOneLessonTakingMutation__
 *
 * To run a mutation, you first call `useUpdateOneLessonTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneLessonTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneLessonTakingMutation, { data, loading, error }] = useUpdateOneLessonTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneLessonTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneLessonTakingMutation,
    UpdateOneLessonTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateOneLessonTakingMutation, UpdateOneLessonTakingMutationVariables>(
    UpdateOneLessonTakingDocument,
    baseOptions,
  );
}
export type UpdateOneLessonTakingMutationHookResult = ReturnType<typeof useUpdateOneLessonTakingMutation>;
export type UpdateOneLessonTakingMutationResult = ApolloReactCommon.MutationResult<UpdateOneLessonTakingMutation>;
export type UpdateOneLessonTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneLessonTakingMutation,
  UpdateOneLessonTakingMutationVariables
>;
export const DeleteOneLessonTakingDocument = gql`
  mutation deleteOneLessonTaking($where: LessonTakingWhereUniqueInput!) {
    deleteOneLessonTaking(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneLessonTakingMutation__
 *
 * To run a mutation, you first call `useDeleteOneLessonTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneLessonTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneLessonTakingMutation, { data, loading, error }] = useDeleteOneLessonTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneLessonTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneLessonTakingMutation,
    DeleteOneLessonTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteOneLessonTakingMutation, DeleteOneLessonTakingMutationVariables>(
    DeleteOneLessonTakingDocument,
    baseOptions,
  );
}
export type DeleteOneLessonTakingMutationHookResult = ReturnType<typeof useDeleteOneLessonTakingMutation>;
export type DeleteOneLessonTakingMutationResult = ApolloReactCommon.MutationResult<DeleteOneLessonTakingMutation>;
export type DeleteOneLessonTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneLessonTakingMutation,
  DeleteOneLessonTakingMutationVariables
>;
export const DeleteManyLessonTakingDocument = gql`
  mutation deleteManyLessonTaking($where: LessonTakingWhereInput) {
    deleteManyLessonTaking(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyLessonTakingMutation__
 *
 * To run a mutation, you first call `useDeleteManyLessonTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyLessonTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyLessonTakingMutation, { data, loading, error }] = useDeleteManyLessonTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyLessonTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyLessonTakingMutation,
    DeleteManyLessonTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<DeleteManyLessonTakingMutation, DeleteManyLessonTakingMutationVariables>(
    DeleteManyLessonTakingDocument,
    baseOptions,
  );
}
export type DeleteManyLessonTakingMutationHookResult = ReturnType<typeof useDeleteManyLessonTakingMutation>;
export type DeleteManyLessonTakingMutationResult = ApolloReactCommon.MutationResult<DeleteManyLessonTakingMutation>;
export type DeleteManyLessonTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyLessonTakingMutation,
  DeleteManyLessonTakingMutationVariables
>;
export const UpdateManyLessonTakingDocument = gql`
  mutation updateManyLessonTaking($where: LessonTakingWhereInput, $data: LessonTakingUpdateManyMutationInput!) {
    updateManyLessonTaking(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyLessonTakingMutation__
 *
 * To run a mutation, you first call `useUpdateManyLessonTakingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyLessonTakingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyLessonTakingMutation, { data, loading, error }] = useUpdateManyLessonTakingMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyLessonTakingMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyLessonTakingMutation,
    UpdateManyLessonTakingMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<UpdateManyLessonTakingMutation, UpdateManyLessonTakingMutationVariables>(
    UpdateManyLessonTakingDocument,
    baseOptions,
  );
}
export type UpdateManyLessonTakingMutationHookResult = ReturnType<typeof useUpdateManyLessonTakingMutation>;
export type UpdateManyLessonTakingMutationResult = ApolloReactCommon.MutationResult<UpdateManyLessonTakingMutation>;
export type UpdateManyLessonTakingMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyLessonTakingMutation,
  UpdateManyLessonTakingMutationVariables
>;
export const FindOneParentDocument = gql`
  query findOneParent($where: ParentWhereUniqueInput!) {
    findOneParent(where: $where) {
      ...ParentFragment
    }
  }
  ${ParentFragmentFragmentDoc}
`;

/**
 * __useFindOneParentQuery__
 *
 * To run a query within a React component, call `useFindOneParentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneParentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneParentQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneParentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneParentQuery, FindOneParentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneParentQuery, FindOneParentQueryVariables>(FindOneParentDocument, baseOptions);
}
export function useFindOneParentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneParentQuery, FindOneParentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneParentQuery, FindOneParentQueryVariables>(
    FindOneParentDocument,
    baseOptions,
  );
}
export type FindOneParentQueryHookResult = ReturnType<typeof useFindOneParentQuery>;
export type FindOneParentLazyQueryHookResult = ReturnType<typeof useFindOneParentLazyQuery>;
export type FindOneParentQueryResult = ApolloReactCommon.QueryResult<FindOneParentQuery, FindOneParentQueryVariables>;
export const FindManyParentDocument = gql`
  query findManyParent(
    $where: ParentWhereInput
    $orderBy: ParentOrderByInput
    $after: ParentWhereUniqueInput
    $before: ParentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyParent(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...ParentFragment
    }
  }
  ${ParentFragmentFragmentDoc}
`;

/**
 * __useFindManyParentQuery__
 *
 * To run a query within a React component, call `useFindManyParentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyParentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyParentQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyParentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyParentQuery, FindManyParentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyParentQuery, FindManyParentQueryVariables>(
    FindManyParentDocument,
    baseOptions,
  );
}
export function useFindManyParentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyParentQuery, FindManyParentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyParentQuery, FindManyParentQueryVariables>(
    FindManyParentDocument,
    baseOptions,
  );
}
export type FindManyParentQueryHookResult = ReturnType<typeof useFindManyParentQuery>;
export type FindManyParentLazyQueryHookResult = ReturnType<typeof useFindManyParentLazyQuery>;
export type FindManyParentQueryResult = ApolloReactCommon.QueryResult<
  FindManyParentQuery,
  FindManyParentQueryVariables
>;
export const FindManyParentCountDocument = gql`
  query findManyParentCount(
    $where: ParentWhereInput
    $orderBy: ParentOrderByInput
    $after: ParentWhereUniqueInput
    $before: ParentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyParentCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyParentCountQuery__
 *
 * To run a query within a React component, call `useFindManyParentCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyParentCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyParentCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyParentCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyParentCountQuery, FindManyParentCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyParentCountQuery, FindManyParentCountQueryVariables>(
    FindManyParentCountDocument,
    baseOptions,
  );
}
export function useFindManyParentCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyParentCountQuery, FindManyParentCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyParentCountQuery, FindManyParentCountQueryVariables>(
    FindManyParentCountDocument,
    baseOptions,
  );
}
export type FindManyParentCountQueryHookResult = ReturnType<typeof useFindManyParentCountQuery>;
export type FindManyParentCountLazyQueryHookResult = ReturnType<typeof useFindManyParentCountLazyQuery>;
export type FindManyParentCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyParentCountQuery,
  FindManyParentCountQueryVariables
>;
export const CreateOneParentDocument = gql`
  mutation createOneParent($data: ParentCreateInput!) {
    createOneParent(data: $data) {
      ...ParentFragment
    }
  }
  ${ParentFragmentFragmentDoc}
`;

/**
 * __useCreateOneParentMutation__
 *
 * To run a mutation, you first call `useCreateOneParentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneParentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneParentMutation, { data, loading, error }] = useCreateOneParentMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneParentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneParentMutation, CreateOneParentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneParentMutation, CreateOneParentMutationVariables>(
    CreateOneParentDocument,
    baseOptions,
  );
}
export type CreateOneParentMutationHookResult = ReturnType<typeof useCreateOneParentMutation>;
export type CreateOneParentMutationResult = ApolloReactCommon.MutationResult<CreateOneParentMutation>;
export type CreateOneParentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneParentMutation,
  CreateOneParentMutationVariables
>;
export const UpdateOneParentDocument = gql`
  mutation updateOneParent($where: ParentWhereUniqueInput!, $data: ParentUpdateInput!) {
    updateOneParent(where: $where, data: $data) {
      ...ParentFragment
    }
  }
  ${ParentFragmentFragmentDoc}
`;

/**
 * __useUpdateOneParentMutation__
 *
 * To run a mutation, you first call `useUpdateOneParentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneParentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneParentMutation, { data, loading, error }] = useUpdateOneParentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneParentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneParentMutation, UpdateOneParentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneParentMutation, UpdateOneParentMutationVariables>(
    UpdateOneParentDocument,
    baseOptions,
  );
}
export type UpdateOneParentMutationHookResult = ReturnType<typeof useUpdateOneParentMutation>;
export type UpdateOneParentMutationResult = ApolloReactCommon.MutationResult<UpdateOneParentMutation>;
export type UpdateOneParentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneParentMutation,
  UpdateOneParentMutationVariables
>;
export const DeleteOneParentDocument = gql`
  mutation deleteOneParent($where: ParentWhereUniqueInput!) {
    deleteOneParent(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneParentMutation__
 *
 * To run a mutation, you first call `useDeleteOneParentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneParentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneParentMutation, { data, loading, error }] = useDeleteOneParentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneParentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneParentMutation, DeleteOneParentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneParentMutation, DeleteOneParentMutationVariables>(
    DeleteOneParentDocument,
    baseOptions,
  );
}
export type DeleteOneParentMutationHookResult = ReturnType<typeof useDeleteOneParentMutation>;
export type DeleteOneParentMutationResult = ApolloReactCommon.MutationResult<DeleteOneParentMutation>;
export type DeleteOneParentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneParentMutation,
  DeleteOneParentMutationVariables
>;
export const DeleteManyParentDocument = gql`
  mutation deleteManyParent($where: ParentWhereInput) {
    deleteManyParent(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyParentMutation__
 *
 * To run a mutation, you first call `useDeleteManyParentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyParentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyParentMutation, { data, loading, error }] = useDeleteManyParentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyParentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyParentMutation, DeleteManyParentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyParentMutation, DeleteManyParentMutationVariables>(
    DeleteManyParentDocument,
    baseOptions,
  );
}
export type DeleteManyParentMutationHookResult = ReturnType<typeof useDeleteManyParentMutation>;
export type DeleteManyParentMutationResult = ApolloReactCommon.MutationResult<DeleteManyParentMutation>;
export type DeleteManyParentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyParentMutation,
  DeleteManyParentMutationVariables
>;
export const UpdateManyParentDocument = gql`
  mutation updateManyParent($where: ParentWhereInput, $data: ParentUpdateManyMutationInput!) {
    updateManyParent(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyParentMutation__
 *
 * To run a mutation, you first call `useUpdateManyParentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyParentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyParentMutation, { data, loading, error }] = useUpdateManyParentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyParentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyParentMutation, UpdateManyParentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyParentMutation, UpdateManyParentMutationVariables>(
    UpdateManyParentDocument,
    baseOptions,
  );
}
export type UpdateManyParentMutationHookResult = ReturnType<typeof useUpdateManyParentMutation>;
export type UpdateManyParentMutationResult = ApolloReactCommon.MutationResult<UpdateManyParentMutation>;
export type UpdateManyParentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyParentMutation,
  UpdateManyParentMutationVariables
>;
export const FindOnePersonDocument = gql`
  query findOnePerson($where: PersonWhereUniqueInput!) {
    findOnePerson(where: $where) {
      ...PersonFragment
    }
  }
  ${PersonFragmentFragmentDoc}
`;

/**
 * __useFindOnePersonQuery__
 *
 * To run a query within a React component, call `useFindOnePersonQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOnePersonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOnePersonQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOnePersonQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOnePersonQuery, FindOnePersonQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOnePersonQuery, FindOnePersonQueryVariables>(FindOnePersonDocument, baseOptions);
}
export function useFindOnePersonLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOnePersonQuery, FindOnePersonQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOnePersonQuery, FindOnePersonQueryVariables>(
    FindOnePersonDocument,
    baseOptions,
  );
}
export type FindOnePersonQueryHookResult = ReturnType<typeof useFindOnePersonQuery>;
export type FindOnePersonLazyQueryHookResult = ReturnType<typeof useFindOnePersonLazyQuery>;
export type FindOnePersonQueryResult = ApolloReactCommon.QueryResult<FindOnePersonQuery, FindOnePersonQueryVariables>;
export const FindManyPersonDocument = gql`
  query findManyPerson(
    $where: PersonWhereInput
    $orderBy: PersonOrderByInput
    $after: PersonWhereUniqueInput
    $before: PersonWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyPerson(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...PersonFragment
    }
  }
  ${PersonFragmentFragmentDoc}
`;

/**
 * __useFindManyPersonQuery__
 *
 * To run a query within a React component, call `useFindManyPersonQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyPersonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyPersonQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyPersonQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyPersonQuery, FindManyPersonQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyPersonQuery, FindManyPersonQueryVariables>(
    FindManyPersonDocument,
    baseOptions,
  );
}
export function useFindManyPersonLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyPersonQuery, FindManyPersonQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyPersonQuery, FindManyPersonQueryVariables>(
    FindManyPersonDocument,
    baseOptions,
  );
}
export type FindManyPersonQueryHookResult = ReturnType<typeof useFindManyPersonQuery>;
export type FindManyPersonLazyQueryHookResult = ReturnType<typeof useFindManyPersonLazyQuery>;
export type FindManyPersonQueryResult = ApolloReactCommon.QueryResult<
  FindManyPersonQuery,
  FindManyPersonQueryVariables
>;
export const FindManyPersonCountDocument = gql`
  query findManyPersonCount(
    $where: PersonWhereInput
    $orderBy: PersonOrderByInput
    $after: PersonWhereUniqueInput
    $before: PersonWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyPersonCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyPersonCountQuery__
 *
 * To run a query within a React component, call `useFindManyPersonCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyPersonCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyPersonCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyPersonCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyPersonCountQuery, FindManyPersonCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyPersonCountQuery, FindManyPersonCountQueryVariables>(
    FindManyPersonCountDocument,
    baseOptions,
  );
}
export function useFindManyPersonCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyPersonCountQuery, FindManyPersonCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyPersonCountQuery, FindManyPersonCountQueryVariables>(
    FindManyPersonCountDocument,
    baseOptions,
  );
}
export type FindManyPersonCountQueryHookResult = ReturnType<typeof useFindManyPersonCountQuery>;
export type FindManyPersonCountLazyQueryHookResult = ReturnType<typeof useFindManyPersonCountLazyQuery>;
export type FindManyPersonCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyPersonCountQuery,
  FindManyPersonCountQueryVariables
>;
export const CreateOnePersonDocument = gql`
  mutation createOnePerson($data: PersonCreateInput!) {
    createOnePerson(data: $data) {
      ...PersonFragment
    }
  }
  ${PersonFragmentFragmentDoc}
`;

/**
 * __useCreateOnePersonMutation__
 *
 * To run a mutation, you first call `useCreateOnePersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOnePersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOnePersonMutation, { data, loading, error }] = useCreateOnePersonMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOnePersonMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOnePersonMutation, CreateOnePersonMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOnePersonMutation, CreateOnePersonMutationVariables>(
    CreateOnePersonDocument,
    baseOptions,
  );
}
export type CreateOnePersonMutationHookResult = ReturnType<typeof useCreateOnePersonMutation>;
export type CreateOnePersonMutationResult = ApolloReactCommon.MutationResult<CreateOnePersonMutation>;
export type CreateOnePersonMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOnePersonMutation,
  CreateOnePersonMutationVariables
>;
export const UpdateOnePersonDocument = gql`
  mutation updateOnePerson($where: PersonWhereUniqueInput!, $data: PersonUpdateInput!) {
    updateOnePerson(where: $where, data: $data) {
      ...PersonFragment
    }
  }
  ${PersonFragmentFragmentDoc}
`;

/**
 * __useUpdateOnePersonMutation__
 *
 * To run a mutation, you first call `useUpdateOnePersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOnePersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOnePersonMutation, { data, loading, error }] = useUpdateOnePersonMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOnePersonMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOnePersonMutation, UpdateOnePersonMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOnePersonMutation, UpdateOnePersonMutationVariables>(
    UpdateOnePersonDocument,
    baseOptions,
  );
}
export type UpdateOnePersonMutationHookResult = ReturnType<typeof useUpdateOnePersonMutation>;
export type UpdateOnePersonMutationResult = ApolloReactCommon.MutationResult<UpdateOnePersonMutation>;
export type UpdateOnePersonMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOnePersonMutation,
  UpdateOnePersonMutationVariables
>;
export const DeleteOnePersonDocument = gql`
  mutation deleteOnePerson($where: PersonWhereUniqueInput!) {
    deleteOnePerson(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOnePersonMutation__
 *
 * To run a mutation, you first call `useDeleteOnePersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOnePersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOnePersonMutation, { data, loading, error }] = useDeleteOnePersonMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOnePersonMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOnePersonMutation, DeleteOnePersonMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOnePersonMutation, DeleteOnePersonMutationVariables>(
    DeleteOnePersonDocument,
    baseOptions,
  );
}
export type DeleteOnePersonMutationHookResult = ReturnType<typeof useDeleteOnePersonMutation>;
export type DeleteOnePersonMutationResult = ApolloReactCommon.MutationResult<DeleteOnePersonMutation>;
export type DeleteOnePersonMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOnePersonMutation,
  DeleteOnePersonMutationVariables
>;
export const DeleteManyPersonDocument = gql`
  mutation deleteManyPerson($where: PersonWhereInput) {
    deleteManyPerson(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyPersonMutation__
 *
 * To run a mutation, you first call `useDeleteManyPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyPersonMutation, { data, loading, error }] = useDeleteManyPersonMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyPersonMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyPersonMutation, DeleteManyPersonMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyPersonMutation, DeleteManyPersonMutationVariables>(
    DeleteManyPersonDocument,
    baseOptions,
  );
}
export type DeleteManyPersonMutationHookResult = ReturnType<typeof useDeleteManyPersonMutation>;
export type DeleteManyPersonMutationResult = ApolloReactCommon.MutationResult<DeleteManyPersonMutation>;
export type DeleteManyPersonMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyPersonMutation,
  DeleteManyPersonMutationVariables
>;
export const UpdateManyPersonDocument = gql`
  mutation updateManyPerson($where: PersonWhereInput, $data: PersonUpdateManyMutationInput!) {
    updateManyPerson(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyPersonMutation__
 *
 * To run a mutation, you first call `useUpdateManyPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyPersonMutation, { data, loading, error }] = useUpdateManyPersonMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyPersonMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyPersonMutation, UpdateManyPersonMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyPersonMutation, UpdateManyPersonMutationVariables>(
    UpdateManyPersonDocument,
    baseOptions,
  );
}
export type UpdateManyPersonMutationHookResult = ReturnType<typeof useUpdateManyPersonMutation>;
export type UpdateManyPersonMutationResult = ApolloReactCommon.MutationResult<UpdateManyPersonMutation>;
export type UpdateManyPersonMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyPersonMutation,
  UpdateManyPersonMutationVariables
>;
export const GetModelDocument = gql`
  query getModel($id: String!) {
    getModel(id: $id) {
      ...ModelFragment
    }
  }
  ${ModelFragmentFragmentDoc}
`;

/**
 * __useGetModelQuery__
 *
 * To run a query within a React component, call `useGetModelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetModelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetModelQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetModelQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<GetModelQuery, GetModelQueryVariables>,
) {
  return ApolloReactHooks.useQuery<GetModelQuery, GetModelQueryVariables>(GetModelDocument, baseOptions);
}
export function useGetModelLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetModelQuery, GetModelQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<GetModelQuery, GetModelQueryVariables>(GetModelDocument, baseOptions);
}
export type GetModelQueryHookResult = ReturnType<typeof useGetModelQuery>;
export type GetModelLazyQueryHookResult = ReturnType<typeof useGetModelLazyQuery>;
export type GetModelQueryResult = ApolloReactCommon.QueryResult<GetModelQuery, GetModelQueryVariables>;
export const GetModelsDocument = gql`
  query getModels {
    getModels {
      ...ModelFragment
    }
  }
  ${ModelFragmentFragmentDoc}
`;

/**
 * __useGetModelsQuery__
 *
 * To run a query within a React component, call `useGetModelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetModelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetModelsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetModelsQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<GetModelsQuery, GetModelsQueryVariables>,
) {
  return ApolloReactHooks.useQuery<GetModelsQuery, GetModelsQueryVariables>(GetModelsDocument, baseOptions);
}
export function useGetModelsLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetModelsQuery, GetModelsQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<GetModelsQuery, GetModelsQueryVariables>(GetModelsDocument, baseOptions);
}
export type GetModelsQueryHookResult = ReturnType<typeof useGetModelsQuery>;
export type GetModelsLazyQueryHookResult = ReturnType<typeof useGetModelsLazyQuery>;
export type GetModelsQueryResult = ApolloReactCommon.QueryResult<GetModelsQuery, GetModelsQueryVariables>;
export const GetEnumDocument = gql`
  query getEnum($name: String!) {
    getEnum(name: $name) {
      ...EnumFragment
    }
  }
  ${EnumFragmentFragmentDoc}
`;

/**
 * __useGetEnumQuery__
 *
 * To run a query within a React component, call `useGetEnumQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEnumQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEnumQuery({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useGetEnumQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<GetEnumQuery, GetEnumQueryVariables>) {
  return ApolloReactHooks.useQuery<GetEnumQuery, GetEnumQueryVariables>(GetEnumDocument, baseOptions);
}
export function useGetEnumLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetEnumQuery, GetEnumQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<GetEnumQuery, GetEnumQueryVariables>(GetEnumDocument, baseOptions);
}
export type GetEnumQueryHookResult = ReturnType<typeof useGetEnumQuery>;
export type GetEnumLazyQueryHookResult = ReturnType<typeof useGetEnumLazyQuery>;
export type GetEnumQueryResult = ApolloReactCommon.QueryResult<GetEnumQuery, GetEnumQueryVariables>;
export const UpdateModelDocument = gql`
  mutation updateModel($id: String!, $data: UpdateModelInput!) {
    updateModel(id: $id, data: $data) {
      ...ModelFragment
    }
  }
  ${ModelFragmentFragmentDoc}
`;

/**
 * __useUpdateModelMutation__
 *
 * To run a mutation, you first call `useUpdateModelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateModelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateModelMutation, { data, loading, error }] = useUpdateModelMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateModelMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateModelMutation, UpdateModelMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateModelMutation, UpdateModelMutationVariables>(
    UpdateModelDocument,
    baseOptions,
  );
}
export type UpdateModelMutationHookResult = ReturnType<typeof useUpdateModelMutation>;
export type UpdateModelMutationResult = ApolloReactCommon.MutationResult<UpdateModelMutation>;
export type UpdateModelMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateModelMutation,
  UpdateModelMutationVariables
>;
export const UpdateFieldDocument = gql`
  mutation updateField($id: String!, $modelId: String!, $data: UpdateFieldInput!) {
    updateField(id: $id, modelId: $modelId, data: $data) {
      ...FieldFragment
    }
  }
  ${FieldFragmentFragmentDoc}
`;

/**
 * __useUpdateFieldMutation__
 *
 * To run a mutation, you first call `useUpdateFieldMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFieldMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFieldMutation, { data, loading, error }] = useUpdateFieldMutation({
 *   variables: {
 *      id: // value for 'id'
 *      modelId: // value for 'modelId'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateFieldMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateFieldMutation, UpdateFieldMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateFieldMutation, UpdateFieldMutationVariables>(
    UpdateFieldDocument,
    baseOptions,
  );
}
export type UpdateFieldMutationHookResult = ReturnType<typeof useUpdateFieldMutation>;
export type UpdateFieldMutationResult = ApolloReactCommon.MutationResult<UpdateFieldMutation>;
export type UpdateFieldMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateFieldMutation,
  UpdateFieldMutationVariables
>;
export const FindOneStudentDocument = gql`
  query findOneStudent($where: StudentWhereUniqueInput!) {
    findOneStudent(where: $where) {
      ...StudentFragment
    }
  }
  ${StudentFragmentFragmentDoc}
`;

/**
 * __useFindOneStudentQuery__
 *
 * To run a query within a React component, call `useFindOneStudentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneStudentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneStudentQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneStudentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneStudentQuery, FindOneStudentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneStudentQuery, FindOneStudentQueryVariables>(
    FindOneStudentDocument,
    baseOptions,
  );
}
export function useFindOneStudentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneStudentQuery, FindOneStudentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneStudentQuery, FindOneStudentQueryVariables>(
    FindOneStudentDocument,
    baseOptions,
  );
}
export type FindOneStudentQueryHookResult = ReturnType<typeof useFindOneStudentQuery>;
export type FindOneStudentLazyQueryHookResult = ReturnType<typeof useFindOneStudentLazyQuery>;
export type FindOneStudentQueryResult = ApolloReactCommon.QueryResult<
  FindOneStudentQuery,
  FindOneStudentQueryVariables
>;
export const FindManyStudentDocument = gql`
  query findManyStudent(
    $where: StudentWhereInput
    $orderBy: StudentOrderByInput
    $after: StudentWhereUniqueInput
    $before: StudentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyStudent(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...StudentFragment
    }
  }
  ${StudentFragmentFragmentDoc}
`;

/**
 * __useFindManyStudentQuery__
 *
 * To run a query within a React component, call `useFindManyStudentQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyStudentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyStudentQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyStudentQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyStudentQuery, FindManyStudentQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyStudentQuery, FindManyStudentQueryVariables>(
    FindManyStudentDocument,
    baseOptions,
  );
}
export function useFindManyStudentLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyStudentQuery, FindManyStudentQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyStudentQuery, FindManyStudentQueryVariables>(
    FindManyStudentDocument,
    baseOptions,
  );
}
export type FindManyStudentQueryHookResult = ReturnType<typeof useFindManyStudentQuery>;
export type FindManyStudentLazyQueryHookResult = ReturnType<typeof useFindManyStudentLazyQuery>;
export type FindManyStudentQueryResult = ApolloReactCommon.QueryResult<
  FindManyStudentQuery,
  FindManyStudentQueryVariables
>;
export const FindManyStudentCountDocument = gql`
  query findManyStudentCount(
    $where: StudentWhereInput
    $orderBy: StudentOrderByInput
    $after: StudentWhereUniqueInput
    $before: StudentWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyStudentCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyStudentCountQuery__
 *
 * To run a query within a React component, call `useFindManyStudentCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyStudentCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyStudentCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyStudentCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyStudentCountQuery, FindManyStudentCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyStudentCountQuery, FindManyStudentCountQueryVariables>(
    FindManyStudentCountDocument,
    baseOptions,
  );
}
export function useFindManyStudentCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyStudentCountQuery, FindManyStudentCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyStudentCountQuery, FindManyStudentCountQueryVariables>(
    FindManyStudentCountDocument,
    baseOptions,
  );
}
export type FindManyStudentCountQueryHookResult = ReturnType<typeof useFindManyStudentCountQuery>;
export type FindManyStudentCountLazyQueryHookResult = ReturnType<typeof useFindManyStudentCountLazyQuery>;
export type FindManyStudentCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyStudentCountQuery,
  FindManyStudentCountQueryVariables
>;
export const CreateOneStudentDocument = gql`
  mutation createOneStudent($data: StudentCreateInput!) {
    createOneStudent(data: $data) {
      ...StudentFragment
    }
  }
  ${StudentFragmentFragmentDoc}
`;

/**
 * __useCreateOneStudentMutation__
 *
 * To run a mutation, you first call `useCreateOneStudentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneStudentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneStudentMutation, { data, loading, error }] = useCreateOneStudentMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneStudentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneStudentMutation, CreateOneStudentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneStudentMutation, CreateOneStudentMutationVariables>(
    CreateOneStudentDocument,
    baseOptions,
  );
}
export type CreateOneStudentMutationHookResult = ReturnType<typeof useCreateOneStudentMutation>;
export type CreateOneStudentMutationResult = ApolloReactCommon.MutationResult<CreateOneStudentMutation>;
export type CreateOneStudentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneStudentMutation,
  CreateOneStudentMutationVariables
>;
export const UpdateOneStudentDocument = gql`
  mutation updateOneStudent($where: StudentWhereUniqueInput!, $data: StudentUpdateInput!) {
    updateOneStudent(where: $where, data: $data) {
      ...StudentFragment
    }
  }
  ${StudentFragmentFragmentDoc}
`;

/**
 * __useUpdateOneStudentMutation__
 *
 * To run a mutation, you first call `useUpdateOneStudentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneStudentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneStudentMutation, { data, loading, error }] = useUpdateOneStudentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneStudentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneStudentMutation, UpdateOneStudentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneStudentMutation, UpdateOneStudentMutationVariables>(
    UpdateOneStudentDocument,
    baseOptions,
  );
}
export type UpdateOneStudentMutationHookResult = ReturnType<typeof useUpdateOneStudentMutation>;
export type UpdateOneStudentMutationResult = ApolloReactCommon.MutationResult<UpdateOneStudentMutation>;
export type UpdateOneStudentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneStudentMutation,
  UpdateOneStudentMutationVariables
>;
export const DeleteOneStudentDocument = gql`
  mutation deleteOneStudent($where: StudentWhereUniqueInput!) {
    deleteOneStudent(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneStudentMutation__
 *
 * To run a mutation, you first call `useDeleteOneStudentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneStudentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneStudentMutation, { data, loading, error }] = useDeleteOneStudentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneStudentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneStudentMutation, DeleteOneStudentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneStudentMutation, DeleteOneStudentMutationVariables>(
    DeleteOneStudentDocument,
    baseOptions,
  );
}
export type DeleteOneStudentMutationHookResult = ReturnType<typeof useDeleteOneStudentMutation>;
export type DeleteOneStudentMutationResult = ApolloReactCommon.MutationResult<DeleteOneStudentMutation>;
export type DeleteOneStudentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneStudentMutation,
  DeleteOneStudentMutationVariables
>;
export const DeleteManyStudentDocument = gql`
  mutation deleteManyStudent($where: StudentWhereInput) {
    deleteManyStudent(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyStudentMutation__
 *
 * To run a mutation, you first call `useDeleteManyStudentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyStudentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyStudentMutation, { data, loading, error }] = useDeleteManyStudentMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyStudentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyStudentMutation, DeleteManyStudentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyStudentMutation, DeleteManyStudentMutationVariables>(
    DeleteManyStudentDocument,
    baseOptions,
  );
}
export type DeleteManyStudentMutationHookResult = ReturnType<typeof useDeleteManyStudentMutation>;
export type DeleteManyStudentMutationResult = ApolloReactCommon.MutationResult<DeleteManyStudentMutation>;
export type DeleteManyStudentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyStudentMutation,
  DeleteManyStudentMutationVariables
>;
export const UpdateManyStudentDocument = gql`
  mutation updateManyStudent($where: StudentWhereInput, $data: StudentUpdateManyMutationInput!) {
    updateManyStudent(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyStudentMutation__
 *
 * To run a mutation, you first call `useUpdateManyStudentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyStudentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyStudentMutation, { data, loading, error }] = useUpdateManyStudentMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyStudentMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyStudentMutation, UpdateManyStudentMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyStudentMutation, UpdateManyStudentMutationVariables>(
    UpdateManyStudentDocument,
    baseOptions,
  );
}
export type UpdateManyStudentMutationHookResult = ReturnType<typeof useUpdateManyStudentMutation>;
export type UpdateManyStudentMutationResult = ApolloReactCommon.MutationResult<UpdateManyStudentMutation>;
export type UpdateManyStudentMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyStudentMutation,
  UpdateManyStudentMutationVariables
>;
export const FindOneUserDocument = gql`
  query findOneUser($where: UserWhereUniqueInput!) {
    findOneUser(where: $where) {
      ...UserFragment
    }
  }
  ${UserFragmentFragmentDoc}
`;

/**
 * __useFindOneUserQuery__
 *
 * To run a query within a React component, call `useFindOneUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneUserQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneUserQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindOneUserQuery, FindOneUserQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindOneUserQuery, FindOneUserQueryVariables>(FindOneUserDocument, baseOptions);
}
export function useFindOneUserLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindOneUserQuery, FindOneUserQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindOneUserQuery, FindOneUserQueryVariables>(FindOneUserDocument, baseOptions);
}
export type FindOneUserQueryHookResult = ReturnType<typeof useFindOneUserQuery>;
export type FindOneUserLazyQueryHookResult = ReturnType<typeof useFindOneUserLazyQuery>;
export type FindOneUserQueryResult = ApolloReactCommon.QueryResult<FindOneUserQuery, FindOneUserQueryVariables>;
export const FindManyUserDocument = gql`
  query findManyUser(
    $where: UserWhereInput
    $orderBy: UserOrderByInput
    $after: UserWhereUniqueInput
    $before: UserWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyUser(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...UserFragment
    }
  }
  ${UserFragmentFragmentDoc}
`;

/**
 * __useFindManyUserQuery__
 *
 * To run a query within a React component, call `useFindManyUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyUserQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyUserQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyUserQuery, FindManyUserQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyUserQuery, FindManyUserQueryVariables>(FindManyUserDocument, baseOptions);
}
export function useFindManyUserLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyUserQuery, FindManyUserQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyUserQuery, FindManyUserQueryVariables>(
    FindManyUserDocument,
    baseOptions,
  );
}
export type FindManyUserQueryHookResult = ReturnType<typeof useFindManyUserQuery>;
export type FindManyUserLazyQueryHookResult = ReturnType<typeof useFindManyUserLazyQuery>;
export type FindManyUserQueryResult = ApolloReactCommon.QueryResult<FindManyUserQuery, FindManyUserQueryVariables>;
export const FindManyUserCountDocument = gql`
  query findManyUserCount(
    $where: UserWhereInput
    $orderBy: UserOrderByInput
    $after: UserWhereUniqueInput
    $before: UserWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyUserCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyUserCountQuery__
 *
 * To run a query within a React component, call `useFindManyUserCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyUserCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyUserCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyUserCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<FindManyUserCountQuery, FindManyUserCountQueryVariables>,
) {
  return ApolloReactHooks.useQuery<FindManyUserCountQuery, FindManyUserCountQueryVariables>(
    FindManyUserCountDocument,
    baseOptions,
  );
}
export function useFindManyUserCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<FindManyUserCountQuery, FindManyUserCountQueryVariables>,
) {
  return ApolloReactHooks.useLazyQuery<FindManyUserCountQuery, FindManyUserCountQueryVariables>(
    FindManyUserCountDocument,
    baseOptions,
  );
}
export type FindManyUserCountQueryHookResult = ReturnType<typeof useFindManyUserCountQuery>;
export type FindManyUserCountLazyQueryHookResult = ReturnType<typeof useFindManyUserCountLazyQuery>;
export type FindManyUserCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyUserCountQuery,
  FindManyUserCountQueryVariables
>;
export const CreateOneUserDocument = gql`
  mutation createOneUser($data: UserCreateInput!) {
    createOneUser(data: $data) {
      ...UserFragment
    }
  }
  ${UserFragmentFragmentDoc}
`;

/**
 * __useCreateOneUserMutation__
 *
 * To run a mutation, you first call `useCreateOneUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneUserMutation, { data, loading, error }] = useCreateOneUserMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneUserMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<CreateOneUserMutation, CreateOneUserMutationVariables>,
) {
  return ApolloReactHooks.useMutation<CreateOneUserMutation, CreateOneUserMutationVariables>(
    CreateOneUserDocument,
    baseOptions,
  );
}
export type CreateOneUserMutationHookResult = ReturnType<typeof useCreateOneUserMutation>;
export type CreateOneUserMutationResult = ApolloReactCommon.MutationResult<CreateOneUserMutation>;
export type CreateOneUserMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneUserMutation,
  CreateOneUserMutationVariables
>;
export const UpdateOneUserDocument = gql`
  mutation updateOneUser($where: UserWhereUniqueInput!, $data: UserUpdateInput!) {
    updateOneUser(where: $where, data: $data) {
      ...UserFragment
    }
  }
  ${UserFragmentFragmentDoc}
`;

/**
 * __useUpdateOneUserMutation__
 *
 * To run a mutation, you first call `useUpdateOneUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneUserMutation, { data, loading, error }] = useUpdateOneUserMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneUserMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateOneUserMutation, UpdateOneUserMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateOneUserMutation, UpdateOneUserMutationVariables>(
    UpdateOneUserDocument,
    baseOptions,
  );
}
export type UpdateOneUserMutationHookResult = ReturnType<typeof useUpdateOneUserMutation>;
export type UpdateOneUserMutationResult = ApolloReactCommon.MutationResult<UpdateOneUserMutation>;
export type UpdateOneUserMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneUserMutation,
  UpdateOneUserMutationVariables
>;
export const DeleteOneUserDocument = gql`
  mutation deleteOneUser($where: UserWhereUniqueInput!) {
    deleteOneUser(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneUserMutation__
 *
 * To run a mutation, you first call `useDeleteOneUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneUserMutation, { data, loading, error }] = useDeleteOneUserMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneUserMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteOneUserMutation, DeleteOneUserMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteOneUserMutation, DeleteOneUserMutationVariables>(
    DeleteOneUserDocument,
    baseOptions,
  );
}
export type DeleteOneUserMutationHookResult = ReturnType<typeof useDeleteOneUserMutation>;
export type DeleteOneUserMutationResult = ApolloReactCommon.MutationResult<DeleteOneUserMutation>;
export type DeleteOneUserMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneUserMutation,
  DeleteOneUserMutationVariables
>;
export const DeleteManyUserDocument = gql`
  mutation deleteManyUser($where: UserWhereInput) {
    deleteManyUser(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyUserMutation__
 *
 * To run a mutation, you first call `useDeleteManyUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyUserMutation, { data, loading, error }] = useDeleteManyUserMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyUserMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<DeleteManyUserMutation, DeleteManyUserMutationVariables>,
) {
  return ApolloReactHooks.useMutation<DeleteManyUserMutation, DeleteManyUserMutationVariables>(
    DeleteManyUserDocument,
    baseOptions,
  );
}
export type DeleteManyUserMutationHookResult = ReturnType<typeof useDeleteManyUserMutation>;
export type DeleteManyUserMutationResult = ApolloReactCommon.MutationResult<DeleteManyUserMutation>;
export type DeleteManyUserMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyUserMutation,
  DeleteManyUserMutationVariables
>;
export const UpdateManyUserDocument = gql`
  mutation updateManyUser($where: UserWhereInput, $data: UserUpdateManyMutationInput!) {
    updateManyUser(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyUserMutation__
 *
 * To run a mutation, you first call `useUpdateManyUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyUserMutation, { data, loading, error }] = useUpdateManyUserMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyUserMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateManyUserMutation, UpdateManyUserMutationVariables>,
) {
  return ApolloReactHooks.useMutation<UpdateManyUserMutation, UpdateManyUserMutationVariables>(
    UpdateManyUserDocument,
    baseOptions,
  );
}
export type UpdateManyUserMutationHookResult = ReturnType<typeof useUpdateManyUserMutation>;
export type UpdateManyUserMutationResult = ApolloReactCommon.MutationResult<UpdateManyUserMutation>;
export type UpdateManyUserMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyUserMutation,
  UpdateManyUserMutationVariables
>;
export const FindOneUserLearningSettingsDocument = gql`
  query findOneUserLearningSettings($where: UserLearningSettingsWhereUniqueInput!) {
    findOneUserLearningSettings(where: $where) {
      ...UserLearningSettingsFragment
    }
  }
  ${UserLearningSettingsFragmentFragmentDoc}
`;

/**
 * __useFindOneUserLearningSettingsQuery__
 *
 * To run a query within a React component, call `useFindOneUserLearningSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindOneUserLearningSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindOneUserLearningSettingsQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useFindOneUserLearningSettingsQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindOneUserLearningSettingsQuery,
    FindOneUserLearningSettingsQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindOneUserLearningSettingsQuery, FindOneUserLearningSettingsQueryVariables>(
    FindOneUserLearningSettingsDocument,
    baseOptions,
  );
}
export function useFindOneUserLearningSettingsLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindOneUserLearningSettingsQuery,
    FindOneUserLearningSettingsQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindOneUserLearningSettingsQuery, FindOneUserLearningSettingsQueryVariables>(
    FindOneUserLearningSettingsDocument,
    baseOptions,
  );
}
export type FindOneUserLearningSettingsQueryHookResult = ReturnType<typeof useFindOneUserLearningSettingsQuery>;
export type FindOneUserLearningSettingsLazyQueryHookResult = ReturnType<typeof useFindOneUserLearningSettingsLazyQuery>;
export type FindOneUserLearningSettingsQueryResult = ApolloReactCommon.QueryResult<
  FindOneUserLearningSettingsQuery,
  FindOneUserLearningSettingsQueryVariables
>;
export const FindManyUserLearningSettingsDocument = gql`
  query findManyUserLearningSettings(
    $where: UserLearningSettingsWhereInput
    $orderBy: UserLearningSettingsOrderByInput
    $after: UserLearningSettingsWhereUniqueInput
    $before: UserLearningSettingsWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyUserLearningSettings(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    ) {
      ...UserLearningSettingsFragment
    }
  }
  ${UserLearningSettingsFragmentFragmentDoc}
`;

/**
 * __useFindManyUserLearningSettingsQuery__
 *
 * To run a query within a React component, call `useFindManyUserLearningSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyUserLearningSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyUserLearningSettingsQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyUserLearningSettingsQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyUserLearningSettingsQuery,
    FindManyUserLearningSettingsQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<FindManyUserLearningSettingsQuery, FindManyUserLearningSettingsQueryVariables>(
    FindManyUserLearningSettingsDocument,
    baseOptions,
  );
}
export function useFindManyUserLearningSettingsLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyUserLearningSettingsQuery,
    FindManyUserLearningSettingsQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<FindManyUserLearningSettingsQuery, FindManyUserLearningSettingsQueryVariables>(
    FindManyUserLearningSettingsDocument,
    baseOptions,
  );
}
export type FindManyUserLearningSettingsQueryHookResult = ReturnType<typeof useFindManyUserLearningSettingsQuery>;
export type FindManyUserLearningSettingsLazyQueryHookResult = ReturnType<
  typeof useFindManyUserLearningSettingsLazyQuery
>;
export type FindManyUserLearningSettingsQueryResult = ApolloReactCommon.QueryResult<
  FindManyUserLearningSettingsQuery,
  FindManyUserLearningSettingsQueryVariables
>;
export const FindManyUserLearningSettingsCountDocument = gql`
  query findManyUserLearningSettingsCount(
    $where: UserLearningSettingsWhereInput
    $orderBy: UserLearningSettingsOrderByInput
    $after: UserLearningSettingsWhereUniqueInput
    $before: UserLearningSettingsWhereUniqueInput
    $skip: Int
    $first: Int
    $last: Int
  ) {
    findManyUserLearningSettingsCount(
      where: $where
      orderBy: $orderBy
      after: $after
      before: $before
      skip: $skip
      first: $first
      last: $last
    )
  }
`;

/**
 * __useFindManyUserLearningSettingsCountQuery__
 *
 * To run a query within a React component, call `useFindManyUserLearningSettingsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindManyUserLearningSettingsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindManyUserLearningSettingsCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      skip: // value for 'skip'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useFindManyUserLearningSettingsCountQuery(
  baseOptions?: ApolloReactHooks.QueryHookOptions<
    FindManyUserLearningSettingsCountQuery,
    FindManyUserLearningSettingsCountQueryVariables
  >,
) {
  return ApolloReactHooks.useQuery<
    FindManyUserLearningSettingsCountQuery,
    FindManyUserLearningSettingsCountQueryVariables
  >(FindManyUserLearningSettingsCountDocument, baseOptions);
}
export function useFindManyUserLearningSettingsCountLazyQuery(
  baseOptions?: ApolloReactHooks.LazyQueryHookOptions<
    FindManyUserLearningSettingsCountQuery,
    FindManyUserLearningSettingsCountQueryVariables
  >,
) {
  return ApolloReactHooks.useLazyQuery<
    FindManyUserLearningSettingsCountQuery,
    FindManyUserLearningSettingsCountQueryVariables
  >(FindManyUserLearningSettingsCountDocument, baseOptions);
}
export type FindManyUserLearningSettingsCountQueryHookResult = ReturnType<
  typeof useFindManyUserLearningSettingsCountQuery
>;
export type FindManyUserLearningSettingsCountLazyQueryHookResult = ReturnType<
  typeof useFindManyUserLearningSettingsCountLazyQuery
>;
export type FindManyUserLearningSettingsCountQueryResult = ApolloReactCommon.QueryResult<
  FindManyUserLearningSettingsCountQuery,
  FindManyUserLearningSettingsCountQueryVariables
>;
export const CreateOneUserLearningSettingsDocument = gql`
  mutation createOneUserLearningSettings($data: UserLearningSettingsCreateInput!) {
    createOneUserLearningSettings(data: $data) {
      ...UserLearningSettingsFragment
    }
  }
  ${UserLearningSettingsFragmentFragmentDoc}
`;

/**
 * __useCreateOneUserLearningSettingsMutation__
 *
 * To run a mutation, you first call `useCreateOneUserLearningSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOneUserLearningSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOneUserLearningSettingsMutation, { data, loading, error }] = useCreateOneUserLearningSettingsMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateOneUserLearningSettingsMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    CreateOneUserLearningSettingsMutation,
    CreateOneUserLearningSettingsMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    CreateOneUserLearningSettingsMutation,
    CreateOneUserLearningSettingsMutationVariables
  >(CreateOneUserLearningSettingsDocument, baseOptions);
}
export type CreateOneUserLearningSettingsMutationHookResult = ReturnType<
  typeof useCreateOneUserLearningSettingsMutation
>;
export type CreateOneUserLearningSettingsMutationResult = ApolloReactCommon.MutationResult<
  CreateOneUserLearningSettingsMutation
>;
export type CreateOneUserLearningSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<
  CreateOneUserLearningSettingsMutation,
  CreateOneUserLearningSettingsMutationVariables
>;
export const UpdateOneUserLearningSettingsDocument = gql`
  mutation updateOneUserLearningSettings(
    $where: UserLearningSettingsWhereUniqueInput!
    $data: UserLearningSettingsUpdateInput!
  ) {
    updateOneUserLearningSettings(where: $where, data: $data) {
      ...UserLearningSettingsFragment
    }
  }
  ${UserLearningSettingsFragmentFragmentDoc}
`;

/**
 * __useUpdateOneUserLearningSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateOneUserLearningSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOneUserLearningSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOneUserLearningSettingsMutation, { data, loading, error }] = useUpdateOneUserLearningSettingsMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateOneUserLearningSettingsMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateOneUserLearningSettingsMutation,
    UpdateOneUserLearningSettingsMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateOneUserLearningSettingsMutation,
    UpdateOneUserLearningSettingsMutationVariables
  >(UpdateOneUserLearningSettingsDocument, baseOptions);
}
export type UpdateOneUserLearningSettingsMutationHookResult = ReturnType<
  typeof useUpdateOneUserLearningSettingsMutation
>;
export type UpdateOneUserLearningSettingsMutationResult = ApolloReactCommon.MutationResult<
  UpdateOneUserLearningSettingsMutation
>;
export type UpdateOneUserLearningSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateOneUserLearningSettingsMutation,
  UpdateOneUserLearningSettingsMutationVariables
>;
export const DeleteOneUserLearningSettingsDocument = gql`
  mutation deleteOneUserLearningSettings($where: UserLearningSettingsWhereUniqueInput!) {
    deleteOneUserLearningSettings(where: $where) {
      id
    }
  }
`;

/**
 * __useDeleteOneUserLearningSettingsMutation__
 *
 * To run a mutation, you first call `useDeleteOneUserLearningSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOneUserLearningSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOneUserLearningSettingsMutation, { data, loading, error }] = useDeleteOneUserLearningSettingsMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteOneUserLearningSettingsMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteOneUserLearningSettingsMutation,
    DeleteOneUserLearningSettingsMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteOneUserLearningSettingsMutation,
    DeleteOneUserLearningSettingsMutationVariables
  >(DeleteOneUserLearningSettingsDocument, baseOptions);
}
export type DeleteOneUserLearningSettingsMutationHookResult = ReturnType<
  typeof useDeleteOneUserLearningSettingsMutation
>;
export type DeleteOneUserLearningSettingsMutationResult = ApolloReactCommon.MutationResult<
  DeleteOneUserLearningSettingsMutation
>;
export type DeleteOneUserLearningSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteOneUserLearningSettingsMutation,
  DeleteOneUserLearningSettingsMutationVariables
>;
export const DeleteManyUserLearningSettingsDocument = gql`
  mutation deleteManyUserLearningSettings($where: UserLearningSettingsWhereInput) {
    deleteManyUserLearningSettings(where: $where) {
      count
    }
  }
`;

/**
 * __useDeleteManyUserLearningSettingsMutation__
 *
 * To run a mutation, you first call `useDeleteManyUserLearningSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteManyUserLearningSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteManyUserLearningSettingsMutation, { data, loading, error }] = useDeleteManyUserLearningSettingsMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteManyUserLearningSettingsMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    DeleteManyUserLearningSettingsMutation,
    DeleteManyUserLearningSettingsMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    DeleteManyUserLearningSettingsMutation,
    DeleteManyUserLearningSettingsMutationVariables
  >(DeleteManyUserLearningSettingsDocument, baseOptions);
}
export type DeleteManyUserLearningSettingsMutationHookResult = ReturnType<
  typeof useDeleteManyUserLearningSettingsMutation
>;
export type DeleteManyUserLearningSettingsMutationResult = ApolloReactCommon.MutationResult<
  DeleteManyUserLearningSettingsMutation
>;
export type DeleteManyUserLearningSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<
  DeleteManyUserLearningSettingsMutation,
  DeleteManyUserLearningSettingsMutationVariables
>;
export const UpdateManyUserLearningSettingsDocument = gql`
  mutation updateManyUserLearningSettings(
    $where: UserLearningSettingsWhereInput
    $data: UserLearningSettingsUpdateManyMutationInput!
  ) {
    updateManyUserLearningSettings(where: $where, data: $data) {
      count
    }
  }
`;

/**
 * __useUpdateManyUserLearningSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateManyUserLearningSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateManyUserLearningSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateManyUserLearningSettingsMutation, { data, loading, error }] = useUpdateManyUserLearningSettingsMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateManyUserLearningSettingsMutation(
  baseOptions?: ApolloReactHooks.MutationHookOptions<
    UpdateManyUserLearningSettingsMutation,
    UpdateManyUserLearningSettingsMutationVariables
  >,
) {
  return ApolloReactHooks.useMutation<
    UpdateManyUserLearningSettingsMutation,
    UpdateManyUserLearningSettingsMutationVariables
  >(UpdateManyUserLearningSettingsDocument, baseOptions);
}
export type UpdateManyUserLearningSettingsMutationHookResult = ReturnType<
  typeof useUpdateManyUserLearningSettingsMutation
>;
export type UpdateManyUserLearningSettingsMutationResult = ApolloReactCommon.MutationResult<
  UpdateManyUserLearningSettingsMutation
>;
export type UpdateManyUserLearningSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<
  UpdateManyUserLearningSettingsMutation,
  UpdateManyUserLearningSettingsMutationVariables
>;
